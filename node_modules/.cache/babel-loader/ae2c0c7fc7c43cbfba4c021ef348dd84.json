{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '@firebase/util';\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\nvar FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nvar FCM_TOKEN_DETAILS_DB_VERSION = 1;\nvar TokenManager = /** @class */function () {\n  function TokenManager() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n    this.openDbPromise_ = null;\n  }\n  /**\n   * Get the indexedDB as a promsie.\n   * @private\n   * @return {Promise<IDBDatabase>} The IndexedDB database\n   */\n  TokenManager.prototype.openDatabase_ = function () {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_;\n    }\n    this.openDbPromise_ = new Promise(function (resolve, reject) {\n      var request = indexedDB.open(TokenManager.DB_NAME, FCM_TOKEN_DETAILS_DB_VERSION);\n      request.onerror = function (event) {\n        reject(event.target.error);\n      };\n      request.onsuccess = function (event) {\n        resolve(event.target.result);\n      };\n      request.onupgradeneeded = function (event) {\n        var db = event.target.result;\n        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n          keyPath: 'swScope'\n        });\n        // Make sure the sender ID can be searched\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n        objectStore.createIndex('fcmToken', 'fcmToken', {\n          unique: true\n        });\n      };\n    });\n    return this.openDbPromise_;\n  };\n  /**\n   * Close the currently open database.\n   * @return {Promise<?>} Returns the result of the promise chain.\n   */\n  TokenManager.prototype.closeDatabase = function () {\n    var _this = this;\n    if (this.openDbPromise_) {\n      return this.openDbPromise_.then(function (db) {\n        db.close();\n        _this.openDbPromise_ = null;\n      });\n    }\n    return Promise.resolve();\n  };\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   * @public\n   * @param {string} fcmToken\n   * @return {Promise<Object>} The details associated with that token.\n   */\n  TokenManager.prototype.getTokenDetailsFromToken = function (fcmToken) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var index = objectStore.index('fcmToken');\n        var request = index.get(fcmToken);\n        request.onerror = function (event) {\n          reject(event.target.error);\n        };\n        request.onsuccess = function (event) {\n          resolve(event.target.result);\n        };\n      });\n    });\n  };\n  TokenManager.prototype.getTokenDetailsFromSWScope_ = function (swScope) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var scopeRequest = objectStore.get(swScope);\n        scopeRequest.onerror = function (event) {\n          reject(event.target.error);\n        };\n        scopeRequest.onsuccess = function (event) {\n          resolve(event.target.result);\n        };\n      });\n    });\n  };\n  TokenManager.prototype.getAllTokenDetailsForSenderId_ = function (senderId) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var senderIdTokens = [];\n        var cursorRequest = objectStore.openCursor();\n        cursorRequest.onerror = function (event) {\n          reject(event.target.error);\n        };\n        cursorRequest.onsuccess = function (event) {\n          var cursor = event.target.result;\n          if (cursor) {\n            if (cursor.value['fcmSenderId'] === senderId) {\n              senderIdTokens.push(cursor.value);\n            }\n            cursor.continue();\n          } else {\n            resolve(senderIdTokens);\n          }\n        };\n      });\n    });\n  };\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {string=} pushSet If defined this will swap the subscription for\n   * matching FCM token.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n  TokenManager.prototype.subscribeToFCM = function (senderId, subscription, pushSet) {\n    var _this = this;\n    var p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    var auth = arrayBufferToBase64(subscription['getKey']('auth'));\n    var fcmSubscribeBody = \"authorized_entity=\" + senderId + \"&\" + (\"endpoint=\" + subscription.endpoint + \"&\") + (\"encryption_key=\" + p256dh + \"&\") + (\"encryption_auth=\" + auth);\n    if (pushSet) {\n      fcmSubscribeBody += \"&pushSet=\" + pushSet;\n    }\n    var headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n    var subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n    return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe', subscribeOptions).then(function (response) {\n      return response.json();\n    }).then(function (response) {\n      var fcmTokenResponse = response;\n      if (fcmTokenResponse['error']) {\n        var message = fcmTokenResponse['error']['message'];\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n          message: message\n        });\n      }\n      if (!fcmTokenResponse['token']) {\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN);\n      }\n      if (!fcmTokenResponse['pushSet']) {\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);\n      }\n      return {\n        token: fcmTokenResponse['token'],\n        pushSet: fcmTokenResponse['pushSet']\n      };\n    });\n  };\n  /**\n   * Checks the that fields in the PushSubscription are equivalent to the\n   * details stores in the masterTokenDetails.\n   * @private\n   * @param  {PushSubscription} subscription The push subscription we expect\n   * the master token to match.\n   * @param  {Object}  masterTokenDetails The saved details we wish to compare\n   * with the PushSubscription\n   * @return {boolean} true if the subscription and token details are\n   * equivalent.\n   */\n  TokenManager.prototype.isSameSubscription_ = function (subscription, masterTokenDetails) {\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return subscription.endpoint === masterTokenDetails['endpoint'] && arrayBufferToBase64(subscription['getKey']('auth')) === masterTokenDetails['auth'] && arrayBufferToBase64(subscription['getKey']('p256dh')) === masterTokenDetails['p256dh'];\n  };\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @private\n   * @param  {string} senderId The 'messagingSenderId' used for this project\n   * @param  {ServiceWorkerRegistration} swRegistration The service worker\n   * used to subscribe the user for web push\n   * @param  {PushSubscription} subscription The push subscription passed to\n   * FCM for the current token.\n   * @param  {string} fcmToken The FCM token currently used on this\n   * device.\n   * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n   * @return {Promise<void>}\n   */\n  TokenManager.prototype.saveTokenDetails_ = function (senderId, swRegistration, subscription, fcmToken, fcmPushSet) {\n    var details = {\n      swScope: swRegistration.scope,\n      endpoint: subscription.endpoint,\n      auth: arrayBufferToBase64(subscription['getKey']('auth')),\n      p256dh: arrayBufferToBase64(subscription['getKey']('p256dh')),\n      fcmToken: fcmToken,\n      fcmPushSet: fcmPushSet,\n      fcmSenderId: senderId\n    };\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var request = objectStore.put(details);\n        request.onerror = function (event) {\n          reject(event.target.error);\n        };\n        request.onsuccess = function (event) {\n          resolve();\n        };\n      });\n    });\n  };\n  /**\n   * Returns the saved FCM Token if one is available and still valid,\n   * otherwise `null` is returned.\n   * @param {string} senderId This should be the sender ID associated with the\n   * FCM Token being retrieved.\n   * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n   * to subscribe the user to push.\n   * @return {Promise<string> | Promise} Returns the saved FCM Token if\n   * avilable and valid.\n   * @export\n   */\n  TokenManager.prototype.getSavedToken = function (senderId, swRegistration) {\n    var _this = this;\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n    }\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n    }\n    return this.getAllTokenDetailsForSenderId_(senderId).then(function (allTokenDetails) {\n      if (allTokenDetails.length === 0) {\n        return;\n      }\n      var index = allTokenDetails.findIndex(function (tokenDetails) {\n        return swRegistration.scope === tokenDetails['swScope'] && senderId === tokenDetails['fcmSenderId'];\n      });\n      if (index === -1) {\n        return;\n      }\n      return allTokenDetails[index];\n    }).then(function (tokenDetails) {\n      if (!tokenDetails) {\n        return;\n      }\n      return swRegistration.pushManager.getSubscription().catch(function (err) {\n        throw _this.errorFactory_.create(Errors.codes.GET_SUBSCRIPTION_FAILED);\n      }).then(function (subscription) {\n        if (subscription && _this.isSameSubscription_(subscription, tokenDetails)) {\n          return tokenDetails['fcmToken'];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new FCM token.\n   */\n  TokenManager.prototype.createToken = function (senderId, swRegistration) {\n    var _this = this;\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n    }\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n    }\n    // Check for existing subscription first\n    var subscription;\n    var fcmTokenDetails;\n    return swRegistration.pushManager.getSubscription().then(function (subscription) {\n      if (subscription) {\n        return subscription;\n      }\n      return swRegistration.pushManager.subscribe(FCMDetails.SUBSCRIPTION_OPTIONS);\n    }).then(function (sub) {\n      subscription = sub;\n      return _this.subscribeToFCM(senderId, subscription);\n    }).then(function (tokenDetails) {\n      fcmTokenDetails = tokenDetails;\n      return _this.saveTokenDetails_(senderId, swRegistration, subscription, fcmTokenDetails['token'], fcmTokenDetails['pushSet']);\n    }).then(function () {\n      return fcmTokenDetails['token'];\n    });\n  };\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   * @param {string} token Token to be deleted\n   * @return {Promise<Object>} Resolves once the FCM token details have been\n   * deleted and returns the deleted details.\n   */\n  TokenManager.prototype.deleteToken = function (token) {\n    var _this = this;\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN));\n    }\n    return this.getTokenDetailsFromToken(token).then(function (details) {\n      if (!details) {\n        throw _this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n      }\n      return _this.openDatabase_().then(function (db) {\n        return new Promise(function (resolve, reject) {\n          var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n          var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n          var request = objectStore.delete(details['swScope']);\n          request.onerror = function (event) {\n            reject(event.target.error);\n          };\n          request.onsuccess = function (event) {\n            if (event.target.result === 0) {\n              reject(_this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN));\n              return;\n            }\n            resolve(details);\n          };\n        });\n      });\n    });\n  };\n  return TokenManager;\n}();\nexport default TokenManager;","map":{"version":3,"mappings":"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","names":["ErrorFactory","Errors","arrayBufferToBase64","FCMDetails","FCM_TOKEN_OBJ_STORE","FCM_TOKEN_DETAILS_DB_VERSION","errorFactory_","map","openDbPromise_","TokenManager","Promise","resolve","reject","request","indexedDB","open","DB_NAME","onerror","event","target","error","onsuccess","result","onupgradeneeded","db","objectStore","createObjectStore","keyPath","createIndex","unique","then","close","_this","fcmToken","openDatabase_","transaction","index","get","swScope","scopeRequest","senderId","senderIdTokens","cursorRequest","openCursor","cursor","value","push","continue","subscription","pushSet","p256dh","auth","fcmSubscribeBody","endpoint","headers","Headers","append","subscribeOptions","method","body","fetch","ENDPOINT","json","fcmTokenResponse","response","message","create","codes","TOKEN_SUBSCRIBE_FAILED","TOKEN_SUBSCRIBE_NO_TOKEN","TOKEN_SUBSCRIBE_NO_PUSH_SET","token","masterTokenDetails","swRegistration","fcmPushSet","details","scope","fcmSenderId","put","ServiceWorkerRegistration","SW_REGISTRATION_EXPECTED","length","BAD_SENDER_ID","getAllTokenDetailsForSenderId_","allTokenDetails","findIndex","tokenDetails","pushManager","getSubscription","catch","GET_SUBSCRIPTION_FAILED","isSameSubscription_","fcmTokenDetails","subscribe","SUBSCRIPTION_OPTIONS","sub","subscribeToFCM","saveTokenDetails_","INVALID_DELETE_TOKEN","getTokenDetailsFromToken","DELETE_TOKEN_NOT_FOUND","delete","FAILED_TO_DELETE_TOKEN"],"sources":["../src/models/token-manager.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '@firebase/util';\n\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\n\nconst FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nconst FCM_TOKEN_DETAILS_DB_VERSION = 1;\n\nexport default class TokenManager {\n  private errorFactory_: ErrorFactory<string>;\n  private openDbPromise_: Promise<IDBDatabase>;\n\n  static DB_NAME: 'fcm_token_details_db';\n\n  constructor() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n    this.openDbPromise_ = null;\n  }\n\n  /**\n   * Get the indexedDB as a promsie.\n   * @private\n   * @return {Promise<IDBDatabase>} The IndexedDB database\n   */\n  openDatabase_() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_;\n    }\n\n    this.openDbPromise_ = new Promise((resolve, reject) => {\n      const request = indexedDB.open(\n        TokenManager.DB_NAME,\n        FCM_TOKEN_DETAILS_DB_VERSION\n      );\n      request.onerror = event => {\n        reject((<IDBRequest>event.target).error);\n      };\n      request.onsuccess = event => {\n        resolve((<IDBRequest>event.target).result);\n      };\n      request.onupgradeneeded = event => {\n        var db = (<IDBRequest>event.target).result;\n\n        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n          keyPath: 'swScope'\n        });\n\n        // Make sure the sender ID can be searched\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n\n        objectStore.createIndex('fcmToken', 'fcmToken', {\n          unique: true\n        });\n      };\n    });\n\n    return this.openDbPromise_;\n  }\n\n  /**\n   * Close the currently open database.\n   * @return {Promise<?>} Returns the result of the promise chain.\n   */\n  closeDatabase() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_.then(db => {\n        db.close();\n        this.openDbPromise_ = null;\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   * @public\n   * @param {string} fcmToken\n   * @return {Promise<Object>} The details associated with that token.\n   */\n  getTokenDetailsFromToken(fcmToken) {\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const index = objectStore.index('fcmToken');\n        const request = index.get(fcmToken);\n        request.onerror = function(event) {\n          reject((<IDBRequest>event.target).error);\n        };\n        request.onsuccess = function(event) {\n          resolve((<IDBRequest>event.target).result);\n        };\n      });\n    });\n  }\n\n  getTokenDetailsFromSWScope_(swScope) {\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const scopeRequest = objectStore.get(swScope);\n        scopeRequest.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n\n        scopeRequest.onsuccess = event => {\n          resolve((<IDBRequest>event.target).result);\n        };\n      });\n    });\n  }\n\n  getAllTokenDetailsForSenderId_(senderId): Promise<Array<Object>> {\n    return this.openDatabase_().then(db => {\n      return new Promise<Array<Object>>((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n\n        const senderIdTokens = [];\n\n        const cursorRequest = objectStore.openCursor();\n        cursorRequest.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n\n        cursorRequest.onsuccess = event => {\n          const cursor = (<IDBRequest>event.target).result;\n          if (cursor) {\n            if (cursor.value['fcmSenderId'] === senderId) {\n              senderIdTokens.push(cursor.value);\n            }\n            cursor.continue();\n          } else {\n            resolve(senderIdTokens);\n          }\n        };\n      });\n    });\n  }\n\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {string=} pushSet If defined this will swap the subscription for\n   * matching FCM token.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n  subscribeToFCM(senderId, subscription, pushSet?): Promise<Object> {\n    const p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    const auth = arrayBufferToBase64(subscription['getKey']('auth'));\n\n    let fcmSubscribeBody =\n      `authorized_entity=${senderId}&` +\n      `endpoint=${subscription.endpoint}&` +\n      `encryption_key=${p256dh}&` +\n      `encryption_auth=${auth}`;\n\n    if (pushSet) {\n      fcmSubscribeBody += `&pushSet=${pushSet}`;\n    }\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n    const subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n\n    return fetch(\n      FCMDetails.ENDPOINT + '/fcm/connect/subscribe',\n      subscribeOptions\n    )\n      .then(response => response.json())\n      .then(response => {\n        const fcmTokenResponse = response;\n        if (fcmTokenResponse['error']) {\n          const message = fcmTokenResponse['error']['message'];\n          throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n            message: message\n          });\n        }\n\n        if (!fcmTokenResponse['token']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN\n          );\n        }\n\n        if (!fcmTokenResponse['pushSet']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET\n          );\n        }\n\n        return {\n          token: fcmTokenResponse['token'],\n          pushSet: fcmTokenResponse['pushSet']\n        };\n      });\n  }\n\n  /**\n   * Checks the that fields in the PushSubscription are equivalent to the\n   * details stores in the masterTokenDetails.\n   * @private\n   * @param  {PushSubscription} subscription The push subscription we expect\n   * the master token to match.\n   * @param  {Object}  masterTokenDetails The saved details we wish to compare\n   * with the PushSubscription\n   * @return {boolean} true if the subscription and token details are\n   * equivalent.\n   */\n  isSameSubscription_(subscription, masterTokenDetails) {\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return (\n      subscription.endpoint === masterTokenDetails['endpoint'] &&\n      arrayBufferToBase64(subscription['getKey']('auth')) ===\n        masterTokenDetails['auth'] &&\n      arrayBufferToBase64(subscription['getKey']('p256dh')) ===\n        masterTokenDetails['p256dh']\n    );\n  }\n\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @private\n   * @param  {string} senderId The 'messagingSenderId' used for this project\n   * @param  {ServiceWorkerRegistration} swRegistration The service worker\n   * used to subscribe the user for web push\n   * @param  {PushSubscription} subscription The push subscription passed to\n   * FCM for the current token.\n   * @param  {string} fcmToken The FCM token currently used on this\n   * device.\n   * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n   * @return {Promise<void>}\n   */\n  saveTokenDetails_(\n    senderId,\n    swRegistration,\n    subscription,\n    fcmToken,\n    fcmPushSet\n  ) {\n    const details = {\n      swScope: swRegistration.scope,\n      endpoint: subscription.endpoint,\n      auth: arrayBufferToBase64(subscription['getKey']('auth')),\n      p256dh: arrayBufferToBase64(subscription['getKey']('p256dh')),\n      fcmToken: fcmToken,\n      fcmPushSet: fcmPushSet,\n      fcmSenderId: senderId\n    };\n\n    return this.openDatabase_().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const request = objectStore.put(details);\n        request.onerror = event => {\n          reject((<IDBRequest>event.target).error);\n        };\n        request.onsuccess = event => {\n          resolve();\n        };\n      });\n    });\n  }\n\n  /**\n   * Returns the saved FCM Token if one is available and still valid,\n   * otherwise `null` is returned.\n   * @param {string} senderId This should be the sender ID associated with the\n   * FCM Token being retrieved.\n   * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n   * to subscribe the user to push.\n   * @return {Promise<string> | Promise} Returns the saved FCM Token if\n   * avilable and valid.\n   * @export\n   */\n  getSavedToken(senderId, swRegistration) {\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED)\n      );\n    }\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.BAD_SENDER_ID)\n      );\n    }\n\n    return this.getAllTokenDetailsForSenderId_(senderId)\n      .then(allTokenDetails => {\n        if (allTokenDetails.length === 0) {\n          return;\n        }\n\n        const index = allTokenDetails.findIndex(tokenDetails => {\n          return (\n            swRegistration.scope === tokenDetails['swScope'] &&\n            senderId === tokenDetails['fcmSenderId']\n          );\n        });\n\n        if (index === -1) {\n          return;\n        }\n\n        return allTokenDetails[index];\n      })\n      .then(tokenDetails => {\n        if (!tokenDetails) {\n          return;\n        }\n\n        return swRegistration.pushManager\n          .getSubscription()\n          .catch(err => {\n            throw this.errorFactory_.create(\n              Errors.codes.GET_SUBSCRIPTION_FAILED\n            );\n          })\n          .then(subscription => {\n            if (\n              subscription &&\n              this.isSameSubscription_(subscription, tokenDetails)\n            ) {\n              return tokenDetails['fcmToken'];\n            }\n          });\n      });\n  }\n\n  /**\n   * Creates a new FCM token.\n   */\n  createToken(senderId, swRegistration): Promise<String> {\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.BAD_SENDER_ID)\n      );\n    }\n\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED)\n      );\n    }\n\n    // Check for existing subscription first\n    let subscription;\n    let fcmTokenDetails;\n    return swRegistration.pushManager\n      .getSubscription()\n      .then(subscription => {\n        if (subscription) {\n          return subscription;\n        }\n\n        return swRegistration.pushManager.subscribe(\n          FCMDetails.SUBSCRIPTION_OPTIONS\n        );\n      })\n      .then(sub => {\n        subscription = sub;\n        return this.subscribeToFCM(senderId, subscription);\n      })\n      .then(tokenDetails => {\n        fcmTokenDetails = tokenDetails;\n        return this.saveTokenDetails_(\n          senderId,\n          swRegistration,\n          subscription,\n          fcmTokenDetails['token'],\n          fcmTokenDetails['pushSet']\n        );\n      })\n      .then(() => fcmTokenDetails['token']);\n  }\n\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   * @param {string} token Token to be deleted\n   * @return {Promise<Object>} Resolves once the FCM token details have been\n   * deleted and returns the deleted details.\n   */\n  deleteToken(token) {\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN)\n      );\n    }\n\n    return this.getTokenDetailsFromToken(token).then(details => {\n      if (!details) {\n        throw this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n      }\n\n      return this.openDatabase_().then(db => {\n        return new Promise((resolve, reject) => {\n          const transaction = db.transaction(\n            [FCM_TOKEN_OBJ_STORE],\n            'readwrite'\n          );\n          const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n          const request = objectStore.delete(details['swScope']);\n          request.onerror = event => {\n            reject((<IDBRequest>event.target).error);\n          };\n          request.onsuccess = event => {\n            if ((<IDBRequest>event.target).result === 0) {\n              reject(\n                this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN)\n              );\n              return;\n            }\n\n            resolve(details);\n          };\n        });\n      });\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}