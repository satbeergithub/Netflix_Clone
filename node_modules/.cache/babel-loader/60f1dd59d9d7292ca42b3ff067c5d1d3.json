{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar SortedMap_1 = require(\"./SortedMap\");\nvar Path_1 = require(\"./Path\");\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"@firebase/util\");\nvar emptyChildrenSingleton;\n/**\n * Singleton empty children collection.\n *\n * @const\n * @type {!SortedMap.<string, !ImmutableTree.<?>>}\n */\nvar EmptyChildren = function EmptyChildren() {\n  if (!emptyChildrenSingleton) {\n    emptyChildrenSingleton = new SortedMap_1.SortedMap(util_1.stringCompare);\n  }\n  return emptyChildrenSingleton;\n};\n/**\n * A tree with immutable elements.\n */\nvar ImmutableTree = /** @class */function () {\n  /**\n   * @template T\n   * @param {?T} value\n   * @param {SortedMap.<string, !ImmutableTree.<T>>=} children\n   */\n  function ImmutableTree(value, children) {\n    if (children === void 0) {\n      children = EmptyChildren();\n    }\n    this.value = value;\n    this.children = children;\n  }\n  /**\n   * @template T\n   * @param {!Object.<string, !T>} obj\n   * @return {!ImmutableTree.<!T>}\n   */\n  ImmutableTree.fromObject = function (obj) {\n    var tree = ImmutableTree.Empty;\n    util_2.forEach(obj, function (childPath, childSnap) {\n      tree = tree.set(new Path_1.Path(childPath), childSnap);\n    });\n    return tree;\n  };\n  /**\n   * True if the value is empty and there are no children\n   * @return {boolean}\n   */\n  ImmutableTree.prototype.isEmpty = function () {\n    return this.value === null && this.children.isEmpty();\n  };\n  /**\n   * Given a path and predicate, return the first node and the path to that node\n   * where the predicate returns true.\n   *\n   * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects\n   * on the way back out, it may be better to pass down a pathSoFar obj.\n   *\n   * @param {!Path} relativePath The remainder of the path\n   * @param {function(T):boolean} predicate The predicate to satisfy to return a\n   *   node\n   * @return {?{path:!Path, value:!T}}\n   */\n  ImmutableTree.prototype.findRootMostMatchingPathAndValue = function (relativePath, predicate) {\n    if (this.value != null && predicate(this.value)) {\n      return {\n        path: Path_1.Path.Empty,\n        value: this.value\n      };\n    } else {\n      if (relativePath.isEmpty()) {\n        return null;\n      } else {\n        var front = relativePath.getFront();\n        var child = this.children.get(front);\n        if (child !== null) {\n          var childExistingPathAndValue = child.findRootMostMatchingPathAndValue(relativePath.popFront(), predicate);\n          if (childExistingPathAndValue != null) {\n            var fullPath = new Path_1.Path(front).child(childExistingPathAndValue.path);\n            return {\n              path: fullPath,\n              value: childExistingPathAndValue.value\n            };\n          } else {\n            return null;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n  };\n  /**\n   * Find, if it exists, the shortest subpath of the given path that points a defined\n   * value in the tree\n   * @param {!Path} relativePath\n   * @return {?{path: !Path, value: !T}}\n   */\n  ImmutableTree.prototype.findRootMostValueAndPath = function (relativePath) {\n    return this.findRootMostMatchingPathAndValue(relativePath, function () {\n      return true;\n    });\n  };\n  /**\n   * @param {!Path} relativePath\n   * @return {!ImmutableTree.<T>} The subtree at the given path\n   */\n  ImmutableTree.prototype.subtree = function (relativePath) {\n    if (relativePath.isEmpty()) {\n      return this;\n    } else {\n      var front = relativePath.getFront();\n      var childTree = this.children.get(front);\n      if (childTree !== null) {\n        return childTree.subtree(relativePath.popFront());\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  };\n  /**\n   * Sets a value at the specified path.\n   *\n   * @param {!Path} relativePath Path to set value at.\n   * @param {?T} toSet Value to set.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  ImmutableTree.prototype.set = function (relativePath, toSet) {\n    if (relativePath.isEmpty()) {\n      return new ImmutableTree(toSet, this.children);\n    } else {\n      var front = relativePath.getFront();\n      var child = this.children.get(front) || ImmutableTree.Empty;\n      var newChild = child.set(relativePath.popFront(), toSet);\n      var newChildren = this.children.insert(front, newChild);\n      return new ImmutableTree(this.value, newChildren);\n    }\n  };\n  /**\n   * Removes the value at the specified path.\n   *\n   * @param {!Path} relativePath Path to value to remove.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  ImmutableTree.prototype.remove = function (relativePath) {\n    if (relativePath.isEmpty()) {\n      if (this.children.isEmpty()) {\n        return ImmutableTree.Empty;\n      } else {\n        return new ImmutableTree(null, this.children);\n      }\n    } else {\n      var front = relativePath.getFront();\n      var child = this.children.get(front);\n      if (child) {\n        var newChild = child.remove(relativePath.popFront());\n        var newChildren = void 0;\n        if (newChild.isEmpty()) {\n          newChildren = this.children.remove(front);\n        } else {\n          newChildren = this.children.insert(front, newChild);\n        }\n        if (this.value === null && newChildren.isEmpty()) {\n          return ImmutableTree.Empty;\n        } else {\n          return new ImmutableTree(this.value, newChildren);\n        }\n      } else {\n        return this;\n      }\n    }\n  };\n  /**\n   * Gets a value from the tree.\n   *\n   * @param {!Path} relativePath Path to get value for.\n   * @return {?T} Value at path, or null.\n   */\n  ImmutableTree.prototype.get = function (relativePath) {\n    if (relativePath.isEmpty()) {\n      return this.value;\n    } else {\n      var front = relativePath.getFront();\n      var child = this.children.get(front);\n      if (child) {\n        return child.get(relativePath.popFront());\n      } else {\n        return null;\n      }\n    }\n  };\n  /**\n   * Replace the subtree at the specified path with the given new tree.\n   *\n   * @param {!Path} relativePath Path to replace subtree for.\n   * @param {!ImmutableTree} newTree New tree.\n   * @return {!ImmutableTree} Resulting tree.\n   */\n  ImmutableTree.prototype.setTree = function (relativePath, newTree) {\n    if (relativePath.isEmpty()) {\n      return newTree;\n    } else {\n      var front = relativePath.getFront();\n      var child = this.children.get(front) || ImmutableTree.Empty;\n      var newChild = child.setTree(relativePath.popFront(), newTree);\n      var newChildren = void 0;\n      if (newChild.isEmpty()) {\n        newChildren = this.children.remove(front);\n      } else {\n        newChildren = this.children.insert(front, newChild);\n      }\n      return new ImmutableTree(this.value, newChildren);\n    }\n  };\n  /**\n   * Performs a depth first fold on this tree. Transforms a tree into a single\n   * value, given a function that operates on the path to a node, an optional\n   * current value, and a map of child names to folded subtrees\n   * @template V\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   */\n  ImmutableTree.prototype.fold = function (fn) {\n    return this.fold_(Path_1.Path.Empty, fn);\n  };\n  /**\n   * Recursive helper for public-facing fold() method\n   * @template V\n   * @param {!Path} pathSoFar\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   * @private\n   */\n  ImmutableTree.prototype.fold_ = function (pathSoFar, fn) {\n    var accum = {};\n    this.children.inorderTraversal(function (childKey, childTree) {\n      accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);\n    });\n    return fn(pathSoFar, this.value, accum);\n  };\n  /**\n   * Find the first matching value on the given path. Return the result of applying f to it.\n   * @template V\n   * @param {!Path} path\n   * @param {!function(!Path, !T):?V} f\n   * @return {?V}\n   */\n  ImmutableTree.prototype.findOnPath = function (path, f) {\n    return this.findOnPath_(path, Path_1.Path.Empty, f);\n  };\n  ImmutableTree.prototype.findOnPath_ = function (pathToFollow, pathSoFar, f) {\n    var result = this.value ? f(pathSoFar, this.value) : false;\n    if (result) {\n      return result;\n    } else {\n      if (pathToFollow.isEmpty()) {\n        return null;\n      } else {\n        var front = pathToFollow.getFront();\n        var nextChild = this.children.get(front);\n        if (nextChild) {\n          return nextChild.findOnPath_(pathToFollow.popFront(), pathSoFar.child(front), f);\n        } else {\n          return null;\n        }\n      }\n    }\n  };\n  /**\n   *\n   * @param {!Path} path\n   * @param {!function(!Path, !T)} f\n   * @returns {!ImmutableTree.<T>}\n   */\n  ImmutableTree.prototype.foreachOnPath = function (path, f) {\n    return this.foreachOnPath_(path, Path_1.Path.Empty, f);\n  };\n  ImmutableTree.prototype.foreachOnPath_ = function (pathToFollow, currentRelativePath, f) {\n    if (pathToFollow.isEmpty()) {\n      return this;\n    } else {\n      if (this.value) {\n        f(currentRelativePath, this.value);\n      }\n      var front = pathToFollow.getFront();\n      var nextChild = this.children.get(front);\n      if (nextChild) {\n        return nextChild.foreachOnPath_(pathToFollow.popFront(), currentRelativePath.child(front), f);\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  };\n  /**\n   * Calls the given function for each node in the tree that has a value.\n   *\n   * @param {function(!Path, !T)} f A function to be called with\n   *   the path from the root of the tree to a node, and the value at that node.\n   *   Called in depth-first order.\n   */\n  ImmutableTree.prototype.foreach = function (f) {\n    this.foreach_(Path_1.Path.Empty, f);\n  };\n  ImmutableTree.prototype.foreach_ = function (currentRelativePath, f) {\n    this.children.inorderTraversal(function (childName, childTree) {\n      childTree.foreach_(currentRelativePath.child(childName), f);\n    });\n    if (this.value) {\n      f(currentRelativePath, this.value);\n    }\n  };\n  /**\n   *\n   * @param {function(string, !T)} f\n   */\n  ImmutableTree.prototype.foreachChild = function (f) {\n    this.children.inorderTraversal(function (childName, childTree) {\n      if (childTree.value) {\n        f(childName, childTree.value);\n      }\n    });\n  };\n  ImmutableTree.Empty = new ImmutableTree(null);\n  return ImmutableTree;\n}();\nexports.ImmutableTree = ImmutableTree;","map":{"version":3,"mappings":"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","names":["emptyChildrenSingleton","EmptyChildren","SortedMap_1","util_1","value","children","ImmutableTree","obj","tree","Empty","util_2","childPath","childSnap","set","Path_1","isEmpty","relativePath","predicate","path","front","getFront","child","get","childExistingPathAndValue","findRootMostMatchingPathAndValue","popFront","fullPath","childTree","subtree","toSet","newChild","newChildren","insert","remove","newTree","setTree","fn","fold_","pathSoFar","accum","inorderTraversal","childKey","f","findOnPath_","pathToFollow","result","nextChild","foreachOnPath_","currentRelativePath","foreach_","childName","exports"],"sources":["../src/core/util/ImmutableTree.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SortedMap } from './SortedMap';\nimport { Path } from './Path';\nimport { stringCompare } from './util';\nimport { forEach } from '@firebase/util';\n\nlet emptyChildrenSingleton: SortedMap<string, ImmutableTree<null>>;\n\n/**\n * Singleton empty children collection.\n *\n * @const\n * @type {!SortedMap.<string, !ImmutableTree.<?>>}\n */\nconst EmptyChildren = (): SortedMap<string, ImmutableTree<null>> => {\n  if (!emptyChildrenSingleton) {\n    emptyChildrenSingleton = new SortedMap<string, ImmutableTree<null>>(\n      stringCompare\n    );\n  }\n  return emptyChildrenSingleton;\n};\n\n/**\n * A tree with immutable elements.\n */\nexport class ImmutableTree<T> {\n  static Empty = new ImmutableTree<any>(null);\n\n  /**\n   * @template T\n   * @param {!Object.<string, !T>} obj\n   * @return {!ImmutableTree.<!T>}\n   */\n  static fromObject<T>(obj: { [k: string]: T }): ImmutableTree<T> {\n    let tree: ImmutableTree<T> = ImmutableTree.Empty;\n    forEach(obj, (childPath: string, childSnap: T) => {\n      tree = tree.set(new Path(childPath), childSnap);\n    });\n    return tree;\n  }\n\n  /**\n   * @template T\n   * @param {?T} value\n   * @param {SortedMap.<string, !ImmutableTree.<T>>=} children\n   */\n  constructor(\n    public readonly value: T | null,\n    public readonly children: SortedMap<\n      string,\n      ImmutableTree<T>\n    > = EmptyChildren()\n  ) {}\n\n  /**\n   * True if the value is empty and there are no children\n   * @return {boolean}\n   */\n  isEmpty(): boolean {\n    return this.value === null && this.children.isEmpty();\n  }\n\n  /**\n   * Given a path and predicate, return the first node and the path to that node\n   * where the predicate returns true.\n   *\n   * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects\n   * on the way back out, it may be better to pass down a pathSoFar obj.\n   *\n   * @param {!Path} relativePath The remainder of the path\n   * @param {function(T):boolean} predicate The predicate to satisfy to return a\n   *   node\n   * @return {?{path:!Path, value:!T}}\n   */\n  findRootMostMatchingPathAndValue(\n    relativePath: Path,\n    predicate: (a: T) => boolean\n  ): { path: Path; value: T } | null {\n    if (this.value != null && predicate(this.value)) {\n      return { path: Path.Empty, value: this.value };\n    } else {\n      if (relativePath.isEmpty()) {\n        return null;\n      } else {\n        const front = relativePath.getFront();\n        const child = this.children.get(front);\n        if (child !== null) {\n          const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(\n            relativePath.popFront(),\n            predicate\n          );\n          if (childExistingPathAndValue != null) {\n            const fullPath = new Path(front).child(\n              childExistingPathAndValue.path\n            );\n            return { path: fullPath, value: childExistingPathAndValue.value };\n          } else {\n            return null;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n\n  /**\n   * Find, if it exists, the shortest subpath of the given path that points a defined\n   * value in the tree\n   * @param {!Path} relativePath\n   * @return {?{path: !Path, value: !T}}\n   */\n  findRootMostValueAndPath(\n    relativePath: Path\n  ): { path: Path; value: T } | null {\n    return this.findRootMostMatchingPathAndValue(relativePath, () => true);\n  }\n\n  /**\n   * @param {!Path} relativePath\n   * @return {!ImmutableTree.<T>} The subtree at the given path\n   */\n  subtree(relativePath: Path): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return this;\n    } else {\n      const front = relativePath.getFront();\n      const childTree = this.children.get(front);\n      if (childTree !== null) {\n        return childTree.subtree(relativePath.popFront());\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  }\n\n  /**\n   * Sets a value at the specified path.\n   *\n   * @param {!Path} relativePath Path to set value at.\n   * @param {?T} toSet Value to set.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  set(relativePath: Path, toSet: T | null): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return new ImmutableTree(toSet, this.children);\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front) || ImmutableTree.Empty;\n      const newChild = child.set(relativePath.popFront(), toSet);\n      const newChildren = this.children.insert(front, newChild);\n      return new ImmutableTree(this.value, newChildren);\n    }\n  }\n\n  /**\n   * Removes the value at the specified path.\n   *\n   * @param {!Path} relativePath Path to value to remove.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  remove(relativePath: Path): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      if (this.children.isEmpty()) {\n        return ImmutableTree.Empty;\n      } else {\n        return new ImmutableTree(null, this.children);\n      }\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front);\n      if (child) {\n        const newChild = child.remove(relativePath.popFront());\n        let newChildren;\n        if (newChild.isEmpty()) {\n          newChildren = this.children.remove(front);\n        } else {\n          newChildren = this.children.insert(front, newChild);\n        }\n        if (this.value === null && newChildren.isEmpty()) {\n          return ImmutableTree.Empty;\n        } else {\n          return new ImmutableTree(this.value, newChildren);\n        }\n      } else {\n        return this;\n      }\n    }\n  }\n\n  /**\n   * Gets a value from the tree.\n   *\n   * @param {!Path} relativePath Path to get value for.\n   * @return {?T} Value at path, or null.\n   */\n  get(relativePath: Path): T | null {\n    if (relativePath.isEmpty()) {\n      return this.value;\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front);\n      if (child) {\n        return child.get(relativePath.popFront());\n      } else {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Replace the subtree at the specified path with the given new tree.\n   *\n   * @param {!Path} relativePath Path to replace subtree for.\n   * @param {!ImmutableTree} newTree New tree.\n   * @return {!ImmutableTree} Resulting tree.\n   */\n  setTree(relativePath: Path, newTree: ImmutableTree<T>): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return newTree;\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front) || ImmutableTree.Empty;\n      const newChild = child.setTree(relativePath.popFront(), newTree);\n      let newChildren;\n      if (newChild.isEmpty()) {\n        newChildren = this.children.remove(front);\n      } else {\n        newChildren = this.children.insert(front, newChild);\n      }\n      return new ImmutableTree(this.value, newChildren);\n    }\n  }\n\n  /**\n   * Performs a depth first fold on this tree. Transforms a tree into a single\n   * value, given a function that operates on the path to a node, an optional\n   * current value, and a map of child names to folded subtrees\n   * @template V\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   */\n  fold<V>(fn: (path: Path, value: T, children: { [k: string]: V }) => V): V {\n    return this.fold_(Path.Empty, fn);\n  }\n\n  /**\n   * Recursive helper for public-facing fold() method\n   * @template V\n   * @param {!Path} pathSoFar\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   * @private\n   */\n  private fold_<V>(\n    pathSoFar: Path,\n    fn: (path: Path, value: T | null, children: { [k: string]: V }) => V\n  ): V {\n    const accum: { [k: string]: V } = {};\n    this.children.inorderTraversal(function(\n      childKey: string,\n      childTree: ImmutableTree<T>\n    ) {\n      accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);\n    });\n    return fn(pathSoFar, this.value, accum);\n  }\n\n  /**\n   * Find the first matching value on the given path. Return the result of applying f to it.\n   * @template V\n   * @param {!Path} path\n   * @param {!function(!Path, !T):?V} f\n   * @return {?V}\n   */\n  findOnPath<V>(path: Path, f: (path: Path, value: T) => V | null): V | null {\n    return this.findOnPath_(path, Path.Empty, f);\n  }\n\n  private findOnPath_<V>(\n    pathToFollow: Path,\n    pathSoFar: Path,\n    f: (path: Path, value: T) => V | null\n  ): V | null {\n    const result = this.value ? f(pathSoFar, this.value) : false;\n    if (result) {\n      return result;\n    } else {\n      if (pathToFollow.isEmpty()) {\n        return null;\n      } else {\n        const front = pathToFollow.getFront()!;\n        const nextChild = this.children.get(front);\n        if (nextChild) {\n          return nextChild.findOnPath_(\n            pathToFollow.popFront(),\n            pathSoFar.child(front),\n            f\n          );\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {!Path} path\n   * @param {!function(!Path, !T)} f\n   * @returns {!ImmutableTree.<T>}\n   */\n  foreachOnPath(\n    path: Path,\n    f: (path: Path, value: T) => void\n  ): ImmutableTree<T> {\n    return this.foreachOnPath_(path, Path.Empty, f);\n  }\n\n  private foreachOnPath_(\n    pathToFollow: Path,\n    currentRelativePath: Path,\n    f: (path: Path, value: T) => void\n  ): ImmutableTree<T> {\n    if (pathToFollow.isEmpty()) {\n      return this;\n    } else {\n      if (this.value) {\n        f(currentRelativePath, this.value);\n      }\n      const front = pathToFollow.getFront();\n      const nextChild = this.children.get(front);\n      if (nextChild) {\n        return nextChild.foreachOnPath_(\n          pathToFollow.popFront(),\n          currentRelativePath.child(front),\n          f\n        );\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  }\n\n  /**\n   * Calls the given function for each node in the tree that has a value.\n   *\n   * @param {function(!Path, !T)} f A function to be called with\n   *   the path from the root of the tree to a node, and the value at that node.\n   *   Called in depth-first order.\n   */\n  foreach(f: (path: Path, value: T) => void) {\n    this.foreach_(Path.Empty, f);\n  }\n\n  private foreach_(\n    currentRelativePath: Path,\n    f: (path: Path, value: T) => void\n  ) {\n    this.children.inorderTraversal(function(childName, childTree) {\n      childTree.foreach_(currentRelativePath.child(childName), f);\n    });\n    if (this.value) {\n      f(currentRelativePath, this.value);\n    }\n  }\n\n  /**\n   *\n   * @param {function(string, !T)} f\n   */\n  foreachChild(f: (name: string, value: T) => void) {\n    this.children.inorderTraversal(\n      (childName: string, childTree: ImmutableTree<T>) => {\n        if (childTree.value) {\n          f(childName, childTree.value);\n        }\n      }\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}