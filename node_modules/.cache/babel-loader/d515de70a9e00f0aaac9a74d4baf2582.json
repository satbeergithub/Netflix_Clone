{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Operation_1 = require(\"../operation/Operation\");\nvar util_1 = require(\"@firebase/util\");\nvar ChildChangeAccumulator_1 = require(\"./ChildChangeAccumulator\");\nvar Change_1 = require(\"./Change\");\nvar ChildrenNode_1 = require(\"../snap/ChildrenNode\");\nvar KeyIndex_1 = require(\"../snap/indexes/KeyIndex\");\nvar ImmutableTree_1 = require(\"../util/ImmutableTree\");\nvar Path_1 = require(\"../util/Path\");\nvar CompleteChildSource_1 = require(\"./CompleteChildSource\");\n/**\n * @constructor\n * @struct\n */\nvar ProcessorResult = /** @class */function () {\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Array.<!Change>} changes\n   */\n  function ProcessorResult(viewCache, changes) {\n    this.viewCache = viewCache;\n    this.changes = changes;\n  }\n  return ProcessorResult;\n}();\nexports.ProcessorResult = ProcessorResult;\n/**\n * @constructor\n */\nvar ViewProcessor = /** @class */function () {\n  /**\n   * @param {!NodeFilter} filter_\n   */\n  function ViewProcessor(filter_) {\n    this.filter_ = filter_;\n  }\n  /**\n   * @param {!ViewCache} viewCache\n   */\n  ViewProcessor.prototype.assertIndexed = function (viewCache) {\n    util_1.assert(viewCache.getEventCache().getNode().isIndexed(this.filter_.getIndex()), 'Event snap not indexed');\n    util_1.assert(viewCache.getServerCache().getNode().isIndexed(this.filter_.getIndex()), 'Server snap not indexed');\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @return {!ProcessorResult}\n   */\n  ViewProcessor.prototype.applyOperation = function (oldViewCache, operation, writesCache, completeCache) {\n    var accumulator = new ChildChangeAccumulator_1.ChildChangeAccumulator();\n    var newViewCache, filterServerNode;\n    if (operation.type === Operation_1.OperationType.OVERWRITE) {\n      var overwrite = operation;\n      if (overwrite.source.fromUser) {\n        newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\n      } else {\n        util_1.assert(overwrite.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered  and the\n        // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n        // again\n        filterServerNode = overwrite.source.tagged || oldViewCache.getServerCache().isFiltered() && !overwrite.path.isEmpty();\n        newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\n      }\n    } else if (operation.type === Operation_1.OperationType.MERGE) {\n      var merge = operation;\n      if (merge.source.fromUser) {\n        newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\n      } else {\n        util_1.assert(merge.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered\n        filterServerNode = merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n        newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\n      }\n    } else if (operation.type === Operation_1.OperationType.ACK_USER_WRITE) {\n      var ackUserWrite = operation;\n      if (!ackUserWrite.revert) {\n        newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\n      } else {\n        newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\n      }\n    } else if (operation.type === Operation_1.OperationType.LISTEN_COMPLETE) {\n      newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);\n    } else {\n      throw util_1.assertionError('Unknown operation type: ' + operation.type);\n    }\n    var changes = accumulator.getChanges();\n    ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n    return new ProcessorResult(newViewCache, changes);\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!ViewCache} newViewCache\n   * @param {!Array.<!Change>} accumulator\n   * @private\n   */\n  ViewProcessor.maybeAddValueEvent_ = function (oldViewCache, newViewCache, accumulator) {\n    var eventSnap = newViewCache.getEventCache();\n    if (eventSnap.isFullyInitialized()) {\n      var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n      var oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n      if (accumulator.length > 0 || !oldViewCache.getEventCache().isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals( /** @type {!Node} */oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\n        accumulator.push(Change_1.Change.valueChange( /** @type {!Node} */newViewCache.getCompleteEventSnap()));\n      }\n    }\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} changePath\n   * @param {!WriteTreeRef} writesCache\n   * @param {!CompleteChildSource} source\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function (viewCache, changePath, writesCache, source, accumulator) {\n    var oldEventSnap = viewCache.getEventCache();\n    if (writesCache.shadowingWrite(changePath) != null) {\n      // we have a shadowing write, ignore changes\n      return viewCache;\n    } else {\n      var newEventCache = void 0,\n        serverNode = void 0;\n      if (changePath.isEmpty()) {\n        // TODO: figure out how this plays with \"sliding ack windows\"\n        util_1.assert(viewCache.getServerCache().isFullyInitialized(), 'If change path is empty, we must have complete server data');\n        if (viewCache.getServerCache().isFiltered()) {\n          // We need to special case this, because we need to only apply writes to complete children, or\n          // we might end up raising events for incomplete children. If the server data is filtered deep\n          // writes cannot be guaranteed to be complete\n          var serverCache = viewCache.getCompleteServerSnap();\n          var completeChildren = serverCache instanceof ChildrenNode_1.ChildrenNode ? serverCache : ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);\n          newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);\n        } else {\n          var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n          newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);\n        }\n      } else {\n        var childKey = changePath.getFront();\n        if (childKey == '.priority') {\n          util_1.assert(changePath.getLength() == 1, \"Can't have a priority with additional path components\");\n          var oldEventNode = oldEventSnap.getNode();\n          serverNode = viewCache.getServerCache().getNode();\n          // we might have overwrites for this priority\n          var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);\n          if (updatedPriority != null) {\n            newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);\n          } else {\n            // priority didn't change, keep old node\n            newEventCache = oldEventSnap.getNode();\n          }\n        } else {\n          var childChangePath = changePath.popFront();\n          // update child\n          var newEventChild = void 0;\n          if (oldEventSnap.isCompleteForChild(childKey)) {\n            serverNode = viewCache.getServerCache().getNode();\n            var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);\n            if (eventChildUpdate != null) {\n              newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);\n            } else {\n              // Nothing changed, just keep the old child\n              newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);\n            }\n          } else {\n            newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n          }\n          if (newEventChild != null) {\n            newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\n          } else {\n            // no complete child available or no change\n            newEventCache = oldEventSnap.getNode();\n          }\n        }\n      }\n      return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());\n    }\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  ViewProcessor.prototype.applyServerOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\n    var oldServerSnap = oldViewCache.getServerCache();\n    var newServerCache;\n    var serverFilter = filterServerNode ? this.filter_ : this.filter_.getIndexedFilter();\n    if (changePath.isEmpty()) {\n      newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n      // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n      var newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);\n      newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\n    } else {\n      var childKey = changePath.getFront();\n      if (!oldServerSnap.isCompleteForPath(changePath) && changePath.getLength() > 1) {\n        // We don't update incomplete nodes with updates intended for other listeners\n        return oldViewCache;\n      }\n      var childChangePath = changePath.popFront();\n      var childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n      var newChildNode = childNode.updateChild(childChangePath, changedSnap);\n      if (childKey == '.priority') {\n        newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\n      } else {\n        newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, null);\n      }\n    }\n    var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());\n    var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\n    return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  ViewProcessor.prototype.applyUserOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\n    var oldEventSnap = oldViewCache.getEventCache();\n    var newViewCache, newEventCache;\n    var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\n    if (changePath.isEmpty()) {\n      newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);\n      newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());\n    } else {\n      var childKey = changePath.getFront();\n      if (childKey === '.priority') {\n        newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);\n        newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\n      } else {\n        var childChangePath = changePath.popFront();\n        var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n        var newChild = void 0;\n        if (childChangePath.isEmpty()) {\n          // Child overwrite, we can replace the child\n          newChild = changedSnap;\n        } else {\n          var childNode = source.getCompleteChild(childKey);\n          if (childNode != null) {\n            if (childChangePath.getBack() === '.priority' && childNode.getChild(childChangePath.parent()).isEmpty()) {\n              // This is a priority update on an empty node. If this node exists on the server, the\n              // server will send down the priority in the update, so ignore for now\n              newChild = childNode;\n            } else {\n              newChild = childNode.updateChild(childChangePath, changedSnap);\n            }\n          } else {\n            // There is no complete child node available\n            newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          }\n        }\n        if (!oldChild.equals(newChild)) {\n          var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\n          newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());\n        } else {\n          newViewCache = oldViewCache;\n        }\n      }\n    }\n    return newViewCache;\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {string} childKey\n   * @return {boolean}\n   * @private\n   */\n  ViewProcessor.cacheHasChild_ = function (viewCache, childKey) {\n    return viewCache.getEventCache().isCompleteForChild(childKey);\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  ViewProcessor.prototype.applyUserMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\n    var _this = this;\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    var curViewCache = viewCache;\n    changedChildren.foreach(function (relativePath, childNode) {\n      var writePath = path.child(relativePath);\n      if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n      }\n    });\n    changedChildren.foreach(function (relativePath, childNode) {\n      var writePath = path.child(relativePath);\n      if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n      }\n    });\n    return curViewCache;\n  };\n  /**\n   * @param {!Node} node\n   * @param {ImmutableTree.<!Node>} merge\n   * @return {!Node}\n   * @private\n   */\n  ViewProcessor.prototype.applyMerge_ = function (node, merge) {\n    merge.foreach(function (relativePath, childNode) {\n      node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  ViewProcessor.prototype.applyServerMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\n    var _this = this;\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n    if (viewCache.getServerCache().getNode().isEmpty() && !viewCache.getServerCache().isFullyInitialized()) {\n      return viewCache;\n    }\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    var curViewCache = viewCache;\n    var viewMergeTree;\n    if (path.isEmpty()) {\n      viewMergeTree = changedChildren;\n    } else {\n      viewMergeTree = ImmutableTree_1.ImmutableTree.Empty.setTree(path, changedChildren);\n    }\n    var serverNode = viewCache.getServerCache().getNode();\n    viewMergeTree.children.inorderTraversal(function (childKey, childTree) {\n      if (serverNode.hasChild(childKey)) {\n        var serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);\n        var newChild = _this.applyMerge_(serverChild, childTree);\n        curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n      }\n    });\n    viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) {\n      var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey) && childMergeTree.value == null;\n      if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n        var serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);\n        var newChild = _this.applyMerge_(serverChild, childMergeTree);\n        curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n      }\n    });\n    return curViewCache;\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} ackPath\n   * @param {!ImmutableTree<!boolean>} affectedTree\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  ViewProcessor.prototype.ackUserWrite_ = function (viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\n    if (writesCache.shadowingWrite(ackPath) != null) {\n      return viewCache;\n    }\n    // Only filter server node if it is currently filtered\n    var filterServerNode = viewCache.getServerCache().isFiltered();\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n    var serverCache = viewCache.getServerCache();\n    if (affectedTree.value != null) {\n      // This is an overwrite.\n      if (ackPath.isEmpty() && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {\n        return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\n      } else if (ackPath.isEmpty()) {\n        // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n        // should just re-apply whatever we have in our cache as a merge.\n        var changedChildren_1 = ImmutableTree_1.ImmutableTree.Empty;\n        serverCache.getNode().forEachChild(KeyIndex_1.KEY_INDEX, function (name, node) {\n          changedChildren_1 = changedChildren_1.set(new Path_1.Path(name), node);\n        });\n        return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);\n      } else {\n        return viewCache;\n      }\n    } else {\n      // This is a merge.\n      var changedChildren_2 = ImmutableTree_1.ImmutableTree.Empty;\n      affectedTree.foreach(function (mergePath, value) {\n        var serverCachePath = ackPath.child(mergePath);\n        if (serverCache.isCompleteForPath(serverCachePath)) {\n          changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));\n        }\n      });\n      return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);\n    }\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  ViewProcessor.prototype.listenComplete_ = function (viewCache, path, writesCache, accumulator) {\n    var oldServerNode = viewCache.getServerCache();\n    var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());\n    return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, accumulator);\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeServerCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  ViewProcessor.prototype.revertUserWrite_ = function (viewCache, path, writesCache, completeServerCache, accumulator) {\n    var complete;\n    if (writesCache.shadowingWrite(path) != null) {\n      return viewCache;\n    } else {\n      var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\n      var oldEventCache = viewCache.getEventCache().getNode();\n      var newEventCache = void 0;\n      if (path.isEmpty() || path.getFront() === '.priority') {\n        var newNode = void 0;\n        if (viewCache.getServerCache().isFullyInitialized()) {\n          newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n        } else {\n          var serverChildren = viewCache.getServerCache().getNode();\n          util_1.assert(serverChildren instanceof ChildrenNode_1.ChildrenNode, 'serverChildren would be complete if leaf node');\n          newNode = writesCache.calcCompleteEventChildren(serverChildren);\n        }\n        newNode = newNode;\n        newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);\n      } else {\n        var childKey = path.getFront();\n        var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n        if (newChild == null && viewCache.getServerCache().isCompleteForChild(childKey)) {\n          newChild = oldEventCache.getImmediateChild(childKey);\n        }\n        if (newChild != null) {\n          newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator);\n        } else if (viewCache.getEventCache().getNode().hasChild(childKey)) {\n          // No complete child available, delete the existing one, if any\n          newEventCache = this.filter_.updateChild(oldEventCache, childKey, ChildrenNode_1.ChildrenNode.EMPTY_NODE, path.popFront(), source, accumulator);\n        } else {\n          newEventCache = oldEventCache;\n        }\n        if (newEventCache.isEmpty() && viewCache.getServerCache().isFullyInitialized()) {\n          // We might have reverted all child writes. Maybe the old event was a leaf node\n          complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n          if (complete.isLeafNode()) {\n            newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);\n          }\n        }\n      }\n      complete = viewCache.getServerCache().isFullyInitialized() || writesCache.shadowingWrite(Path_1.Path.Empty) != null;\n      return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());\n    }\n  };\n  return ViewProcessor;\n}();\nexports.ViewProcessor = ViewProcessor;","map":{"version":3,"mappings":"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","names":["viewCache","changes","exports","filter_","ViewProcessor","util_1","getEventCache","getNode","isIndexed","getIndex","getServerCache","oldViewCache","operation","writesCache","completeCache","accumulator","ChildChangeAccumulator_1","newViewCache","filterServerNode","type","Operation_1","OVERWRITE","overwrite","source","fromUser","applyUserOverwrite_","path","snap","fromServer","tagged","isFiltered","isEmpty","applyServerOverwrite_","MERGE","merge","applyUserMerge_","children","applyServerMerge_","ACK_USER_WRITE","ackUserWrite","revert","ackUserWrite_","affectedTree","revertUserWrite_","LISTEN_COMPLETE","listenComplete_","getChanges","maybeAddValueEvent_","ProcessorResult","eventSnap","isFullyInitialized","isLeafOrEmpty","isLeafNode","oldCompleteSnap","getCompleteEventSnap","length","equals","getPriority","push","Change_1","valueChange","changePath","oldEventSnap","shadowingWrite","newEventCache","serverNode","serverCache","getCompleteServerSnap","completeChildren","ChildrenNode_1","EMPTY_NODE","completeEventChildren","calcCompleteEventChildren","updateFullNode","completeNode","calcCompleteEventCache","childKey","getFront","getLength","oldEventNode","updatedPriority","calcEventCacheAfterServerOverwrite","updatePriority","childChangePath","popFront","newEventChild","isCompleteForChild","eventChildUpdate","getImmediateChild","updateChild","calcCompleteChild","updateEventSnap","filtersNodes","changedSnap","oldServerSnap","newServerCache","serverFilter","getIndexedFilter","newServerNode","isCompleteForPath","childNode","newChildNode","CompleteChildSource_1","updateServerSnap","generateEventCacheAfterServerEvent_","oldChild","newChild","getCompleteChild","getBack","getChild","parent","newEventSnap","changedChildren","curViewCache","foreach","relativePath","writePath","child","cacheHasChild_","_this","node","viewMergeTree","ImmutableTree_1","Empty","setTree","inorderTraversal","childTree","hasChild","serverChild","applyMerge_","Path_1","childMergeTree","isUnknownDeepMerge","value","ackPath","changedChildren_1","forEachChild","KeyIndex_1","name","set","changedChildren_2","mergePath","serverCachePath","oldServerNode","completeServerCache","complete","oldEventCache","newNode","serverChildren"],"sources":["../src/core/view/ViewProcessor.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Operation, OperationType } from '../operation/Operation';\nimport { assert, assertionError } from '@firebase/util';\nimport { ChildChangeAccumulator } from './ChildChangeAccumulator';\nimport { Change } from './Change';\nimport { ChildrenNode } from '../snap/ChildrenNode';\nimport { KEY_INDEX } from '../snap/indexes/KeyIndex';\nimport { ImmutableTree } from '../util/ImmutableTree';\nimport { Path } from '../util/Path';\nimport {\n  WriteTreeCompleteChildSource,\n  NO_COMPLETE_CHILD_SOURCE,\n  CompleteChildSource\n} from './CompleteChildSource';\nimport { ViewCache } from './ViewCache';\nimport { NodeFilter } from './filter/NodeFilter';\nimport { WriteTreeRef } from '../WriteTree';\nimport { Overwrite } from '../operation/Overwrite';\nimport { Merge } from '../operation/Merge';\nimport { AckUserWrite } from '../operation/AckUserWrite';\nimport { Node } from '../snap/Node';\n\n/**\n * @constructor\n * @struct\n */\nexport class ProcessorResult {\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Array.<!Change>} changes\n   */\n  constructor(\n    public readonly viewCache: ViewCache,\n    public readonly changes: Change[]\n  ) {}\n}\n\n/**\n * @constructor\n */\nexport class ViewProcessor {\n  /**\n   * @param {!NodeFilter} filter_\n   */\n  constructor(private readonly filter_: NodeFilter) {}\n\n  /**\n   * @param {!ViewCache} viewCache\n   */\n  assertIndexed(viewCache: ViewCache) {\n    assert(\n      viewCache\n        .getEventCache()\n        .getNode()\n        .isIndexed(this.filter_.getIndex()),\n      'Event snap not indexed'\n    );\n    assert(\n      viewCache\n        .getServerCache()\n        .getNode()\n        .isIndexed(this.filter_.getIndex()),\n      'Server snap not indexed'\n    );\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @return {!ProcessorResult}\n   */\n  applyOperation(\n    oldViewCache: ViewCache,\n    operation: Operation,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null\n  ): ProcessorResult {\n    const accumulator = new ChildChangeAccumulator();\n    let newViewCache, filterServerNode;\n    if (operation.type === OperationType.OVERWRITE) {\n      const overwrite = operation as Overwrite;\n      if (overwrite.source.fromUser) {\n        newViewCache = this.applyUserOverwrite_(\n          oldViewCache,\n          overwrite.path,\n          overwrite.snap,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        assert(overwrite.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered  and the\n        // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n        // again\n        filterServerNode =\n          overwrite.source.tagged ||\n          (oldViewCache.getServerCache().isFiltered() &&\n            !overwrite.path.isEmpty());\n        newViewCache = this.applyServerOverwrite_(\n          oldViewCache,\n          overwrite.path,\n          overwrite.snap,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.MERGE) {\n      const merge = operation as Merge;\n      if (merge.source.fromUser) {\n        newViewCache = this.applyUserMerge_(\n          oldViewCache,\n          merge.path,\n          merge.children,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        assert(merge.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered\n        filterServerNode =\n          merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n        newViewCache = this.applyServerMerge_(\n          oldViewCache,\n          merge.path,\n          merge.children,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.ACK_USER_WRITE) {\n      const ackUserWrite = operation as AckUserWrite;\n      if (!ackUserWrite.revert) {\n        newViewCache = this.ackUserWrite_(\n          oldViewCache,\n          ackUserWrite.path,\n          ackUserWrite.affectedTree,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        newViewCache = this.revertUserWrite_(\n          oldViewCache,\n          ackUserWrite.path,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.LISTEN_COMPLETE) {\n      newViewCache = this.listenComplete_(\n        oldViewCache,\n        operation.path,\n        writesCache,\n        accumulator\n      );\n    } else {\n      throw assertionError('Unknown operation type: ' + operation.type);\n    }\n    const changes = accumulator.getChanges();\n    ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n    return new ProcessorResult(newViewCache, changes);\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!ViewCache} newViewCache\n   * @param {!Array.<!Change>} accumulator\n   * @private\n   */\n  private static maybeAddValueEvent_(\n    oldViewCache: ViewCache,\n    newViewCache: ViewCache,\n    accumulator: Change[]\n  ) {\n    const eventSnap = newViewCache.getEventCache();\n    if (eventSnap.isFullyInitialized()) {\n      const isLeafOrEmpty =\n        eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n      const oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n      if (\n        accumulator.length > 0 ||\n        !oldViewCache.getEventCache().isFullyInitialized() ||\n        (isLeafOrEmpty &&\n          !eventSnap\n            .getNode()\n            .equals(/** @type {!Node} */ (oldCompleteSnap))) ||\n        !eventSnap\n          .getNode()\n          .getPriority()\n          .equals(oldCompleteSnap.getPriority())\n      ) {\n        accumulator.push(\n          Change.valueChange(\n            /** @type {!Node} */ newViewCache.getCompleteEventSnap()\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} changePath\n   * @param {!WriteTreeRef} writesCache\n   * @param {!CompleteChildSource} source\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private generateEventCacheAfterServerEvent_(\n    viewCache: ViewCache,\n    changePath: Path,\n    writesCache: WriteTreeRef,\n    source: CompleteChildSource,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldEventSnap = viewCache.getEventCache();\n    if (writesCache.shadowingWrite(changePath) != null) {\n      // we have a shadowing write, ignore changes\n      return viewCache;\n    } else {\n      let newEventCache, serverNode;\n      if (changePath.isEmpty()) {\n        // TODO: figure out how this plays with \"sliding ack windows\"\n        assert(\n          viewCache.getServerCache().isFullyInitialized(),\n          'If change path is empty, we must have complete server data'\n        );\n        if (viewCache.getServerCache().isFiltered()) {\n          // We need to special case this, because we need to only apply writes to complete children, or\n          // we might end up raising events for incomplete children. If the server data is filtered deep\n          // writes cannot be guaranteed to be complete\n          const serverCache = viewCache.getCompleteServerSnap();\n          const completeChildren =\n            serverCache instanceof ChildrenNode\n              ? serverCache\n              : ChildrenNode.EMPTY_NODE;\n          const completeEventChildren = writesCache.calcCompleteEventChildren(\n            completeChildren\n          );\n          newEventCache = this.filter_.updateFullNode(\n            viewCache.getEventCache().getNode(),\n            completeEventChildren,\n            accumulator\n          );\n        } else {\n          const completeNode = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n          newEventCache = this.filter_.updateFullNode(\n            viewCache.getEventCache().getNode(),\n            completeNode,\n            accumulator\n          );\n        }\n      } else {\n        const childKey = changePath.getFront();\n        if (childKey == '.priority') {\n          assert(\n            changePath.getLength() == 1,\n            \"Can't have a priority with additional path components\"\n          );\n          const oldEventNode = oldEventSnap.getNode();\n          serverNode = viewCache.getServerCache().getNode();\n          // we might have overwrites for this priority\n          const updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(\n            changePath,\n            oldEventNode,\n            serverNode\n          );\n          if (updatedPriority != null) {\n            newEventCache = this.filter_.updatePriority(\n              oldEventNode,\n              updatedPriority\n            );\n          } else {\n            // priority didn't change, keep old node\n            newEventCache = oldEventSnap.getNode();\n          }\n        } else {\n          const childChangePath = changePath.popFront();\n          // update child\n          let newEventChild;\n          if (oldEventSnap.isCompleteForChild(childKey)) {\n            serverNode = viewCache.getServerCache().getNode();\n            const eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(\n              changePath,\n              oldEventSnap.getNode(),\n              serverNode\n            );\n            if (eventChildUpdate != null) {\n              newEventChild = oldEventSnap\n                .getNode()\n                .getImmediateChild(childKey)\n                .updateChild(childChangePath, eventChildUpdate);\n            } else {\n              // Nothing changed, just keep the old child\n              newEventChild = oldEventSnap\n                .getNode()\n                .getImmediateChild(childKey);\n            }\n          } else {\n            newEventChild = writesCache.calcCompleteChild(\n              childKey,\n              viewCache.getServerCache()\n            );\n          }\n          if (newEventChild != null) {\n            newEventCache = this.filter_.updateChild(\n              oldEventSnap.getNode(),\n              childKey,\n              newEventChild,\n              childChangePath,\n              source,\n              accumulator\n            );\n          } else {\n            // no complete child available or no change\n            newEventCache = oldEventSnap.getNode();\n          }\n        }\n      }\n      return viewCache.updateEventSnap(\n        newEventCache,\n        oldEventSnap.isFullyInitialized() || changePath.isEmpty(),\n        this.filter_.filtersNodes()\n      );\n    }\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyServerOverwrite_(\n    oldViewCache: ViewCache,\n    changePath: Path,\n    changedSnap: Node,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    filterServerNode: boolean,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldServerSnap = oldViewCache.getServerCache();\n    let newServerCache;\n    const serverFilter = filterServerNode\n      ? this.filter_\n      : this.filter_.getIndexedFilter();\n    if (changePath.isEmpty()) {\n      newServerCache = serverFilter.updateFullNode(\n        oldServerSnap.getNode(),\n        changedSnap,\n        null\n      );\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n      // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n      const newServerNode = oldServerSnap\n        .getNode()\n        .updateChild(changePath, changedSnap);\n      newServerCache = serverFilter.updateFullNode(\n        oldServerSnap.getNode(),\n        newServerNode,\n        null\n      );\n    } else {\n      const childKey = changePath.getFront();\n      if (\n        !oldServerSnap.isCompleteForPath(changePath) &&\n        changePath.getLength() > 1\n      ) {\n        // We don't update incomplete nodes with updates intended for other listeners\n        return oldViewCache;\n      }\n      const childChangePath = changePath.popFront();\n      const childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n      const newChildNode = childNode.updateChild(childChangePath, changedSnap);\n      if (childKey == '.priority') {\n        newServerCache = serverFilter.updatePriority(\n          oldServerSnap.getNode(),\n          newChildNode\n        );\n      } else {\n        newServerCache = serverFilter.updateChild(\n          oldServerSnap.getNode(),\n          childKey,\n          newChildNode,\n          childChangePath,\n          NO_COMPLETE_CHILD_SOURCE,\n          null\n        );\n      }\n    }\n    const newViewCache = oldViewCache.updateServerSnap(\n      newServerCache,\n      oldServerSnap.isFullyInitialized() || changePath.isEmpty(),\n      serverFilter.filtersNodes()\n    );\n    const source = new WriteTreeCompleteChildSource(\n      writesCache,\n      newViewCache,\n      completeCache\n    );\n    return this.generateEventCacheAfterServerEvent_(\n      newViewCache,\n      changePath,\n      writesCache,\n      source,\n      accumulator\n    );\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyUserOverwrite_(\n    oldViewCache: ViewCache,\n    changePath: Path,\n    changedSnap: Node,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldEventSnap = oldViewCache.getEventCache();\n    let newViewCache, newEventCache;\n    const source = new WriteTreeCompleteChildSource(\n      writesCache,\n      oldViewCache,\n      completeCache\n    );\n    if (changePath.isEmpty()) {\n      newEventCache = this.filter_.updateFullNode(\n        oldViewCache.getEventCache().getNode(),\n        changedSnap,\n        accumulator\n      );\n      newViewCache = oldViewCache.updateEventSnap(\n        newEventCache,\n        true,\n        this.filter_.filtersNodes()\n      );\n    } else {\n      const childKey = changePath.getFront();\n      if (childKey === '.priority') {\n        newEventCache = this.filter_.updatePriority(\n          oldViewCache.getEventCache().getNode(),\n          changedSnap\n        );\n        newViewCache = oldViewCache.updateEventSnap(\n          newEventCache,\n          oldEventSnap.isFullyInitialized(),\n          oldEventSnap.isFiltered()\n        );\n      } else {\n        const childChangePath = changePath.popFront();\n        const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n        let newChild;\n        if (childChangePath.isEmpty()) {\n          // Child overwrite, we can replace the child\n          newChild = changedSnap;\n        } else {\n          const childNode = source.getCompleteChild(childKey);\n          if (childNode != null) {\n            if (\n              childChangePath.getBack() === '.priority' &&\n              childNode.getChild(childChangePath.parent()).isEmpty()\n            ) {\n              // This is a priority update on an empty node. If this node exists on the server, the\n              // server will send down the priority in the update, so ignore for now\n              newChild = childNode;\n            } else {\n              newChild = childNode.updateChild(childChangePath, changedSnap);\n            }\n          } else {\n            // There is no complete child node available\n            newChild = ChildrenNode.EMPTY_NODE;\n          }\n        }\n        if (!oldChild.equals(newChild)) {\n          const newEventSnap = this.filter_.updateChild(\n            oldEventSnap.getNode(),\n            childKey,\n            newChild,\n            childChangePath,\n            source,\n            accumulator\n          );\n          newViewCache = oldViewCache.updateEventSnap(\n            newEventSnap,\n            oldEventSnap.isFullyInitialized(),\n            this.filter_.filtersNodes()\n          );\n        } else {\n          newViewCache = oldViewCache;\n        }\n      }\n    }\n    return newViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {string} childKey\n   * @return {boolean}\n   * @private\n   */\n  private static cacheHasChild_(\n    viewCache: ViewCache,\n    childKey: string\n  ): boolean {\n    return viewCache.getEventCache().isCompleteForChild(childKey);\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyUserMerge_(\n    viewCache: ViewCache,\n    path: Path,\n    changedChildren: ImmutableTree<Node>,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(\n          curViewCache,\n          writePath,\n          childNode,\n          writesCache,\n          serverCache,\n          accumulator\n        );\n      }\n    });\n\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(\n          curViewCache,\n          writePath,\n          childNode,\n          writesCache,\n          serverCache,\n          accumulator\n        );\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!Node} node\n   * @param {ImmutableTree.<!Node>} merge\n   * @return {!Node}\n   * @private\n   */\n  private applyMerge_(node: Node, merge: ImmutableTree<Node>): Node {\n    merge.foreach(function(relativePath, childNode) {\n      node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyServerMerge_(\n    viewCache: ViewCache,\n    path: Path,\n    changedChildren: ImmutableTree<Node>,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    filterServerNode: boolean,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n    if (\n      viewCache\n        .getServerCache()\n        .getNode()\n        .isEmpty() &&\n      !viewCache.getServerCache().isFullyInitialized()\n    ) {\n      return viewCache;\n    }\n\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    let viewMergeTree;\n    if (path.isEmpty()) {\n      viewMergeTree = changedChildren;\n    } else {\n      viewMergeTree = ImmutableTree.Empty.setTree(path, changedChildren);\n    }\n    const serverNode = viewCache.getServerCache().getNode();\n    viewMergeTree.children.inorderTraversal((childKey, childTree) => {\n      if (serverNode.hasChild(childKey)) {\n        const serverChild = viewCache\n          .getServerCache()\n          .getNode()\n          .getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childTree);\n        curViewCache = this.applyServerOverwrite_(\n          curViewCache,\n          new Path(childKey),\n          newChild,\n          writesCache,\n          serverCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    });\n    viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {\n      const isUnknownDeepMerge =\n        !viewCache.getServerCache().isCompleteForChild(childKey) &&\n        childMergeTree.value == null;\n      if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n        const serverChild = viewCache\n          .getServerCache()\n          .getNode()\n          .getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childMergeTree);\n        curViewCache = this.applyServerOverwrite_(\n          curViewCache,\n          new Path(childKey),\n          newChild,\n          writesCache,\n          serverCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} ackPath\n   * @param {!ImmutableTree<!boolean>} affectedTree\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private ackUserWrite_(\n    viewCache: ViewCache,\n    ackPath: Path,\n    affectedTree: ImmutableTree<boolean>,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    if (writesCache.shadowingWrite(ackPath) != null) {\n      return viewCache;\n    }\n\n    // Only filter server node if it is currently filtered\n    const filterServerNode = viewCache.getServerCache().isFiltered();\n\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n    const serverCache = viewCache.getServerCache();\n    if (affectedTree.value != null) {\n      // This is an overwrite.\n      if (\n        (ackPath.isEmpty() && serverCache.isFullyInitialized()) ||\n        serverCache.isCompleteForPath(ackPath)\n      ) {\n        return this.applyServerOverwrite_(\n          viewCache,\n          ackPath,\n          serverCache.getNode().getChild(ackPath),\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      } else if (ackPath.isEmpty()) {\n        // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n        // should just re-apply whatever we have in our cache as a merge.\n        let changedChildren = ImmutableTree.Empty;\n        serverCache.getNode().forEachChild(KEY_INDEX, function(name, node) {\n          changedChildren = changedChildren.set(new Path(name), node);\n        });\n        return this.applyServerMerge_(\n          viewCache,\n          ackPath,\n          changedChildren,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      } else {\n        return viewCache;\n      }\n    } else {\n      // This is a merge.\n      let changedChildren = ImmutableTree.Empty;\n      affectedTree.foreach(function(mergePath, value) {\n        const serverCachePath = ackPath.child(mergePath);\n        if (serverCache.isCompleteForPath(serverCachePath)) {\n          changedChildren = changedChildren.set(\n            mergePath,\n            serverCache.getNode().getChild(serverCachePath)\n          );\n        }\n      });\n      return this.applyServerMerge_(\n        viewCache,\n        ackPath,\n        changedChildren,\n        writesCache,\n        completeCache,\n        filterServerNode,\n        accumulator\n      );\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private listenComplete_(\n    viewCache: ViewCache,\n    path: Path,\n    writesCache: WriteTreeRef,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldServerNode = viewCache.getServerCache();\n    const newViewCache = viewCache.updateServerSnap(\n      oldServerNode.getNode(),\n      oldServerNode.isFullyInitialized() || path.isEmpty(),\n      oldServerNode.isFiltered()\n    );\n    return this.generateEventCacheAfterServerEvent_(\n      newViewCache,\n      path,\n      writesCache,\n      NO_COMPLETE_CHILD_SOURCE,\n      accumulator\n    );\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeServerCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private revertUserWrite_(\n    viewCache: ViewCache,\n    path: Path,\n    writesCache: WriteTreeRef,\n    completeServerCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    let complete;\n    if (writesCache.shadowingWrite(path) != null) {\n      return viewCache;\n    } else {\n      const source = new WriteTreeCompleteChildSource(\n        writesCache,\n        viewCache,\n        completeServerCache\n      );\n      const oldEventCache = viewCache.getEventCache().getNode();\n      let newEventCache;\n      if (path.isEmpty() || path.getFront() === '.priority') {\n        let newNode;\n        if (viewCache.getServerCache().isFullyInitialized()) {\n          newNode = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n        } else {\n          const serverChildren = viewCache.getServerCache().getNode();\n          assert(\n            serverChildren instanceof ChildrenNode,\n            'serverChildren would be complete if leaf node'\n          );\n          newNode = writesCache.calcCompleteEventChildren(\n            serverChildren as ChildrenNode\n          );\n        }\n        newNode = newNode as Node;\n        newEventCache = this.filter_.updateFullNode(\n          oldEventCache,\n          newNode,\n          accumulator\n        );\n      } else {\n        const childKey = path.getFront();\n        let newChild = writesCache.calcCompleteChild(\n          childKey,\n          viewCache.getServerCache()\n        );\n        if (\n          newChild == null &&\n          viewCache.getServerCache().isCompleteForChild(childKey)\n        ) {\n          newChild = oldEventCache.getImmediateChild(childKey);\n        }\n        if (newChild != null) {\n          newEventCache = this.filter_.updateChild(\n            oldEventCache,\n            childKey,\n            newChild,\n            path.popFront(),\n            source,\n            accumulator\n          );\n        } else if (\n          viewCache\n            .getEventCache()\n            .getNode()\n            .hasChild(childKey)\n        ) {\n          // No complete child available, delete the existing one, if any\n          newEventCache = this.filter_.updateChild(\n            oldEventCache,\n            childKey,\n            ChildrenNode.EMPTY_NODE,\n            path.popFront(),\n            source,\n            accumulator\n          );\n        } else {\n          newEventCache = oldEventCache;\n        }\n        if (\n          newEventCache.isEmpty() &&\n          viewCache.getServerCache().isFullyInitialized()\n        ) {\n          // We might have reverted all child writes. Maybe the old event was a leaf node\n          complete = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n          if (complete.isLeafNode()) {\n            newEventCache = this.filter_.updateFullNode(\n              newEventCache,\n              complete,\n              accumulator\n            );\n          }\n        }\n      }\n      complete =\n        viewCache.getServerCache().isFullyInitialized() ||\n        writesCache.shadowingWrite(Path.Empty) != null;\n      return viewCache.updateEventSnap(\n        newEventCache,\n        complete,\n        this.filter_.filtersNodes()\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}