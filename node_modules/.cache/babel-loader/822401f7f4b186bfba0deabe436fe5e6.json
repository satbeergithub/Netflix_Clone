{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"@firebase/util\");\n/**\n * An immutable object representing a parsed path.  It's immutable so that you\n * can pass them around to other functions without worrying about them changing\n * it.\n */\nvar Path = /** @class */function () {\n  /**\n   * @param {string|Array.<string>} pathOrString Path string to parse,\n   *      or another path, or the raw tokens array\n   * @param {number=} pieceNum\n   */\n  function Path(pathOrString, pieceNum) {\n    if (pieceNum === void 0) {\n      this.pieces_ = pathOrString.split('/');\n      // Remove empty pieces.\n      var copyTo = 0;\n      for (var i = 0; i < this.pieces_.length; i++) {\n        if (this.pieces_[i].length > 0) {\n          this.pieces_[copyTo] = this.pieces_[i];\n          copyTo++;\n        }\n      }\n      this.pieces_.length = copyTo;\n      this.pieceNum_ = 0;\n    } else {\n      this.pieces_ = pathOrString;\n      this.pieceNum_ = pieceNum;\n    }\n  }\n  Object.defineProperty(Path, \"Empty\", {\n    /**\n     * Singleton to represent an empty path\n     *\n     * @const\n     */\n    get: function get() {\n      return new Path('');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Path.prototype.getFront = function () {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n    return this.pieces_[this.pieceNum_];\n  };\n  /**\n   * @return {number} The number of segments in this path\n   */\n  Path.prototype.getLength = function () {\n    return this.pieces_.length - this.pieceNum_;\n  };\n  /**\n   * @return {!Path}\n   */\n  Path.prototype.popFront = function () {\n    var pieceNum = this.pieceNum_;\n    if (pieceNum < this.pieces_.length) {\n      pieceNum++;\n    }\n    return new Path(this.pieces_, pieceNum);\n  };\n  /**\n   * @return {?string}\n   */\n  Path.prototype.getBack = function () {\n    if (this.pieceNum_ < this.pieces_.length) return this.pieces_[this.pieces_.length - 1];\n    return null;\n  };\n  Path.prototype.toString = function () {\n    var pathString = '';\n    for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '') pathString += '/' + this.pieces_[i];\n    }\n    return pathString || '/';\n  };\n  Path.prototype.toUrlEncodedString = function () {\n    var pathString = '';\n    for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '') pathString += '/' + encodeURIComponent(String(this.pieces_[i]));\n    }\n    return pathString || '/';\n  };\n  /**\n   * Shallow copy of the parts of the path.\n   *\n   * @param {number=} begin\n   * @return {!Array<string>}\n   */\n  Path.prototype.slice = function (begin) {\n    if (begin === void 0) {\n      begin = 0;\n    }\n    return this.pieces_.slice(this.pieceNum_ + begin);\n  };\n  /**\n   * @return {?Path}\n   */\n  Path.prototype.parent = function () {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n    var pieces = [];\n    for (var i = this.pieceNum_; i < this.pieces_.length - 1; i++) {\n      pieces.push(this.pieces_[i]);\n    }\n    return new Path(pieces, 0);\n  };\n  /**\n   * @param {string|!Path} childPathObj\n   * @return {!Path}\n   */\n  Path.prototype.child = function (childPathObj) {\n    var pieces = [];\n    for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\n      pieces.push(this.pieces_[i]);\n    }\n    if (childPathObj instanceof Path) {\n      for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {\n        pieces.push(childPathObj.pieces_[i]);\n      }\n    } else {\n      var childPieces = childPathObj.split('/');\n      for (var i = 0; i < childPieces.length; i++) {\n        if (childPieces[i].length > 0) pieces.push(childPieces[i]);\n      }\n    }\n    return new Path(pieces, 0);\n  };\n  /**\n   * @return {boolean} True if there are no segments in this path\n   */\n  Path.prototype.isEmpty = function () {\n    return this.pieceNum_ >= this.pieces_.length;\n  };\n  /**\n   * @param {!Path} outerPath\n   * @param {!Path} innerPath\n   * @return {!Path} The path from outerPath to innerPath\n   */\n  Path.relativePath = function (outerPath, innerPath) {\n    var outer = outerPath.getFront(),\n      inner = innerPath.getFront();\n    if (outer === null) {\n      return innerPath;\n    } else if (outer === inner) {\n      return Path.relativePath(outerPath.popFront(), innerPath.popFront());\n    } else {\n      throw new Error('INTERNAL ERROR: innerPath (' + innerPath + ') is not within ' + 'outerPath (' + outerPath + ')');\n    }\n  };\n  /**\n   * @param {!Path} left\n   * @param {!Path} right\n   * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.\n   */\n  Path.comparePaths = function (left, right) {\n    var leftKeys = left.slice();\n    var rightKeys = right.slice();\n    for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n      var cmp = util_1.nameCompare(leftKeys[i], rightKeys[i]);\n      if (cmp !== 0) return cmp;\n    }\n    if (leftKeys.length === rightKeys.length) return 0;\n    return leftKeys.length < rightKeys.length ? -1 : 1;\n  };\n  /**\n   *\n   * @param {Path} other\n   * @return {boolean} true if paths are the same.\n   */\n  Path.prototype.equals = function (other) {\n    if (this.getLength() !== other.getLength()) {\n      return false;\n    }\n    for (var i = this.pieceNum_, j = other.pieceNum_; i <= this.pieces_.length; i++, j++) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   *\n   * @param {!Path} other\n   * @return {boolean} True if this path is a parent (or the same as) other\n   */\n  Path.prototype.contains = function (other) {\n    var i = this.pieceNum_;\n    var j = other.pieceNum_;\n    if (this.getLength() > other.getLength()) {\n      return false;\n    }\n    while (i < this.pieces_.length) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n      ++i;\n      ++j;\n    }\n    return true;\n  };\n  return Path;\n}(); // end Path\nexports.Path = Path;\n/**\n * Dynamic (mutable) path used to count path lengths.\n *\n * This class is used to efficiently check paths for valid\n * length (in UTF8 bytes) and depth (used in path validation).\n *\n * Throws Error exception if path is ever invalid.\n *\n * The definition of a path always begins with '/'.\n */\nvar ValidationPath = /** @class */function () {\n  /**\n   * @param {!Path} path Initial Path.\n   * @param {string} errorPrefix_ Prefix for any error messages.\n   */\n  function ValidationPath(path, errorPrefix_) {\n    this.errorPrefix_ = errorPrefix_;\n    /** @type {!Array<string>} */\n    this.parts_ = path.slice();\n    /** @type {number} Initialize to number of '/' chars needed in path. */\n    this.byteLength_ = Math.max(1, this.parts_.length);\n    for (var i = 0; i < this.parts_.length; i++) {\n      this.byteLength_ += util_2.stringLength(this.parts_[i]);\n    }\n    this.checkValid_();\n  }\n  Object.defineProperty(ValidationPath, \"MAX_PATH_DEPTH\", {\n    /** @const {number} Maximum key depth. */\n    get: function get() {\n      return 32;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValidationPath, \"MAX_PATH_LENGTH_BYTES\", {\n    /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */\n    get: function get() {\n      return 768;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @param {string} child */\n  ValidationPath.prototype.push = function (child) {\n    // Count the needed '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ += 1;\n    }\n    this.parts_.push(child);\n    this.byteLength_ += util_2.stringLength(child);\n    this.checkValid_();\n  };\n  ValidationPath.prototype.pop = function () {\n    var last = this.parts_.pop();\n    this.byteLength_ -= util_2.stringLength(last);\n    // Un-count the previous '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ -= 1;\n    }\n  };\n  ValidationPath.prototype.checkValid_ = function () {\n    if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {\n      throw new Error(this.errorPrefix_ + 'has a key path longer than ' + ValidationPath.MAX_PATH_LENGTH_BYTES + ' bytes (' + this.byteLength_ + ').');\n    }\n    if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {\n      throw new Error(this.errorPrefix_ + 'path specified exceeds the maximum depth that can be written (' + ValidationPath.MAX_PATH_DEPTH + ') or object contains a cycle ' + this.toErrorString());\n    }\n  };\n  /**\n   * String for use in error messages - uses '.' notation for path.\n   *\n   * @return {string}\n   */\n  ValidationPath.prototype.toErrorString = function () {\n    if (this.parts_.length == 0) {\n      return '';\n    }\n    return \"in property '\" + this.parts_.join('.') + \"'\";\n  };\n  return ValidationPath;\n}();\nexports.ValidationPath = ValidationPath;","map":{"version":3,"mappings":"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","names":["pathOrString","pieceNum","pieces_","split","copyTo","i","length","pieceNum_","Object","Path","pathString","encodeURIComponent","String","begin","slice","pieces","push","childPathObj","childPieces","outerPath","innerPath","outer","getFront","inner","relativePath","popFront","Error","left","right","leftKeys","rightKeys","cmp","util_1","other","getLength","j","exports","path","errorPrefix_","parts_","byteLength_","Math","max","util_2","checkValid_","ValidationPath","child","last","pop","MAX_PATH_LENGTH_BYTES","MAX_PATH_DEPTH","toErrorString","join"],"sources":["../src/core/util/Path.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { nameCompare } from './util';\nimport { stringLength } from '@firebase/util';\n/**\n * An immutable object representing a parsed path.  It's immutable so that you\n * can pass them around to other functions without worrying about them changing\n * it.\n */\n\nexport class Path {\n  private pieces_: string[];\n  private pieceNum_: number;\n\n  /**\n   * Singleton to represent an empty path\n   *\n   * @const\n   */\n  static get Empty() {\n    return new Path('');\n  }\n\n  /**\n   * @param {string|Array.<string>} pathOrString Path string to parse,\n   *      or another path, or the raw tokens array\n   * @param {number=} pieceNum\n   */\n  constructor(pathOrString: string | string[], pieceNum?: number) {\n    if (pieceNum === void 0) {\n      this.pieces_ = (pathOrString as string).split('/');\n\n      // Remove empty pieces.\n      let copyTo = 0;\n      for (let i = 0; i < this.pieces_.length; i++) {\n        if (this.pieces_[i].length > 0) {\n          this.pieces_[copyTo] = this.pieces_[i];\n          copyTo++;\n        }\n      }\n      this.pieces_.length = copyTo;\n\n      this.pieceNum_ = 0;\n    } else {\n      this.pieces_ = pathOrString as string[];\n      this.pieceNum_ = pieceNum;\n    }\n  }\n\n  getFront(): string | null {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n\n    return this.pieces_[this.pieceNum_];\n  }\n\n  /**\n   * @return {number} The number of segments in this path\n   */\n  getLength(): number {\n    return this.pieces_.length - this.pieceNum_;\n  }\n\n  /**\n   * @return {!Path}\n   */\n  popFront(): Path {\n    let pieceNum = this.pieceNum_;\n    if (pieceNum < this.pieces_.length) {\n      pieceNum++;\n    }\n    return new Path(this.pieces_, pieceNum);\n  }\n\n  /**\n   * @return {?string}\n   */\n  getBack(): string | null {\n    if (this.pieceNum_ < this.pieces_.length)\n      return this.pieces_[this.pieces_.length - 1];\n\n    return null;\n  }\n\n  toString(): string {\n    let pathString = '';\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '') pathString += '/' + this.pieces_[i];\n    }\n\n    return pathString || '/';\n  }\n\n  toUrlEncodedString(): string {\n    let pathString = '';\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '')\n        pathString += '/' + encodeURIComponent(String(this.pieces_[i]));\n    }\n\n    return pathString || '/';\n  }\n\n  /**\n   * Shallow copy of the parts of the path.\n   *\n   * @param {number=} begin\n   * @return {!Array<string>}\n   */\n  slice(begin: number = 0): string[] {\n    return this.pieces_.slice(this.pieceNum_ + begin);\n  }\n\n  /**\n   * @return {?Path}\n   */\n  parent(): Path | null {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n\n    const pieces = [];\n    for (let i = this.pieceNum_; i < this.pieces_.length - 1; i++)\n      pieces.push(this.pieces_[i]);\n\n    return new Path(pieces, 0);\n  }\n\n  /**\n   * @param {string|!Path} childPathObj\n   * @return {!Path}\n   */\n  child(childPathObj: string | Path): Path {\n    const pieces = [];\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++)\n      pieces.push(this.pieces_[i]);\n\n    if (childPathObj instanceof Path) {\n      for (\n        let i = childPathObj.pieceNum_;\n        i < childPathObj.pieces_.length;\n        i++\n      ) {\n        pieces.push(childPathObj.pieces_[i]);\n      }\n    } else {\n      const childPieces = childPathObj.split('/');\n      for (let i = 0; i < childPieces.length; i++) {\n        if (childPieces[i].length > 0) pieces.push(childPieces[i]);\n      }\n    }\n\n    return new Path(pieces, 0);\n  }\n\n  /**\n   * @return {boolean} True if there are no segments in this path\n   */\n  isEmpty(): boolean {\n    return this.pieceNum_ >= this.pieces_.length;\n  }\n\n  /**\n   * @param {!Path} outerPath\n   * @param {!Path} innerPath\n   * @return {!Path} The path from outerPath to innerPath\n   */\n  static relativePath(outerPath: Path, innerPath: Path): Path {\n    const outer = outerPath.getFront(),\n      inner = innerPath.getFront();\n    if (outer === null) {\n      return innerPath;\n    } else if (outer === inner) {\n      return Path.relativePath(outerPath.popFront(), innerPath.popFront());\n    } else {\n      throw new Error(\n        'INTERNAL ERROR: innerPath (' +\n          innerPath +\n          ') is not within ' +\n          'outerPath (' +\n          outerPath +\n          ')'\n      );\n    }\n  }\n\n  /**\n   * @param {!Path} left\n   * @param {!Path} right\n   * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.\n   */\n  static comparePaths(left: Path, right: Path): number {\n    const leftKeys = left.slice();\n    const rightKeys = right.slice();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n      const cmp = nameCompare(leftKeys[i], rightKeys[i]);\n      if (cmp !== 0) return cmp;\n    }\n    if (leftKeys.length === rightKeys.length) return 0;\n    return leftKeys.length < rightKeys.length ? -1 : 1;\n  }\n\n  /**\n   *\n   * @param {Path} other\n   * @return {boolean} true if paths are the same.\n   */\n  equals(other: Path): boolean {\n    if (this.getLength() !== other.getLength()) {\n      return false;\n    }\n\n    for (\n      let i = this.pieceNum_, j = other.pieceNum_;\n      i <= this.pieces_.length;\n      i++, j++\n    ) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {!Path} other\n   * @return {boolean} True if this path is a parent (or the same as) other\n   */\n  contains(other: Path): boolean {\n    let i = this.pieceNum_;\n    let j = other.pieceNum_;\n    if (this.getLength() > other.getLength()) {\n      return false;\n    }\n    while (i < this.pieces_.length) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n      ++i;\n      ++j;\n    }\n    return true;\n  }\n} // end Path\n\n/**\n * Dynamic (mutable) path used to count path lengths.\n *\n * This class is used to efficiently check paths for valid\n * length (in UTF8 bytes) and depth (used in path validation).\n *\n * Throws Error exception if path is ever invalid.\n *\n * The definition of a path always begins with '/'.\n */\nexport class ValidationPath {\n  /** @type {!Array<string>} */\n  private parts_: string[];\n  /** @type {number} Initialize to number of '/' chars needed in path. */\n  private byteLength_: number;\n\n  /**\n   * @param {!Path} path Initial Path.\n   * @param {string} errorPrefix_ Prefix for any error messages.\n   */\n  constructor(path: Path, private errorPrefix_: string) {\n    /** @type {!Array<string>} */\n    this.parts_ = path.slice();\n    /** @type {number} Initialize to number of '/' chars needed in path. */\n    this.byteLength_ = Math.max(1, this.parts_.length);\n\n    for (let i = 0; i < this.parts_.length; i++) {\n      this.byteLength_ += stringLength(this.parts_[i]);\n    }\n    this.checkValid_();\n  }\n\n  /** @const {number} Maximum key depth. */\n  static get MAX_PATH_DEPTH() {\n    return 32;\n  }\n\n  /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */\n  static get MAX_PATH_LENGTH_BYTES() {\n    return 768;\n  }\n\n  /** @param {string} child */\n  push(child: string) {\n    // Count the needed '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ += 1;\n    }\n    this.parts_.push(child);\n    this.byteLength_ += stringLength(child);\n    this.checkValid_();\n  }\n\n  pop() {\n    const last = this.parts_.pop();\n    this.byteLength_ -= stringLength(last);\n    // Un-count the previous '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ -= 1;\n    }\n  }\n\n  private checkValid_() {\n    if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {\n      throw new Error(\n        this.errorPrefix_ +\n          'has a key path longer than ' +\n          ValidationPath.MAX_PATH_LENGTH_BYTES +\n          ' bytes (' +\n          this.byteLength_ +\n          ').'\n      );\n    }\n    if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {\n      throw new Error(\n        this.errorPrefix_ +\n          'path specified exceeds the maximum depth that can be written (' +\n          ValidationPath.MAX_PATH_DEPTH +\n          ') or object contains a cycle ' +\n          this.toErrorString()\n      );\n    }\n  }\n\n  /**\n   * String for use in error messages - uses '.' notation for path.\n   *\n   * @return {string}\n   */\n  toErrorString(): string {\n    if (this.parts_.length == 0) {\n      return '';\n    }\n    return \"in property '\" + this.parts_.join('.') + \"'\";\n  }\n}\n"]},"metadata":{},"sourceType":"script"}