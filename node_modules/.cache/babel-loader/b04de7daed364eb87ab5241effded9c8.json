{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Functionality related to the parsing/composition of bucket/\n * object location.\n */\nimport * as errorsExports from './error';\n/**\n * @struct\n */\nvar Location = /** @class */function () {\n  function Location(bucket, path) {\n    this.bucket = bucket;\n    this.path_ = path;\n  }\n  Object.defineProperty(Location.prototype, \"path\", {\n    get: function get() {\n      return this.path_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Location.prototype.fullServerUrl = function () {\n    var encode = encodeURIComponent;\n    return '/b/' + encode(this.bucket) + '/o/' + encode(this.path);\n  };\n  Location.prototype.bucketOnlyServerUrl = function () {\n    var encode = encodeURIComponent;\n    return '/b/' + encode(this.bucket) + '/o';\n  };\n  Location.makeFromBucketSpec = function (bucketString) {\n    var bucketLocation;\n    try {\n      bucketLocation = Location.makeFromUrl(bucketString);\n    } catch (e) {\n      // Not valid URL, use as-is. This lets you put bare bucket names in\n      // config.\n      return new Location(bucketString, '');\n    }\n    if (bucketLocation.path === '') {\n      return bucketLocation;\n    } else {\n      throw errorsExports.invalidDefaultBucket(bucketString);\n    }\n  };\n  Location.makeFromUrl = function (url) {\n    var location = null;\n    var bucketDomain = '([A-Za-z0-9.\\\\-]+)';\n    function gsModify(loc) {\n      if (loc.path.charAt(loc.path.length - 1) === '/') {\n        loc.path_ = loc.path_.slice(0, -1);\n      }\n    }\n    var gsPath = '(/(.*))?$';\n    var path = '(/([^?#]*).*)?$';\n    var gsRegex = new RegExp('^gs://' + bucketDomain + gsPath, 'i');\n    var gsIndices = {\n      bucket: 1,\n      path: 3\n    };\n    function httpModify(loc) {\n      loc.path_ = decodeURIComponent(loc.path);\n    }\n    var version = 'v[A-Za-z0-9_]+';\n    var httpRegex = new RegExp('^https?://firebasestorage\\\\.googleapis\\\\.com/' + version + '/b/' + bucketDomain + '/o' + path, 'i');\n    var httpIndices = {\n      bucket: 1,\n      path: 3\n    };\n    var groups = [{\n      regex: gsRegex,\n      indices: gsIndices,\n      postModify: gsModify\n    }, {\n      regex: httpRegex,\n      indices: httpIndices,\n      postModify: httpModify\n    }];\n    for (var i = 0; i < groups.length; i++) {\n      var group = groups[i];\n      var captures = group.regex.exec(url);\n      if (captures) {\n        var bucketValue = captures[group.indices.bucket];\n        var pathValue = captures[group.indices.path];\n        if (!pathValue) {\n          pathValue = '';\n        }\n        location = new Location(bucketValue, pathValue);\n        group.postModify(location);\n        break;\n      }\n    }\n    if (location == null) {\n      throw errorsExports.invalidUrl(url);\n    }\n    return location;\n  };\n  return Location;\n}();\nexport { Location };","map":{"version":3,"mappings":"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","names":["errorsExports","bucket","path","path_","Object","Location","encode","encodeURIComponent","bucketString","bucketLocation","makeFromUrl","e","invalidDefaultBucket","url","location","bucketDomain","loc","charAt","length","slice","gsPath","gsRegex","RegExp","gsIndices","decodeURIComponent","version","httpRegex","httpIndices","groups","regex","indices","postModify","gsModify","httpModify","i","group","captures","exec","bucketValue","pathValue","invalidUrl"],"sources":["../src/implementation/location.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Functionality related to the parsing/composition of bucket/\n * object location.\n */\nimport * as errorsExports from './error';\nimport { errors } from './error';\n\n/**\n * @struct\n */\nexport class Location {\n  private path_: string;\n\n  constructor(public readonly bucket: string, path: string) {\n    this.path_ = path;\n  }\n\n  get path(): string {\n    return this.path_;\n  }\n\n  fullServerUrl(): string {\n    let encode = encodeURIComponent;\n    return '/b/' + encode(this.bucket) + '/o/' + encode(this.path);\n  }\n\n  bucketOnlyServerUrl(): string {\n    let encode = encodeURIComponent;\n    return '/b/' + encode(this.bucket) + '/o';\n  }\n\n  static makeFromBucketSpec(bucketString: string): Location {\n    let bucketLocation;\n    try {\n      bucketLocation = Location.makeFromUrl(bucketString);\n    } catch (e) {\n      // Not valid URL, use as-is. This lets you put bare bucket names in\n      // config.\n      return new Location(bucketString, '');\n    }\n    if (bucketLocation.path === '') {\n      return bucketLocation;\n    } else {\n      throw errorsExports.invalidDefaultBucket(bucketString);\n    }\n  }\n\n  static makeFromUrl(url: string): Location {\n    let location = null;\n    let bucketDomain = '([A-Za-z0-9.\\\\-]+)';\n\n    function gsModify(loc: Location) {\n      if (loc.path.charAt(loc.path.length - 1) === '/') {\n        loc.path_ = loc.path_.slice(0, -1);\n      }\n    }\n    let gsPath = '(/(.*))?$';\n    let path = '(/([^?#]*).*)?$';\n    let gsRegex = new RegExp('^gs://' + bucketDomain + gsPath, 'i');\n    let gsIndices = { bucket: 1, path: 3 };\n\n    function httpModify(loc: Location) {\n      loc.path_ = decodeURIComponent(loc.path);\n    }\n    let version = 'v[A-Za-z0-9_]+';\n    let httpRegex = new RegExp(\n      '^https?://firebasestorage\\\\.googleapis\\\\.com/' +\n        version +\n        '/b/' +\n        bucketDomain +\n        '/o' +\n        path,\n      'i'\n    );\n    let httpIndices = { bucket: 1, path: 3 };\n    let groups = [\n      { regex: gsRegex, indices: gsIndices, postModify: gsModify },\n      { regex: httpRegex, indices: httpIndices, postModify: httpModify }\n    ];\n    for (let i = 0; i < groups.length; i++) {\n      let group = groups[i];\n      let captures = group.regex.exec(url);\n      if (captures) {\n        let bucketValue = captures[group.indices.bucket];\n        let pathValue = captures[group.indices.path];\n        if (!pathValue) {\n          pathValue = '';\n        }\n        location = new Location(bucketValue, pathValue);\n        group.postModify(location);\n        break;\n      }\n    }\n    if (location == null) {\n      throw errorsExports.invalidUrl(url);\n    }\n    return location;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}