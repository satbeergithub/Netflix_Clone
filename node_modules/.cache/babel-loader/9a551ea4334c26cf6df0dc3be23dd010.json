{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar app_1 = require(\"@firebase/app\");\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"../core/util/util\");\nvar StatsManager_1 = require(\"../core/stats/StatsManager\");\nvar Constants_1 = require(\"./Constants\");\nvar util_3 = require(\"@firebase/util\");\nvar storage_1 = require(\"../core/storage/storage\");\nvar util_4 = require(\"@firebase/util\");\nvar util_5 = require(\"@firebase/util\");\nvar WEBSOCKET_MAX_FRAME_SIZE = 16384;\nvar WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\nvar WebSocketImpl = null;\nif (typeof MozWebSocket !== 'undefined') {\n  WebSocketImpl = MozWebSocket;\n} else if (typeof WebSocket !== 'undefined') {\n  WebSocketImpl = WebSocket;\n}\nfunction setWebSocketImpl(impl) {\n  WebSocketImpl = impl;\n}\nexports.setWebSocketImpl = setWebSocketImpl;\n/**\n * Create a new websocket connection with the given callbacks.\n * @constructor\n * @implements {Transport}\n */\nvar WebSocketConnection = /** @class */function () {\n  /**\n   * @param {string} connId identifier for this transport\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   */\n  function WebSocketConnection(connId, repoInfo, transportSessionId, lastSessionId) {\n    this.connId = connId;\n    this.keepaliveTimer = null;\n    this.frames = null;\n    this.totalFrames = 0;\n    this.bytesSent = 0;\n    this.bytesReceived = 0;\n    this.log_ = util_2.logWrapper(this.connId);\n    this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo);\n    this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId);\n  }\n  /**\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   * @return {string} connection url\n   * @private\n   */\n  WebSocketConnection.connectionURL_ = function (repoInfo, transportSessionId, lastSessionId) {\n    var urlParams = {};\n    urlParams[Constants_1.VERSION_PARAM] = Constants_1.PROTOCOL_VERSION;\n    if (!util_5.isNodeSdk() && typeof location !== 'undefined' && location.href && location.href.indexOf(Constants_1.FORGE_DOMAIN) !== -1) {\n      urlParams[Constants_1.REFERER_PARAM] = Constants_1.FORGE_REF;\n    }\n    if (transportSessionId) {\n      urlParams[Constants_1.TRANSPORT_SESSION_PARAM] = transportSessionId;\n    }\n    if (lastSessionId) {\n      urlParams[Constants_1.LAST_SESSION_PARAM] = lastSessionId;\n    }\n    return repoInfo.connectionURL(Constants_1.WEBSOCKET, urlParams);\n  };\n  /**\n   *\n   * @param onMessage Callback when messages arrive\n   * @param onDisconnect Callback with connection lost.\n   */\n  WebSocketConnection.prototype.open = function (onMessage, onDisconnect) {\n    var _this = this;\n    this.onDisconnect = onDisconnect;\n    this.onMessage = onMessage;\n    this.log_('Websocket connecting to ' + this.connURL);\n    this.everConnected_ = false;\n    // Assume failure until proven otherwise.\n    storage_1.PersistentStorage.set('previous_websocket_failure', true);\n    try {\n      if (util_5.isNodeSdk()) {\n        var device = util_3.CONSTANTS.NODE_ADMIN ? 'AdminNode' : 'Node';\n        // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\n        var options = {\n          headers: {\n            'User-Agent': \"Firebase/\" + Constants_1.PROTOCOL_VERSION + \"/\" + app_1.default.SDK_VERSION + \"/\" + process.platform + \"/\" + device\n          }\n        };\n        // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\n        var env = process['env'];\n        var proxy = this.connURL.indexOf('wss://') == 0 ? env['HTTPS_PROXY'] || env['https_proxy'] : env['HTTP_PROXY'] || env['http_proxy'];\n        if (proxy) {\n          options['proxy'] = {\n            origin: proxy\n          };\n        }\n        this.mySock = new WebSocketImpl(this.connURL, [], options);\n      } else {\n        this.mySock = new WebSocketImpl(this.connURL);\n      }\n    } catch (e) {\n      this.log_('Error instantiating WebSocket.');\n      var error = e.message || e.data;\n      if (error) {\n        this.log_(error);\n      }\n      this.onClosed_();\n      return;\n    }\n    this.mySock.onopen = function () {\n      _this.log_('Websocket connected.');\n      _this.everConnected_ = true;\n    };\n    this.mySock.onclose = function () {\n      _this.log_('Websocket connection was disconnected.');\n      _this.mySock = null;\n      _this.onClosed_();\n    };\n    this.mySock.onmessage = function (m) {\n      _this.handleIncomingFrame(m);\n    };\n    this.mySock.onerror = function (e) {\n      _this.log_('WebSocket error.  Closing connection.');\n      var error = e.message || e.data;\n      if (error) {\n        _this.log_(error);\n      }\n      _this.onClosed_();\n    };\n  };\n  /**\n   * No-op for websockets, we don't need to do anything once the connection is confirmed as open\n   */\n  WebSocketConnection.prototype.start = function () {};\n  WebSocketConnection.forceDisallow = function () {\n    WebSocketConnection.forceDisallow_ = true;\n  };\n  WebSocketConnection.isAvailable = function () {\n    var isOldAndroid = false;\n    if (typeof navigator !== 'undefined' && navigator.userAgent) {\n      var oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\n      var oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\n      if (oldAndroidMatch && oldAndroidMatch.length > 1) {\n        if (parseFloat(oldAndroidMatch[1]) < 4.4) {\n          isOldAndroid = true;\n        }\n      }\n    }\n    return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection.forceDisallow_;\n  };\n  /**\n   * Returns true if we previously failed to connect with this transport.\n   * @return {boolean}\n   */\n  WebSocketConnection.previouslyFailed = function () {\n    // If our persistent storage is actually only in-memory storage,\n    // we default to assuming that it previously failed to be safe.\n    return storage_1.PersistentStorage.isInMemoryStorage || storage_1.PersistentStorage.get('previous_websocket_failure') === true;\n  };\n  WebSocketConnection.prototype.markConnectionHealthy = function () {\n    storage_1.PersistentStorage.remove('previous_websocket_failure');\n  };\n  WebSocketConnection.prototype.appendFrame_ = function (data) {\n    this.frames.push(data);\n    if (this.frames.length == this.totalFrames) {\n      var fullMess = this.frames.join('');\n      this.frames = null;\n      var jsonMess = util_4.jsonEval(fullMess);\n      //handle the message\n      this.onMessage(jsonMess);\n    }\n  };\n  /**\n   * @param {number} frameCount The number of frames we are expecting from the server\n   * @private\n   */\n  WebSocketConnection.prototype.handleNewFrameCount_ = function (frameCount) {\n    this.totalFrames = frameCount;\n    this.frames = [];\n  };\n  /**\n   * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\n   * @param {!String} data\n   * @return {?String} Any remaining data to be process, or null if there is none\n   * @private\n   */\n  WebSocketConnection.prototype.extractFrameCount_ = function (data) {\n    util_1.assert(this.frames === null, 'We already have a frame buffer');\n    // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n    // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\n    if (data.length <= 6) {\n      var frameCount = Number(data);\n      if (!isNaN(frameCount)) {\n        this.handleNewFrameCount_(frameCount);\n        return null;\n      }\n    }\n    this.handleNewFrameCount_(1);\n    return data;\n  };\n  /**\n   * Process a websocket frame that has arrived from the server.\n   * @param mess The frame data\n   */\n  WebSocketConnection.prototype.handleIncomingFrame = function (mess) {\n    if (this.mySock === null) return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n    var data = mess['data'];\n    this.bytesReceived += data.length;\n    this.stats_.incrementCounter('bytes_received', data.length);\n    this.resetKeepAlive();\n    if (this.frames !== null) {\n      // we're buffering\n      this.appendFrame_(data);\n    } else {\n      // try to parse out a frame count, otherwise, assume 1 and process it\n      var remainingData = this.extractFrameCount_(data);\n      if (remainingData !== null) {\n        this.appendFrame_(remainingData);\n      }\n    }\n  };\n  /**\n   * Send a message to the server\n   * @param {Object} data The JSON object to transmit\n   */\n  WebSocketConnection.prototype.send = function (data) {\n    this.resetKeepAlive();\n    var dataStr = util_4.stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length);\n    //We can only fit a certain amount in each websocket frame, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n    var dataSegs = util_2.splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\n    //Send the length header\n    if (dataSegs.length > 1) {\n      this.sendString_(String(dataSegs.length));\n    }\n    //Send the actual data in segments.\n    for (var i = 0; i < dataSegs.length; i++) {\n      this.sendString_(dataSegs[i]);\n    }\n  };\n  WebSocketConnection.prototype.shutdown_ = function () {\n    this.isClosed_ = true;\n    if (this.keepaliveTimer) {\n      clearInterval(this.keepaliveTimer);\n      this.keepaliveTimer = null;\n    }\n    if (this.mySock) {\n      this.mySock.close();\n      this.mySock = null;\n    }\n  };\n  WebSocketConnection.prototype.onClosed_ = function () {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is closing itself');\n      this.shutdown_();\n      // since this is an internal close, trigger the close listener\n      if (this.onDisconnect) {\n        this.onDisconnect(this.everConnected_);\n        this.onDisconnect = null;\n      }\n    }\n  };\n  /**\n   * External-facing close handler.\n   * Close the websocket and kill the connection.\n   */\n  WebSocketConnection.prototype.close = function () {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is being closed');\n      this.shutdown_();\n    }\n  };\n  /**\n   * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\n   * the last activity.\n   */\n  WebSocketConnection.prototype.resetKeepAlive = function () {\n    var _this = this;\n    clearInterval(this.keepaliveTimer);\n    this.keepaliveTimer = setInterval(function () {\n      //If there has been no websocket activity for a while, send a no-op\n      if (_this.mySock) {\n        _this.sendString_('0');\n      }\n      _this.resetKeepAlive();\n    }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));\n  };\n  /**\n   * Send a string over the websocket.\n   *\n   * @param {string} str String to send.\n   * @private\n   */\n  WebSocketConnection.prototype.sendString_ = function (str) {\n    // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n    // calls for some unknown reason.  We treat these as an error and disconnect.\n    // See https://app.asana.com/0/58926111402292/68021340250410\n    try {\n      this.mySock.send(str);\n    } catch (e) {\n      this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');\n      setTimeout(this.onClosed_.bind(this), 0);\n    }\n  };\n  /**\n   * Number of response before we consider the connection \"healthy.\"\n   * @type {number}\n   */\n  WebSocketConnection.responsesRequiredToBeHealthy = 2;\n  /**\n   * Time to wait for the connection te become healthy before giving up.\n   * @type {number}\n   */\n  WebSocketConnection.healthyTimeout = 30000;\n  return WebSocketConnection;\n}();\nexports.WebSocketConnection = WebSocketConnection;","map":{"version":3,"mappings":"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","names":["WEBSOCKET_MAX_FRAME_SIZE","WEBSOCKET_KEEPALIVE_INTERVAL","WebSocketImpl","MozWebSocket","WebSocket","impl","exports","connId","repoInfo","transportSessionId","lastSessionId","log_","util_2","stats_","StatsManager_1","getCollection","connURL","WebSocketConnection","connectionURL_","urlParams","Constants_1","util_5","location","href","indexOf","connectionURL","onMessage","onDisconnect","everConnected_","storage_1","set","device","util_3","NODE_ADMIN","options","headers","app_1","SDK_VERSION","process","platform","env","proxy","origin","mySock","e","error","message","data","onClosed_","onopen","_this","onclose","onmessage","m","handleIncomingFrame","onerror","forceDisallow_","isOldAndroid","navigator","userAgent","oldAndroidRegex","oldAndroidMatch","match","length","parseFloat","isInMemoryStorage","get","remove","frames","push","totalFrames","fullMess","join","jsonMess","util_4","frameCount","util_1","Number","isNaN","handleNewFrameCount_","mess","bytesReceived","incrementCounter","resetKeepAlive","appendFrame_","remainingData","extractFrameCount_","dataStr","bytesSent","dataSegs","sendString_","String","i","isClosed_","keepaliveTimer","clearInterval","close","shutdown_","setInterval","Math","floor","str","send","setTimeout","bind"],"sources":["../src/realtime/WebSocketConnection.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RepoInfo } from '../core/RepoInfo';\n\ndeclare const MozWebSocket: any;\n\nimport firebase from '@firebase/app';\nimport { assert } from '@firebase/util';\nimport { logWrapper, splitStringBySize } from '../core/util/util';\nimport { StatsManager } from '../core/stats/StatsManager';\nimport {\n  FORGE_DOMAIN,\n  FORGE_REF,\n  LAST_SESSION_PARAM,\n  PROTOCOL_VERSION,\n  REFERER_PARAM,\n  TRANSPORT_SESSION_PARAM,\n  VERSION_PARAM,\n  WEBSOCKET\n} from './Constants';\nimport { CONSTANTS as ENV_CONSTANTS } from '@firebase/util';\nimport { PersistentStorage } from '../core/storage/storage';\nimport { jsonEval, stringify } from '@firebase/util';\nimport { isNodeSdk } from '@firebase/util';\nimport { Transport } from './Transport';\nimport { StatsCollection } from '../core/stats/StatsCollection';\n\nconst WEBSOCKET_MAX_FRAME_SIZE = 16384;\nconst WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\n\nlet WebSocketImpl = null;\nif (typeof MozWebSocket !== 'undefined') {\n  WebSocketImpl = MozWebSocket;\n} else if (typeof WebSocket !== 'undefined') {\n  WebSocketImpl = WebSocket;\n}\n\nexport function setWebSocketImpl(impl) {\n  WebSocketImpl = impl;\n}\n\n/**\n * Create a new websocket connection with the given callbacks.\n * @constructor\n * @implements {Transport}\n */\nexport class WebSocketConnection implements Transport {\n  keepaliveTimer: number | null = null;\n  frames: string[] | null = null;\n  totalFrames = 0;\n  bytesSent = 0;\n  bytesReceived = 0;\n  connURL: string;\n  onDisconnect: (a?: boolean) => void;\n  onMessage: (msg: Object) => void;\n  mySock: any | null;\n  private log_: (...a: any[]) => void;\n  private stats_: StatsCollection;\n  private everConnected_: boolean;\n  private isClosed_: boolean;\n\n  /**\n   * @param {string} connId identifier for this transport\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   */\n  constructor(\n    public connId: string,\n    repoInfo: RepoInfo,\n    transportSessionId?: string,\n    lastSessionId?: string\n  ) {\n    this.log_ = logWrapper(this.connId);\n    this.stats_ = StatsManager.getCollection(repoInfo);\n    this.connURL = WebSocketConnection.connectionURL_(\n      repoInfo,\n      transportSessionId,\n      lastSessionId\n    );\n  }\n\n  /**\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   * @return {string} connection url\n   * @private\n   */\n  private static connectionURL_(\n    repoInfo: RepoInfo,\n    transportSessionId?: string,\n    lastSessionId?: string\n  ): string {\n    const urlParams: { [k: string]: string } = {};\n    urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n\n    if (\n      !isNodeSdk() &&\n      typeof location !== 'undefined' &&\n      location.href &&\n      location.href.indexOf(FORGE_DOMAIN) !== -1\n    ) {\n      urlParams[REFERER_PARAM] = FORGE_REF;\n    }\n    if (transportSessionId) {\n      urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\n    }\n    if (lastSessionId) {\n      urlParams[LAST_SESSION_PARAM] = lastSessionId;\n    }\n    return repoInfo.connectionURL(WEBSOCKET, urlParams);\n  }\n\n  /**\n   *\n   * @param onMessage Callback when messages arrive\n   * @param onDisconnect Callback with connection lost.\n   */\n  open(onMessage: (msg: Object) => void, onDisconnect: (a?: boolean) => void) {\n    this.onDisconnect = onDisconnect;\n    this.onMessage = onMessage;\n\n    this.log_('Websocket connecting to ' + this.connURL);\n\n    this.everConnected_ = false;\n    // Assume failure until proven otherwise.\n    PersistentStorage.set('previous_websocket_failure', true);\n\n    try {\n      if (isNodeSdk()) {\n        const device = ENV_CONSTANTS.NODE_ADMIN ? 'AdminNode' : 'Node';\n        // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\n        const options: { [k: string]: object } = {\n          headers: {\n            'User-Agent': `Firebase/${PROTOCOL_VERSION}/${\n              firebase.SDK_VERSION\n            }/${process.platform}/${device}`\n          }\n        };\n\n        // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\n        const env = process['env'];\n        const proxy =\n          this.connURL.indexOf('wss://') == 0\n            ? env['HTTPS_PROXY'] || env['https_proxy']\n            : env['HTTP_PROXY'] || env['http_proxy'];\n\n        if (proxy) {\n          options['proxy'] = { origin: proxy };\n        }\n\n        this.mySock = new WebSocketImpl(this.connURL, [], options);\n      } else {\n        this.mySock = new WebSocketImpl(this.connURL);\n      }\n    } catch (e) {\n      this.log_('Error instantiating WebSocket.');\n      const error = e.message || e.data;\n      if (error) {\n        this.log_(error);\n      }\n      this.onClosed_();\n      return;\n    }\n\n    this.mySock.onopen = () => {\n      this.log_('Websocket connected.');\n      this.everConnected_ = true;\n    };\n\n    this.mySock.onclose = () => {\n      this.log_('Websocket connection was disconnected.');\n      this.mySock = null;\n      this.onClosed_();\n    };\n\n    this.mySock.onmessage = (m: object) => {\n      this.handleIncomingFrame(m);\n    };\n\n    this.mySock.onerror = (e: any) => {\n      this.log_('WebSocket error.  Closing connection.');\n      const error = e.message || e.data;\n      if (error) {\n        this.log_(error);\n      }\n      this.onClosed_();\n    };\n  }\n\n  /**\n   * No-op for websockets, we don't need to do anything once the connection is confirmed as open\n   */\n  start() {}\n\n  static forceDisallow_: Boolean;\n\n  static forceDisallow() {\n    WebSocketConnection.forceDisallow_ = true;\n  }\n\n  static isAvailable(): boolean {\n    let isOldAndroid = false;\n    if (typeof navigator !== 'undefined' && navigator.userAgent) {\n      const oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\n      const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\n      if (oldAndroidMatch && oldAndroidMatch.length > 1) {\n        if (parseFloat(oldAndroidMatch[1]) < 4.4) {\n          isOldAndroid = true;\n        }\n      }\n    }\n\n    return (\n      !isOldAndroid &&\n      WebSocketImpl !== null &&\n      !WebSocketConnection.forceDisallow_\n    );\n  }\n\n  /**\n   * Number of response before we consider the connection \"healthy.\"\n   * @type {number}\n   */\n  static responsesRequiredToBeHealthy = 2;\n\n  /**\n   * Time to wait for the connection te become healthy before giving up.\n   * @type {number}\n   */\n  static healthyTimeout = 30000;\n\n  /**\n   * Returns true if we previously failed to connect with this transport.\n   * @return {boolean}\n   */\n  static previouslyFailed(): boolean {\n    // If our persistent storage is actually only in-memory storage,\n    // we default to assuming that it previously failed to be safe.\n    return (\n      PersistentStorage.isInMemoryStorage ||\n      PersistentStorage.get('previous_websocket_failure') === true\n    );\n  }\n\n  markConnectionHealthy() {\n    PersistentStorage.remove('previous_websocket_failure');\n  }\n\n  private appendFrame_(data: string) {\n    this.frames.push(data);\n    if (this.frames.length == this.totalFrames) {\n      const fullMess = this.frames.join('');\n      this.frames = null;\n      const jsonMess = jsonEval(fullMess);\n\n      //handle the message\n      this.onMessage(jsonMess);\n    }\n  }\n\n  /**\n   * @param {number} frameCount The number of frames we are expecting from the server\n   * @private\n   */\n  private handleNewFrameCount_(frameCount: number) {\n    this.totalFrames = frameCount;\n    this.frames = [];\n  }\n\n  /**\n   * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\n   * @param {!String} data\n   * @return {?String} Any remaining data to be process, or null if there is none\n   * @private\n   */\n  private extractFrameCount_(data: string): string | null {\n    assert(this.frames === null, 'We already have a frame buffer');\n    // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n    // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\n    if (data.length <= 6) {\n      const frameCount = Number(data);\n      if (!isNaN(frameCount)) {\n        this.handleNewFrameCount_(frameCount);\n        return null;\n      }\n    }\n    this.handleNewFrameCount_(1);\n    return data;\n  }\n\n  /**\n   * Process a websocket frame that has arrived from the server.\n   * @param mess The frame data\n   */\n  handleIncomingFrame(mess: { [k: string]: any }) {\n    if (this.mySock === null) return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n    const data = mess['data'] as string;\n    this.bytesReceived += data.length;\n    this.stats_.incrementCounter('bytes_received', data.length);\n\n    this.resetKeepAlive();\n\n    if (this.frames !== null) {\n      // we're buffering\n      this.appendFrame_(data);\n    } else {\n      // try to parse out a frame count, otherwise, assume 1 and process it\n      const remainingData = this.extractFrameCount_(data);\n      if (remainingData !== null) {\n        this.appendFrame_(remainingData);\n      }\n    }\n  }\n\n  /**\n   * Send a message to the server\n   * @param {Object} data The JSON object to transmit\n   */\n  send(data: Object) {\n    this.resetKeepAlive();\n\n    const dataStr = stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length);\n\n    //We can only fit a certain amount in each websocket frame, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n\n    const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\n\n    //Send the length header\n    if (dataSegs.length > 1) {\n      this.sendString_(String(dataSegs.length));\n    }\n\n    //Send the actual data in segments.\n    for (let i = 0; i < dataSegs.length; i++) {\n      this.sendString_(dataSegs[i]);\n    }\n  }\n\n  private shutdown_() {\n    this.isClosed_ = true;\n    if (this.keepaliveTimer) {\n      clearInterval(this.keepaliveTimer);\n      this.keepaliveTimer = null;\n    }\n\n    if (this.mySock) {\n      this.mySock.close();\n      this.mySock = null;\n    }\n  }\n\n  private onClosed_() {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is closing itself');\n      this.shutdown_();\n\n      // since this is an internal close, trigger the close listener\n      if (this.onDisconnect) {\n        this.onDisconnect(this.everConnected_);\n        this.onDisconnect = null;\n      }\n    }\n  }\n\n  /**\n   * External-facing close handler.\n   * Close the websocket and kill the connection.\n   */\n  close() {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is being closed');\n      this.shutdown_();\n    }\n  }\n\n  /**\n   * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\n   * the last activity.\n   */\n  resetKeepAlive() {\n    clearInterval(this.keepaliveTimer);\n    this.keepaliveTimer = setInterval(() => {\n      //If there has been no websocket activity for a while, send a no-op\n      if (this.mySock) {\n        this.sendString_('0');\n      }\n      this.resetKeepAlive();\n    }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL)) as any;\n  }\n\n  /**\n   * Send a string over the websocket.\n   *\n   * @param {string} str String to send.\n   * @private\n   */\n  private sendString_(str: string) {\n    // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n    // calls for some unknown reason.  We treat these as an error and disconnect.\n    // See https://app.asana.com/0/58926111402292/68021340250410\n    try {\n      this.mySock.send(str);\n    } catch (e) {\n      this.log_(\n        'Exception thrown from WebSocket.send():',\n        e.message || e.data,\n        'Closing connection.'\n      );\n      setTimeout(this.onClosed_.bind(this), 0);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}