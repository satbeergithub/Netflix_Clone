{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param f May be invoked\n *     before the function returns.\n * @param callback Get all the arguments passed to the function\n *     passed to f, including the initial boolean.\n */\nexport function start(f, callback, timeout) {\n  // TODO(andysoto): make this code cleaner (probably refactor into an actual\n  // type instead of a bunch of functions with state shared in the closure)\n  var waitSeconds = 1;\n  // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n  var timeoutId = null;\n  var hitTimeout = false;\n  var cancelState = 0;\n  function canceled() {\n    return cancelState === 2;\n  }\n  var triggeredCallback = false;\n  function triggerCallback() {\n    if (!triggeredCallback) {\n      triggeredCallback = true;\n      callback.apply(null, arguments);\n    }\n  }\n  function callWithDelay(millis) {\n    timeoutId = setTimeout(function () {\n      timeoutId = null;\n      f(handler, canceled());\n    }, millis);\n  }\n  function handler(success) {\n    var var_args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      var_args[_i - 1] = arguments[_i];\n    }\n    if (triggeredCallback) {\n      return;\n    }\n    if (success) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    var mustStop = canceled() || hitTimeout;\n    if (mustStop) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    if (waitSeconds < 64) {\n      /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n      waitSeconds *= 2;\n    }\n    var waitMillis;\n    if (cancelState === 1) {\n      cancelState = 2;\n      waitMillis = 0;\n    } else {\n      waitMillis = (waitSeconds + Math.random()) * 1000;\n    }\n    callWithDelay(waitMillis);\n  }\n  var stopped = false;\n  function stop(wasTimeout) {\n    if (stopped) {\n      return;\n    }\n    stopped = true;\n    if (triggeredCallback) {\n      return;\n    }\n    if (timeoutId !== null) {\n      if (!wasTimeout) {\n        cancelState = 2;\n      }\n      clearTimeout(timeoutId);\n      callWithDelay(0);\n    } else {\n      if (!wasTimeout) {\n        cancelState = 1;\n      }\n    }\n  }\n  callWithDelay(0);\n  setTimeout(function () {\n    hitTimeout = true;\n    stop(true);\n  }, timeout);\n  return stop;\n}\n/**\n * Stops the retry loop from repeating.\n * If the function is currently \"in between\" retries, it is invoked immediately\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\n * after the current invocation finishes iff the current invocation would have\n * triggered another retry.\n */\nexport function stop(id) {\n  id(false);\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;AAwBA;;;;;;AAMA,OAAM,eACJA,CAGS,EACTC,QAAkB,EAClBC,OAAe;EAEf;EACA;EACA,IAAIC,WAAW,GAAG,CAAC;EACnB;EACA,IAAIC,SAAS,GAAQ,IAAI;EACzB,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAIC,WAAW,GAAG,CAAC;EAEnB;IACE,OAAOA,WAAW,KAAK,CAAC;EAC1B;EACA,IAAIC,iBAAiB,GAAG,KAAK;EAE7B;IACE,IAAI,CAACA,iBAAiB,EAAE;MACtBA,iBAAiB,GAAG,IAAI;MACxBN,QAAQ,CAACO,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IACjC;EACF;EAEA,uBAAuBC,MAAc;IACnCN,SAAS,GAAGO,UAAU,CAAC;MACrBP,SAAS,GAAG,IAAI;MAChBJ,CAAC,CAACY,OAAO,EAAEC,QAAQ,EAAE,CAAC;IACxB,CAAC,EAAEH,MAAM,CAAC;EACZ;EAEA,iBAAiBI,OAAgB;IAAE;SAAA,UAAkB,EAAlBC,qBAAkB,EAAlBA,IAAkB;MAAlBC;;IACjC,IAAIT,iBAAiB,EAAE;MACrB;IACF;IACA,IAAIO,OAAO,EAAE;MACXG,eAAe,CAACT,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;MACtC;IACF;IACA,IAAIS,QAAQ,GAAGL,QAAQ,EAAE,IAAIR,UAAU;IACvC,IAAIa,QAAQ,EAAE;MACZD,eAAe,CAACT,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;MACtC;IACF;IACA,IAAIN,WAAW,GAAG,EAAE,EAAE;MACpB;MACAA,WAAW,IAAI,CAAC;IAClB;IACA,IAAIgB,UAAU;IACd,IAAIb,WAAW,KAAK,CAAC,EAAE;MACrBA,WAAW,GAAG,CAAC;MACfa,UAAU,GAAG,CAAC;IAChB,CAAC,MAAM;MACLA,UAAU,GAAG,CAAChB,WAAW,GAAGiB,IAAI,CAACC,MAAM,EAAE,IAAI,IAAI;IACnD;IACAC,aAAa,CAACH,UAAU,CAAC;EAC3B;EACA,IAAII,OAAO,GAAG,KAAK;EAEnB,cAAcC,UAAmB;IAC/B,IAAID,OAAO,EAAE;MACX;IACF;IACAA,OAAO,GAAG,IAAI;IACd,IAAIhB,iBAAiB,EAAE;MACrB;IACF;IACA,IAAIH,SAAS,KAAK,IAAI,EAAE;MACtB,IAAI,CAACoB,UAAU,EAAE;QACflB,WAAW,GAAG,CAAC;MACjB;MACAmB,YAAY,CAACrB,SAAS,CAAC;MACvBkB,aAAa,CAAC,CAAC,CAAC;IAClB,CAAC,MAAM;MACL,IAAI,CAACE,UAAU,EAAE;QACflB,WAAW,GAAG,CAAC;MACjB;IACF;EACF;EACAgB,aAAa,CAAC,CAAC,CAAC;EAChBX,UAAU,CAAC;IACTN,UAAU,GAAG,IAAI;IACjBqB,IAAI,CAAC,IAAI,CAAC;EACZ,CAAC,EAAExB,OAAO,CAAC;EACX,OAAOwB,IAAI;AACb;AAEA;;;;;;;AAOA,OAAM,cAAeC,EAAM;EACzBA,EAAE,CAAC,KAAK,CAAC;AACX","names":["f","callback","timeout","waitSeconds","timeoutId","hitTimeout","cancelState","triggeredCallback","apply","arguments","millis","setTimeout","handler","canceled","success","_i","var_args","triggerCallback","mustStop","waitMillis","Math","random","callWithDelay","stopped","wasTimeout","clearTimeout","stop","id"],"sources":["../src/implementation/backoff.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Provides a method for running a function with exponential\n * backoff.\n */\ntype id = (p1: boolean) => void;\n\nexport { id };\n\n/**\n * @param f May be invoked\n *     before the function returns.\n * @param callback Get all the arguments passed to the function\n *     passed to f, including the initial boolean.\n */\nexport function start(\n  f: (\n    p1: (success: boolean, ...rest: any[]) => void,\n    canceled: boolean\n  ) => void,\n  callback: Function,\n  timeout: number\n): id {\n  // TODO(andysoto): make this code cleaner (probably refactor into an actual\n  // type instead of a bunch of functions with state shared in the closure)\n  let waitSeconds = 1;\n  // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n  let timeoutId: any = null;\n  let hitTimeout = false;\n  let cancelState = 0;\n\n  function canceled() {\n    return cancelState === 2;\n  }\n  let triggeredCallback = false;\n\n  function triggerCallback() {\n    if (!triggeredCallback) {\n      triggeredCallback = true;\n      callback.apply(null, arguments);\n    }\n  }\n\n  function callWithDelay(millis: number): void {\n    timeoutId = setTimeout(function() {\n      timeoutId = null;\n      f(handler, canceled());\n    }, millis);\n  }\n\n  function handler(success: boolean, ...var_args: any[]): void {\n    if (triggeredCallback) {\n      return;\n    }\n    if (success) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    let mustStop = canceled() || hitTimeout;\n    if (mustStop) {\n      triggerCallback.apply(null, arguments);\n      return;\n    }\n    if (waitSeconds < 64) {\n      /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n      waitSeconds *= 2;\n    }\n    let waitMillis;\n    if (cancelState === 1) {\n      cancelState = 2;\n      waitMillis = 0;\n    } else {\n      waitMillis = (waitSeconds + Math.random()) * 1000;\n    }\n    callWithDelay(waitMillis);\n  }\n  let stopped = false;\n\n  function stop(wasTimeout: boolean): void {\n    if (stopped) {\n      return;\n    }\n    stopped = true;\n    if (triggeredCallback) {\n      return;\n    }\n    if (timeoutId !== null) {\n      if (!wasTimeout) {\n        cancelState = 2;\n      }\n      clearTimeout(timeoutId);\n      callWithDelay(0);\n    } else {\n      if (!wasTimeout) {\n        cancelState = 1;\n      }\n    }\n  }\n  callWithDelay(0);\n  setTimeout(function() {\n    hitTimeout = true;\n    stop(true);\n  }, timeout);\n  return stop;\n}\n\n/**\n * Stops the retry loop from repeating.\n * If the function is currently \"in between\" retries, it is invoked immediately\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\n * after the current invocation finishes iff the current invocation would have\n * triggered another retry.\n */\nexport function stop(id: id) {\n  id(false);\n}\n"]},"metadata":{},"sourceType":"module"}