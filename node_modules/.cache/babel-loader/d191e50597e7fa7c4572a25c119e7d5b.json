{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar DataSnapshot_1 = require(\"../../api/DataSnapshot\");\nvar Event_1 = require(\"./Event\");\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"@firebase/util\");\n/**\n * Represents registration for 'value' events.\n */\nvar ValueEventRegistration = /** @class */function () {\n  /**\n   * @param {?function(!DataSnapshot)} callback_\n   * @param {?function(Error)} cancelCallback_\n   * @param {?Object} context_\n   */\n  function ValueEventRegistration(callback_, cancelCallback_, context_) {\n    this.callback_ = callback_;\n    this.cancelCallback_ = cancelCallback_;\n    this.context_ = context_;\n  }\n  /**\n   * @inheritDoc\n   */\n  ValueEventRegistration.prototype.respondsTo = function (eventType) {\n    return eventType === 'value';\n  };\n  /**\n   * @inheritDoc\n   */\n  ValueEventRegistration.prototype.createEvent = function (change, query) {\n    var index = query.getQueryParams().getIndex();\n    return new Event_1.DataEvent('value', this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, query.getRef(), index));\n  };\n  /**\n   * @inheritDoc\n   */\n  ValueEventRegistration.prototype.getEventRunner = function (eventData) {\n    var ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');\n      var cancelCB_1 = this.cancelCallback_;\n      return function () {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB_1.call(ctx, eventData.error);\n      };\n    } else {\n      var cb_1 = this.callback_;\n      return function () {\n        cb_1.call(ctx, eventData.snapshot);\n      };\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  ValueEventRegistration.prototype.createCancelEvent = function (error, path) {\n    if (this.cancelCallback_) {\n      return new Event_1.CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  ValueEventRegistration.prototype.matches = function (other) {\n    if (!(other instanceof ValueEventRegistration)) {\n      return false;\n    } else if (!other.callback_ || !this.callback_) {\n      // If no callback specified, we consider it to match any callback.\n      return true;\n    } else {\n      return other.callback_ === this.callback_ && other.context_ === this.context_;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  ValueEventRegistration.prototype.hasAnyCallback = function () {\n    return this.callback_ !== null;\n  };\n  return ValueEventRegistration;\n}();\nexports.ValueEventRegistration = ValueEventRegistration;\n/**\n * Represents the registration of 1 or more child_xxx events.\n *\n * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you\n * register a group of callbacks together in the future.\n *\n * @constructor\n * @implements {EventRegistration}\n */\nvar ChildEventRegistration = /** @class */function () {\n  /**\n   * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_\n   * @param {?function(Error)} cancelCallback_\n   * @param {Object=} context_\n   */\n  function ChildEventRegistration(callbacks_, cancelCallback_, context_) {\n    this.callbacks_ = callbacks_;\n    this.cancelCallback_ = cancelCallback_;\n    this.context_ = context_;\n  }\n  /**\n   * @inheritDoc\n   */\n  ChildEventRegistration.prototype.respondsTo = function (eventType) {\n    var eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;\n    eventToCheck = eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\n    return util_1.contains(this.callbacks_, eventToCheck);\n  };\n  /**\n   * @inheritDoc\n   */\n  ChildEventRegistration.prototype.createCancelEvent = function (error, path) {\n    if (this.cancelCallback_) {\n      return new Event_1.CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  ChildEventRegistration.prototype.createEvent = function (change, query) {\n    util_2.assert(change.childName != null, 'Child events should have a childName.');\n    var ref = query.getRef().child( /** @type {!string} */change.childName);\n    var index = query.getQueryParams().getIndex();\n    return new Event_1.DataEvent(change.type, this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, ref, index), change.prevName);\n  };\n  /**\n   * @inheritDoc\n   */\n  ChildEventRegistration.prototype.getEventRunner = function (eventData) {\n    var ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');\n      var cancelCB_2 = this.cancelCallback_;\n      return function () {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB_2.call(ctx, eventData.error);\n      };\n    } else {\n      var cb_2 = this.callbacks_[eventData.eventType];\n      return function () {\n        cb_2.call(ctx, eventData.snapshot, eventData.prevName);\n      };\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  ChildEventRegistration.prototype.matches = function (other) {\n    if (other instanceof ChildEventRegistration) {\n      if (!this.callbacks_ || !other.callbacks_) {\n        return true;\n      } else if (this.context_ === other.context_) {\n        var otherCount = util_1.getCount(other.callbacks_);\n        var thisCount = util_1.getCount(this.callbacks_);\n        if (otherCount === thisCount) {\n          // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.\n          //  If event types don't match, not a match\n          // If count is not 1, exact match across all\n          if (otherCount === 1) {\n            var otherKey /** @type {!string} */ = util_1.getAnyKey(other.callbacks_);\n            var thisKey /** @type {!string} */ = util_1.getAnyKey(this.callbacks_);\n            return thisKey === otherKey && (!other.callbacks_[otherKey] || !this.callbacks_[thisKey] || other.callbacks_[otherKey] === this.callbacks_[thisKey]);\n          } else {\n            // Exact match on each key.\n            return util_1.every(this.callbacks_, function (eventType, cb) {\n              return other.callbacks_[eventType] === cb;\n            });\n          }\n        }\n      }\n    }\n    return false;\n  };\n  /**\n   * @inheritDoc\n   */\n  ChildEventRegistration.prototype.hasAnyCallback = function () {\n    return this.callbacks_ !== null;\n  };\n  return ChildEventRegistration;\n}();\nexports.ChildEventRegistration = ChildEventRegistration;","map":{"version":3,"mappings":"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","names":["callback_","cancelCallback_","context_","ValueEventRegistration","eventType","change","query","index","getQueryParams","getIndex","Event_1","DataSnapshot_1","snapshotNode","getRef","eventData","ctx","getEventType","util_2","cancelCB_1","call","error","cb_1","snapshot","path","other","exports","callbacks_","ChildEventRegistration","eventToCheck","util_1","childName","ref","child","type","prevName","cancelCB_2","cb_2","otherCount","thisCount","otherKey","thisKey","cb"],"sources":["../src/core/view/EventRegistration.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DataSnapshot } from '../../api/DataSnapshot';\nimport { DataEvent, CancelEvent, Event } from './Event';\nimport { contains, getCount, getAnyKey, every } from '@firebase/util';\nimport { assert } from '@firebase/util';\nimport { Path } from '../util/Path';\nimport { Change } from './Change';\nimport { Query } from '../../api/Query';\n\n/**\n * An EventRegistration is basically an event type ('value', 'child_added', etc.) and a callback\n * to be notified of that type of event.\n *\n * That said, it can also contain a cancel callback to be notified if the event is canceled.  And\n * currently, this code is organized around the idea that you would register multiple child_ callbacks\n * together, as a single EventRegistration.  Though currently we don't do that.\n */\nexport interface EventRegistration {\n  /**\n   * True if this container has a callback to trigger for this event type\n   * @param {!string} eventType\n   * @return {boolean}\n   */\n  respondsTo(eventType: string): boolean;\n\n  /**\n   * @param {!Change} change\n   * @param {!Query} query\n   * @return {!Event}\n   */\n  createEvent(change: Change, query: Query): Event;\n\n  /**\n   * Given event data, return a function to trigger the user's callback\n   * @param {!Event} eventData\n   * @return {function()}\n   */\n  getEventRunner(eventData: Event): () => void;\n\n  /**\n   * @param {!Error} error\n   * @param {!Path} path\n   * @return {?CancelEvent}\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null;\n\n  /**\n   * @param {!EventRegistration} other\n   * @return {boolean}\n   */\n  matches(other: EventRegistration): boolean;\n\n  /**\n   * False basically means this is a \"dummy\" callback container being used as a sentinel\n   * to remove all callback containers of a particular type.  (e.g. if the user does\n   * ref.off('value') without specifying a specific callback).\n   *\n   * (TODO: Rework this, since it's hacky)\n   *\n   * @return {boolean}\n   */\n  hasAnyCallback(): boolean;\n}\n\n/**\n * Represents registration for 'value' events.\n */\nexport class ValueEventRegistration implements EventRegistration {\n  /**\n   * @param {?function(!DataSnapshot)} callback_\n   * @param {?function(Error)} cancelCallback_\n   * @param {?Object} context_\n   */\n  constructor(\n    private callback_: ((d: DataSnapshot) => void) | null,\n    private cancelCallback_: ((e: Error) => void) | null,\n    private context_: Object | null\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  respondsTo(eventType: string): boolean {\n    return eventType === 'value';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createEvent(change: Change, query: Query): DataEvent {\n    const index = query.getQueryParams().getIndex();\n    return new DataEvent(\n      'value',\n      this,\n      new DataSnapshot(change.snapshotNode, query.getRef(), index)\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(eventData: CancelEvent | DataEvent): () => void {\n    const ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      assert(\n        this.cancelCallback_,\n        'Raising a cancel event on a listener with no cancel callback'\n      );\n      const cancelCB = this.cancelCallback_;\n      return function() {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB.call(ctx, (eventData as CancelEvent).error);\n      };\n    } else {\n      const cb = this.callback_;\n      return function() {\n        cb.call(ctx, (eventData as DataEvent).snapshot);\n      };\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null {\n    if (this.cancelCallback_) {\n      return new CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  matches(other: EventRegistration): boolean {\n    if (!(other instanceof ValueEventRegistration)) {\n      return false;\n    } else if (!other.callback_ || !this.callback_) {\n      // If no callback specified, we consider it to match any callback.\n      return true;\n    } else {\n      return (\n        other.callback_ === this.callback_ && other.context_ === this.context_\n      );\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasAnyCallback(): boolean {\n    return this.callback_ !== null;\n  }\n}\n\n/**\n * Represents the registration of 1 or more child_xxx events.\n *\n * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you\n * register a group of callbacks together in the future.\n *\n * @constructor\n * @implements {EventRegistration}\n */\nexport class ChildEventRegistration implements EventRegistration {\n  /**\n   * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_\n   * @param {?function(Error)} cancelCallback_\n   * @param {Object=} context_\n   */\n  constructor(\n    private callbacks_:\n      | ({ [k: string]: (d: DataSnapshot, s?: string | null) => void })\n      | null,\n    private cancelCallback_: ((e: Error) => void) | null,\n    private context_?: Object\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  respondsTo(eventType: string): boolean {\n    let eventToCheck =\n      eventType === 'children_added' ? 'child_added' : eventType;\n    eventToCheck =\n      eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\n    return contains(this.callbacks_, eventToCheck);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null {\n    if (this.cancelCallback_) {\n      return new CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createEvent(change: Change, query: Query): DataEvent {\n    assert(change.childName != null, 'Child events should have a childName.');\n    const ref = query.getRef().child(/** @type {!string} */ (change.childName));\n    const index = query.getQueryParams().getIndex();\n    return new DataEvent(\n      change.type as any,\n      this,\n      new DataSnapshot(change.snapshotNode, ref, index as any),\n      change.prevName\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(eventData: CancelEvent | DataEvent): () => void {\n    const ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      assert(\n        this.cancelCallback_,\n        'Raising a cancel event on a listener with no cancel callback'\n      );\n      const cancelCB = this.cancelCallback_;\n      return function() {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB.call(ctx, (eventData as CancelEvent).error);\n      };\n    } else {\n      const cb = this.callbacks_[(eventData as DataEvent).eventType];\n      return function() {\n        cb.call(\n          ctx,\n          (eventData as DataEvent).snapshot,\n          (eventData as DataEvent).prevName\n        );\n      };\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  matches(other: EventRegistration): boolean {\n    if (other instanceof ChildEventRegistration) {\n      if (!this.callbacks_ || !other.callbacks_) {\n        return true;\n      } else if (this.context_ === other.context_) {\n        const otherCount = getCount(other.callbacks_);\n        const thisCount = getCount(this.callbacks_);\n        if (otherCount === thisCount) {\n          // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.\n          //  If event types don't match, not a match\n          // If count is not 1, exact match across all\n\n          if (otherCount === 1) {\n            const otherKey /** @type {!string} */ = getAnyKey(other.callbacks_);\n            const thisKey /** @type {!string} */ = getAnyKey(this.callbacks_);\n            return (\n              thisKey === otherKey &&\n              (!other.callbacks_[otherKey] ||\n                !this.callbacks_[thisKey] ||\n                other.callbacks_[otherKey] === this.callbacks_[thisKey])\n            );\n          } else {\n            // Exact match on each key.\n            return every(\n              this.callbacks_,\n              (eventType, cb) => other.callbacks_[eventType] === cb\n            );\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasAnyCallback(): boolean {\n    return this.callbacks_ !== null;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}