{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar Path_1 = require(\"./Path\");\nvar SparseSnapshotTree_1 = require(\"../SparseSnapshotTree\");\nvar LeafNode_1 = require(\"../snap/LeafNode\");\nvar nodeFromJSON_1 = require(\"../snap/nodeFromJSON\");\nvar PriorityIndex_1 = require(\"../snap/indexes/PriorityIndex\");\n/**\n * Generate placeholders for deferred values.\n * @param {?Object} values\n * @return {!Object}\n */\nexports.generateWithValues = function (values) {\n  values = values || {};\n  values['timestamp'] = values['timestamp'] || new Date().getTime();\n  return values;\n};\n/**\n * Value to use when firing local events. When writing server values, fire\n * local events with an approximate value, otherwise return value as-is.\n * @param {(Object|string|number|boolean)} value\n * @param {!Object} serverValues\n * @return {!(string|number|boolean)}\n */\nexports.resolveDeferredValue = function (value, serverValues) {\n  if (!value || typeof value !== 'object') {\n    return value;\n  } else {\n    util_1.assert('.sv' in value, 'Unexpected leaf node or priority contents');\n    return serverValues[value['.sv']];\n  }\n};\n/**\n * Recursively replace all deferred values and priorities in the tree with the\n * specified generated replacement values.\n * @param {!SparseSnapshotTree} tree\n * @param {!Object} serverValues\n * @return {!SparseSnapshotTree}\n */\nexports.resolveDeferredValueTree = function (tree, serverValues) {\n  var resolvedTree = new SparseSnapshotTree_1.SparseSnapshotTree();\n  tree.forEachTree(new Path_1.Path(''), function (path, node) {\n    resolvedTree.remember(path, exports.resolveDeferredValueSnapshot(node, serverValues));\n  });\n  return resolvedTree;\n};\n/**\n * Recursively replace all deferred values and priorities in the node with the\n * specified generated replacement values.  If there are no server values in the node,\n * it'll be returned as-is.\n * @param {!Node} node\n * @param {!Object} serverValues\n * @return {!Node}\n */\nexports.resolveDeferredValueSnapshot = function (node, serverValues) {\n  var rawPri = node.getPriority().val();\n  var priority = exports.resolveDeferredValue(rawPri, serverValues);\n  var newNode;\n  if (node.isLeafNode()) {\n    var leafNode = node;\n    var value = exports.resolveDeferredValue(leafNode.getValue(), serverValues);\n    if (value !== leafNode.getValue() || priority !== leafNode.getPriority().val()) {\n      return new LeafNode_1.LeafNode(value, nodeFromJSON_1.nodeFromJSON(priority));\n    } else {\n      return node;\n    }\n  } else {\n    var childrenNode = node;\n    newNode = childrenNode;\n    if (priority !== childrenNode.getPriority().val()) {\n      newNode = newNode.updatePriority(new LeafNode_1.LeafNode(priority));\n    }\n    childrenNode.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {\n      var newChildNode = exports.resolveDeferredValueSnapshot(childNode, serverValues);\n      if (newChildNode !== childNode) {\n        newNode = newNode.updateImmediateChild(childName, newChildNode);\n      }\n    });\n    return newNode;\n  }\n};","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AAIA;;;;;AAKaA,0BAAkB,GAAG,UAChCC,MAEQ;EAERA,MAAM,GAAGA,MAAM,IAAI,EAAE;EACrBA,MAAM,CAAC,WAAW,CAAC,GAAGA,MAAM,CAAC,WAAW,CAAC,IAAI,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE;EACjE,OAAOF,MAAM;AACf,CAAC;AAED;;;;;;;AAOaD,4BAAoB,GAAG,UAClCI,KAAuD,EACvDC,YAAkC;EAElC,IAAI,CAACD,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IACvC,OAAOA,KAAkC;EAC3C,CAAC,MAAM;IACLE,aAAM,CAAC,KAAK,IAAIF,KAAK,EAAE,2CAA2C,CAAC;IACnE,OAAOC,YAAY,CAACD,KAAK,CAAC,KAAK,CAAC,CAAC;EACnC;AACF,CAAC;AAED;;;;;;;AAOaJ,gCAAwB,GAAG,UACtCO,IAAwB,EACxBF,YAAoB;EAEpB,IAAMG,YAAY,GAAG,IAAIC,uCAAkB,EAAE;EAC7CF,IAAI,CAACG,WAAW,CAAC,IAAIC,WAAI,CAAC,EAAE,CAAC,EAAE,UAASC,IAAI,EAAEC,IAAI;IAChDL,YAAY,CAACM,QAAQ,CACnBF,IAAI,EACJZ,oCAA4B,CAACa,IAAI,EAAER,YAAY,CAAC,CACjD;EACH,CAAC,CAAC;EACF,OAAOG,YAAY;AACrB,CAAC;AAED;;;;;;;;AAQaR,oCAA4B,GAAG,UAC1Ca,IAAU,EACVR,YAAoB;EAEpB,IAAMU,MAAM,GAAGF,IAAI,CAACG,WAAW,EAAE,CAACC,GAAG,EAK3B;EACV,IAAMC,QAAQ,GAAGlB,4BAAoB,CAACe,MAAM,EAAEV,YAAY,CAAC;EAC3D,IAAIc,OAAa;EAEjB,IAAIN,IAAI,CAACO,UAAU,EAAE,EAAE;IACrB,IAAMC,QAAQ,GAAGR,IAAgB;IACjC,IAAMT,KAAK,GAAGJ,4BAAoB,CAACqB,QAAQ,CAACC,QAAQ,EAAE,EAAEjB,YAAY,CAAC;IACrE,IACED,KAAK,KAAKiB,QAAQ,CAACC,QAAQ,EAAE,IAC7BJ,QAAQ,KAAKG,QAAQ,CAACL,WAAW,EAAE,CAACC,GAAG,EACzC,EAAE;MACA,OAAO,IAAIM,mBAAQ,CAACnB,KAAK,EAAEoB,2BAAY,CAACN,QAAQ,CAAC,CAAC;IACpD,CAAC,MAAM;MACL,OAAOL,IAAI;IACb;EACF,CAAC,MAAM;IACL,IAAMY,YAAY,GAAGZ,IAAoB;IACzCM,OAAO,GAAGM,YAAY;IACtB,IAAIP,QAAQ,KAAKO,YAAY,CAACT,WAAW,EAAE,CAACC,GAAG,EAAE,EAAE;MACjDE,OAAO,GAAGA,OAAO,CAACO,cAAc,CAAC,IAAIH,mBAAQ,CAACL,QAAQ,CAAC,CAAC;IAC1D;IACAO,YAAY,CAACE,YAAY,CAACC,8BAAc,EAAE,UAASC,SAAS,EAAEC,SAAS;MACrE,IAAMC,YAAY,GAAG/B,oCAA4B,CAC/C8B,SAAS,EACTzB,YAAY,CACb;MACD,IAAI0B,YAAY,KAAKD,SAAS,EAAE;QAC9BX,OAAO,GAAGA,OAAO,CAACa,oBAAoB,CAACH,SAAS,EAAEE,YAAY,CAAC;MACjE;IACF,CAAC,CAAC;IACF,OAAOZ,OAAO;EAChB;AACF,CAAC","names":["exports","values","Date","getTime","value","serverValues","util_1","tree","resolvedTree","SparseSnapshotTree_1","forEachTree","Path_1","path","node","remember","rawPri","getPriority","val","priority","newNode","isLeafNode","leafNode","getValue","LeafNode_1","nodeFromJSON_1","childrenNode","updatePriority","forEachChild","PriorityIndex_1","childName","childNode","newChildNode","updateImmediateChild"],"sources":["../src/core/util/ServerValues.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Path } from './Path';\nimport { SparseSnapshotTree } from '../SparseSnapshotTree';\nimport { LeafNode } from '../snap/LeafNode';\nimport { nodeFromJSON } from '../snap/nodeFromJSON';\nimport { PRIORITY_INDEX } from '../snap/indexes/PriorityIndex';\nimport { Node } from '../snap/Node';\nimport { ChildrenNode } from '../snap/ChildrenNode';\n\n/**\n * Generate placeholders for deferred values.\n * @param {?Object} values\n * @return {!Object}\n */\nexport const generateWithValues = function(\n  values: {\n    [k: string]: any;\n  } | null\n): { [k: string]: any } {\n  values = values || {};\n  values['timestamp'] = values['timestamp'] || new Date().getTime();\n  return values;\n};\n\n/**\n * Value to use when firing local events. When writing server values, fire\n * local events with an approximate value, otherwise return value as-is.\n * @param {(Object|string|number|boolean)} value\n * @param {!Object} serverValues\n * @return {!(string|number|boolean)}\n */\nexport const resolveDeferredValue = function(\n  value: { [k: string]: any } | string | number | boolean,\n  serverValues: { [k: string]: any }\n): string | number | boolean {\n  if (!value || typeof value !== 'object') {\n    return value as string | number | boolean;\n  } else {\n    assert('.sv' in value, 'Unexpected leaf node or priority contents');\n    return serverValues[value['.sv']];\n  }\n};\n\n/**\n * Recursively replace all deferred values and priorities in the tree with the\n * specified generated replacement values.\n * @param {!SparseSnapshotTree} tree\n * @param {!Object} serverValues\n * @return {!SparseSnapshotTree}\n */\nexport const resolveDeferredValueTree = function(\n  tree: SparseSnapshotTree,\n  serverValues: Object\n): SparseSnapshotTree {\n  const resolvedTree = new SparseSnapshotTree();\n  tree.forEachTree(new Path(''), function(path, node) {\n    resolvedTree.remember(\n      path,\n      resolveDeferredValueSnapshot(node, serverValues)\n    );\n  });\n  return resolvedTree;\n};\n\n/**\n * Recursively replace all deferred values and priorities in the node with the\n * specified generated replacement values.  If there are no server values in the node,\n * it'll be returned as-is.\n * @param {!Node} node\n * @param {!Object} serverValues\n * @return {!Node}\n */\nexport const resolveDeferredValueSnapshot = function(\n  node: Node,\n  serverValues: Object\n): Node {\n  const rawPri = node.getPriority().val() as\n    | object\n    | boolean\n    | null\n    | number\n    | string;\n  const priority = resolveDeferredValue(rawPri, serverValues);\n  let newNode: Node;\n\n  if (node.isLeafNode()) {\n    const leafNode = node as LeafNode;\n    const value = resolveDeferredValue(leafNode.getValue(), serverValues);\n    if (\n      value !== leafNode.getValue() ||\n      priority !== leafNode.getPriority().val()\n    ) {\n      return new LeafNode(value, nodeFromJSON(priority));\n    } else {\n      return node;\n    }\n  } else {\n    const childrenNode = node as ChildrenNode;\n    newNode = childrenNode;\n    if (priority !== childrenNode.getPriority().val()) {\n      newNode = newNode.updatePriority(new LeafNode(priority));\n    }\n    childrenNode.forEachChild(PRIORITY_INDEX, function(childName, childNode) {\n      const newChildNode = resolveDeferredValueSnapshot(\n        childNode,\n        serverValues\n      );\n      if (newChildNode !== childNode) {\n        newNode = newNode.updateImmediateChild(childName, newChildNode);\n      }\n    });\n    return newNode;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}