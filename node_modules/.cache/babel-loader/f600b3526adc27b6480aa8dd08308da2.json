{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar SortedMap_1 = require(\"../util/SortedMap\");\nvar SortedMap_2 = require(\"../util/SortedMap\");\nvar LOG_2 = Math.log(2);\n/**\n * @constructor\n */\nvar Base12Num = /** @class */function () {\n  /**\n   * @param {number} length\n   */\n  function Base12Num(length) {\n    var logBase2 = function logBase2(num) {\n      return parseInt(Math.log(num) / LOG_2, 10);\n    };\n    var bitMask = function bitMask(bits) {\n      return parseInt(Array(bits + 1).join('1'), 2);\n    };\n    this.count = logBase2(length + 1);\n    this.current_ = this.count - 1;\n    var mask = bitMask(this.count);\n    this.bits_ = length + 1 & mask;\n  }\n  /**\n   * @return {boolean}\n   */\n  Base12Num.prototype.nextBitIsOne = function () {\n    //noinspection JSBitwiseOperatorUsage\n    var result = !(this.bits_ & 0x1 << this.current_);\n    this.current_--;\n    return result;\n  };\n  return Base12Num;\n}();\n/**\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\n * function\n *\n * Uses the algorithm described in the paper linked here:\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\n *\n * @template K, V\n * @param {Array.<!NamedNode>} childList Unsorted list of children\n * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used\n * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's\n *                                                        type is not NamedNode\n * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map\n * @return {SortedMap.<K, V>}\n */\nexports.buildChildSet = function (childList, cmp, keyFn, mapSortFn) {\n  childList.sort(cmp);\n  var buildBalancedTree = function buildBalancedTree(low, high) {\n    var length = high - low;\n    var namedNode;\n    var key;\n    if (length == 0) {\n      return null;\n    } else if (length == 1) {\n      namedNode = childList[low];\n      key = keyFn ? keyFn(namedNode) : namedNode;\n      return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, null, null);\n    } else {\n      var middle = parseInt(length / 2, 10) + low;\n      var left = buildBalancedTree(low, middle);\n      var right = buildBalancedTree(middle + 1, high);\n      namedNode = childList[middle];\n      key = keyFn ? keyFn(namedNode) : namedNode;\n      return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, left, right);\n    }\n  };\n  var buildFrom12Array = function buildFrom12Array(base12) {\n    var node = null;\n    var root = null;\n    var index = childList.length;\n    var buildPennant = function buildPennant(chunkSize, color) {\n      var low = index - chunkSize;\n      var high = index;\n      index -= chunkSize;\n      var childTree = buildBalancedTree(low + 1, high);\n      var namedNode = childList[low];\n      var key = keyFn ? keyFn(namedNode) : namedNode;\n      attachPennant(new SortedMap_1.LLRBNode(key, namedNode.node, color, null, childTree));\n    };\n    var attachPennant = function attachPennant(pennant) {\n      if (node) {\n        node.left = pennant;\n        node = pennant;\n      } else {\n        root = pennant;\n        node = pennant;\n      }\n    };\n    for (var i = 0; i < base12.count; ++i) {\n      var isOne = base12.nextBitIsOne();\n      // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\n      var chunkSize = Math.pow(2, base12.count - (i + 1));\n      if (isOne) {\n        buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);\n      } else {\n        // current == 2\n        buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);\n        buildPennant(chunkSize, SortedMap_1.LLRBNode.RED);\n      }\n    }\n    return root;\n  };\n  var base12 = new Base12Num(childList.length);\n  var root = buildFrom12Array(base12);\n  return new SortedMap_2.SortedMap(mapSortFn || cmp, root);\n};","map":{"version":3,"mappings":"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","names":["LOG_2","Math","log","length","logBase2","num","bitMask","bits","Array","join","count","current_","mask","bits_","Base12Num","result","exports","childList","cmp","keyFn","mapSortFn","sort","buildBalancedTree","low","high","namedNode","key","SortedMap_1","node","BLACK","middle","parseInt","left","right","buildFrom12Array","base12","root","index","buildPennant","chunkSize","color","childTree","attachPennant","pennant","i","isOne","nextBitIsOne","pow","RED","SortedMap_2"],"sources":["../src/core/snap/childSet.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LLRBNode } from '../util/SortedMap';\nimport { SortedMap } from '../util/SortedMap';\nimport { NamedNode } from './Node';\n\nconst LOG_2 = Math.log(2);\n\n/**\n * @constructor\n */\nclass Base12Num {\n  count: number;\n  private current_: number;\n  private bits_: number;\n\n  /**\n   * @param {number} length\n   */\n  constructor(length: number) {\n    const logBase2 = (num: number) =>\n      parseInt((Math.log(num) / LOG_2) as any, 10);\n    const bitMask = (bits: number) => parseInt(Array(bits + 1).join('1'), 2);\n    this.count = logBase2(length + 1);\n    this.current_ = this.count - 1;\n    const mask = bitMask(this.count);\n    this.bits_ = (length + 1) & mask;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  nextBitIsOne(): boolean {\n    //noinspection JSBitwiseOperatorUsage\n    const result = !(this.bits_ & (0x1 << this.current_));\n    this.current_--;\n    return result;\n  }\n}\n\n/**\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\n * function\n *\n * Uses the algorithm described in the paper linked here:\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\n *\n * @template K, V\n * @param {Array.<!NamedNode>} childList Unsorted list of children\n * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used\n * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's\n *                                                        type is not NamedNode\n * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map\n * @return {SortedMap.<K, V>}\n */\nexport const buildChildSet = function<K, V>(\n  childList: NamedNode[],\n  cmp: (a: NamedNode, b: NamedNode) => number,\n  keyFn?: (a: NamedNode) => K,\n  mapSortFn?: (a: K, b: K) => number\n): SortedMap<K, V> {\n  childList.sort(cmp);\n\n  const buildBalancedTree = function(\n    low: number,\n    high: number\n  ): LLRBNode<K, V> | null {\n    const length = high - low;\n    let namedNode: NamedNode;\n    let key: K;\n    if (length == 0) {\n      return null;\n    } else if (length == 1) {\n      namedNode = childList[low];\n      key = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      return new LLRBNode(\n        key,\n        (namedNode.node as any) as V,\n        LLRBNode.BLACK,\n        null,\n        null\n      );\n    } else {\n      const middle = parseInt((length / 2) as any, 10) + low;\n      const left = buildBalancedTree(low, middle);\n      const right = buildBalancedTree(middle + 1, high);\n      namedNode = childList[middle];\n      key = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      return new LLRBNode(\n        key,\n        (namedNode.node as any) as V,\n        LLRBNode.BLACK,\n        left,\n        right\n      );\n    }\n  };\n\n  const buildFrom12Array = function(base12: Base12Num): LLRBNode<K, V> {\n    let node: LLRBNode<K, V> = null;\n    let root = null;\n    let index = childList.length;\n\n    const buildPennant = function(chunkSize: number, color: boolean) {\n      const low = index - chunkSize;\n      const high = index;\n      index -= chunkSize;\n      const childTree = buildBalancedTree(low + 1, high);\n      const namedNode = childList[low];\n      const key: K = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      attachPennant(\n        new LLRBNode(key, (namedNode.node as any) as V, color, null, childTree)\n      );\n    };\n\n    const attachPennant = function(pennant: LLRBNode<K, V>) {\n      if (node) {\n        node.left = pennant;\n        node = pennant;\n      } else {\n        root = pennant;\n        node = pennant;\n      }\n    };\n\n    for (let i = 0; i < base12.count; ++i) {\n      const isOne = base12.nextBitIsOne();\n      // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\n      const chunkSize = Math.pow(2, base12.count - (i + 1));\n      if (isOne) {\n        buildPennant(chunkSize, LLRBNode.BLACK);\n      } else {\n        // current == 2\n        buildPennant(chunkSize, LLRBNode.BLACK);\n        buildPennant(chunkSize, LLRBNode.RED);\n      }\n    }\n    return root;\n  };\n\n  const base12 = new Base12Num(childList.length);\n  const root = buildFrom12Array(base12);\n\n  return new SortedMap<K, V>(mapSortFn || (cmp as any), root);\n};\n"]},"metadata":{},"sourceType":"script"}