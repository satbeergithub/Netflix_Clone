{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Path_1 = require(\"../Path\");\nvar RepoInfo_1 = require(\"../../RepoInfo\");\nvar util_1 = require(\"../util\");\n/**\n * @param {!string} pathString\n * @return {string}\n */\nfunction decodePath(pathString) {\n  var pathStringDecoded = '';\n  var pieces = pathString.split('/');\n  for (var i = 0; i < pieces.length; i++) {\n    if (pieces[i].length > 0) {\n      var piece = pieces[i];\n      try {\n        piece = decodeURIComponent(piece.replace(/\\+/g, ' '));\n      } catch (e) {}\n      pathStringDecoded += '/' + piece;\n    }\n  }\n  return pathStringDecoded;\n}\n/**\n *\n * @param {!string} dataURL\n * @return {{repoInfo: !RepoInfo, path: !Path}}\n */\nexports.parseRepoInfo = function (dataURL) {\n  var parsedUrl = exports.parseURL(dataURL),\n    namespace = parsedUrl.subdomain;\n  if (parsedUrl.domain === 'firebase') {\n    util_1.fatal(parsedUrl.host + ' is no longer supported. ' + 'Please use <YOUR FIREBASE>.firebaseio.com instead');\n  }\n  // Catch common error of uninitialized namespace value.\n  if (!namespace || namespace == 'undefined') {\n    util_1.fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');\n  }\n  if (!parsedUrl.secure) {\n    util_1.warnIfPageIsSecure();\n  }\n  var webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';\n  return {\n    repoInfo: new RepoInfo_1.RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly),\n    path: new Path_1.Path(parsedUrl.pathString)\n  };\n};\n/**\n *\n * @param {!string} dataURL\n * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string}}\n */\nexports.parseURL = function (dataURL) {\n  // Default to empty strings in the event of a malformed string.\n  var host = '',\n    domain = '',\n    subdomain = '',\n    pathString = '';\n  // Always default to SSL, unless otherwise specified.\n  var secure = true,\n    scheme = 'https',\n    port = 443;\n  // Don't do any validation here. The caller is responsible for validating the result of parsing.\n  if (typeof dataURL === 'string') {\n    // Parse scheme.\n    var colonInd = dataURL.indexOf('//');\n    if (colonInd >= 0) {\n      scheme = dataURL.substring(0, colonInd - 1);\n      dataURL = dataURL.substring(colonInd + 2);\n    }\n    // Parse host and path.\n    var slashInd = dataURL.indexOf('/');\n    if (slashInd === -1) {\n      slashInd = dataURL.length;\n    }\n    host = dataURL.substring(0, slashInd);\n    pathString = decodePath(dataURL.substring(slashInd));\n    var parts = host.split('.');\n    if (parts.length === 3) {\n      // Normalize namespaces to lowercase to share storage / connection.\n      domain = parts[1];\n      subdomain = parts[0].toLowerCase();\n    } else if (parts.length === 2) {\n      domain = parts[0];\n    }\n    // If we have a port, use scheme for determining if it's secure.\n    colonInd = host.indexOf(':');\n    if (colonInd >= 0) {\n      secure = scheme === 'https' || scheme === 'wss';\n      port = parseInt(host.substring(colonInd + 1), 10);\n    }\n  }\n  return {\n    host: host,\n    port: port,\n    domain: domain,\n    subdomain: subdomain,\n    secure: secure,\n    scheme: scheme,\n    pathString: pathString\n  };\n};","map":{"version":3,"mappings":"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","names":["pathString","pathStringDecoded","pieces","split","i","length","piece","decodeURIComponent","replace","e","exports","dataURL","parsedUrl","namespace","subdomain","domain","util_1","host","secure","webSocketOnly","scheme","repoInfo","RepoInfo_1","path","Path_1","port","colonInd","indexOf","substring","slashInd","decodePath","parts","toLowerCase","parseInt"],"sources":["../src/core/util/libs/parser.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from '../Path';\nimport { RepoInfo } from '../../RepoInfo';\nimport { warnIfPageIsSecure, fatal } from '../util';\n\n/**\n * @param {!string} pathString\n * @return {string}\n */\nfunction decodePath(pathString: string): string {\n  let pathStringDecoded = '';\n  const pieces = pathString.split('/');\n  for (let i = 0; i < pieces.length; i++) {\n    if (pieces[i].length > 0) {\n      let piece = pieces[i];\n      try {\n        piece = decodeURIComponent(piece.replace(/\\+/g, ' '));\n      } catch (e) {}\n      pathStringDecoded += '/' + piece;\n    }\n  }\n  return pathStringDecoded;\n}\n\n/**\n *\n * @param {!string} dataURL\n * @return {{repoInfo: !RepoInfo, path: !Path}}\n */\nexport const parseRepoInfo = function(\n  dataURL: string\n): { repoInfo: RepoInfo; path: Path } {\n  const parsedUrl = parseURL(dataURL),\n    namespace = parsedUrl.subdomain;\n\n  if (parsedUrl.domain === 'firebase') {\n    fatal(\n      parsedUrl.host +\n        ' is no longer supported. ' +\n        'Please use <YOUR FIREBASE>.firebaseio.com instead'\n    );\n  }\n\n  // Catch common error of uninitialized namespace value.\n  if (!namespace || namespace == 'undefined') {\n    fatal(\n      'Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com'\n    );\n  }\n\n  if (!parsedUrl.secure) {\n    warnIfPageIsSecure();\n  }\n\n  const webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';\n\n  return {\n    repoInfo: new RepoInfo(\n      parsedUrl.host,\n      parsedUrl.secure,\n      namespace,\n      webSocketOnly\n    ),\n    path: new Path(parsedUrl.pathString)\n  };\n};\n\n/**\n *\n * @param {!string} dataURL\n * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string}}\n */\nexport const parseURL = function(\n  dataURL: string\n): {\n  host: string;\n  port: number;\n  domain: string;\n  subdomain: string;\n  secure: boolean;\n  scheme: string;\n  pathString: string;\n} {\n  // Default to empty strings in the event of a malformed string.\n  let host = '',\n    domain = '',\n    subdomain = '',\n    pathString = '';\n\n  // Always default to SSL, unless otherwise specified.\n  let secure = true,\n    scheme = 'https',\n    port = 443;\n\n  // Don't do any validation here. The caller is responsible for validating the result of parsing.\n  if (typeof dataURL === 'string') {\n    // Parse scheme.\n    let colonInd = dataURL.indexOf('//');\n    if (colonInd >= 0) {\n      scheme = dataURL.substring(0, colonInd - 1);\n      dataURL = dataURL.substring(colonInd + 2);\n    }\n\n    // Parse host and path.\n    let slashInd = dataURL.indexOf('/');\n    if (slashInd === -1) {\n      slashInd = dataURL.length;\n    }\n    host = dataURL.substring(0, slashInd);\n    pathString = decodePath(dataURL.substring(slashInd));\n\n    const parts = host.split('.');\n    if (parts.length === 3) {\n      // Normalize namespaces to lowercase to share storage / connection.\n      domain = parts[1];\n      subdomain = parts[0].toLowerCase();\n    } else if (parts.length === 2) {\n      domain = parts[0];\n    }\n\n    // If we have a port, use scheme for determining if it's secure.\n    colonInd = host.indexOf(':');\n    if (colonInd >= 0) {\n      secure = scheme === 'https' || scheme === 'wss';\n      port = parseInt(host.substring(colonInd + 1), 10);\n    }\n  }\n\n  return {\n    host,\n    port,\n    domain,\n    subdomain,\n    secure,\n    scheme,\n    pathString\n  };\n};\n"]},"metadata":{},"sourceType":"script"}