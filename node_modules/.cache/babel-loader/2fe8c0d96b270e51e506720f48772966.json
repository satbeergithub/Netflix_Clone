{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as json from './json';\nimport { Location } from './location';\nimport * as path from './path';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nexport function noXform_(metadata, value) {\n  return value;\n}\n/**\n * @struct\n */\nvar Mapping = /** @class */function () {\n  function Mapping(server, opt_local, opt_writable, opt_xform) {\n    this.server = server;\n    this.local = opt_local || server;\n    this.writable = !!opt_writable;\n    this.xform = opt_xform || noXform_;\n  }\n  return Mapping;\n}();\nexport { Mapping };\nvar mappings_ = null;\nexport function xformPath(fullPath) {\n  var valid = type.isString(fullPath);\n  if (!valid || fullPath.length < 2) {\n    return fullPath;\n  } else {\n    fullPath = fullPath;\n    return path.lastComponent(fullPath);\n  }\n}\nexport function getMappings() {\n  if (mappings_) {\n    return mappings_;\n  }\n  var mappings = [];\n  mappings.push(new Mapping('bucket'));\n  mappings.push(new Mapping('generation'));\n  mappings.push(new Mapping('metageneration'));\n  mappings.push(new Mapping('name', 'fullPath', true));\n  function mappingsXformPath(metadata, fullPath) {\n    return xformPath(fullPath);\n  }\n  var nameMapping = new Mapping('name');\n  nameMapping.xform = mappingsXformPath;\n  mappings.push(nameMapping);\n  /**\n   * Coerces the second param to a number, if it is defined.\n   */\n  function xformSize(metadata, size) {\n    if (type.isDef(size)) {\n      return +size;\n    } else {\n      return size;\n    }\n  }\n  var sizeMapping = new Mapping('size');\n  sizeMapping.xform = xformSize;\n  mappings.push(sizeMapping);\n  mappings.push(new Mapping('timeCreated'));\n  mappings.push(new Mapping('updated'));\n  mappings.push(new Mapping('md5Hash', null, true));\n  mappings.push(new Mapping('cacheControl', null, true));\n  mappings.push(new Mapping('contentDisposition', null, true));\n  mappings.push(new Mapping('contentEncoding', null, true));\n  mappings.push(new Mapping('contentLanguage', null, true));\n  mappings.push(new Mapping('contentType', null, true));\n  mappings.push(new Mapping('metadata', 'customMetadata', true));\n  /**\n   * Transforms a comma-separated string of tokens into a list of download\n   * URLs.\n   */\n  function xformTokens(metadata, tokens) {\n    var valid = type.isString(tokens) && tokens.length > 0;\n    if (!valid) {\n      // This can happen if objects are uploaded through GCS and retrieved\n      // through list, so we don't want to throw an Error.\n      return [];\n    }\n    var encode = encodeURIComponent;\n    var tokensList = tokens.split(',');\n    var urls = tokensList.map(function (token) {\n      var bucket = metadata['bucket'];\n      var path = metadata['fullPath'];\n      var urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n      var base = UrlUtils.makeDownloadUrl(urlPart);\n      var queryString = UrlUtils.makeQueryString({\n        alt: 'media',\n        token: token\n      });\n      return base + queryString;\n    });\n    return urls;\n  }\n  mappings.push(new Mapping('downloadTokens', 'downloadURLs', false, xformTokens));\n  mappings_ = mappings;\n  return mappings_;\n}\nexport function addRef(metadata, authWrapper) {\n  function generateRef() {\n    var bucket = metadata['bucket'];\n    var path = metadata['fullPath'];\n    var loc = new Location(bucket, path);\n    return authWrapper.makeStorageReference(loc);\n  }\n  Object.defineProperty(metadata, 'ref', {\n    get: generateRef\n  });\n}\nexport function fromResource(authWrapper, resource, mappings) {\n  var metadata = {};\n  metadata['type'] = 'file';\n  var len = mappings.length;\n  for (var i = 0; i < len; i++) {\n    var mapping = mappings[i];\n    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n  }\n  addRef(metadata, authWrapper);\n  return metadata;\n}\nexport function fromResourceString(authWrapper, resourceString, mappings) {\n  var obj = json.jsonObjectOrNull(resourceString);\n  if (obj === null) {\n    return null;\n  }\n  var resource = obj;\n  return fromResource(authWrapper, resource, mappings);\n}\nexport function toResourceString(metadata, mappings) {\n  var resource = {};\n  var len = mappings.length;\n  for (var i = 0; i < len; i++) {\n    var mapping = mappings[i];\n    if (mapping.writable) {\n      resource[mapping.server] = metadata[mapping.local];\n    }\n  }\n  return JSON.stringify(resource);\n}\nexport function metadataValidator(p) {\n  var validType = p && type.isObject(p);\n  if (!validType) {\n    throw 'Expected Metadata object.';\n  }\n  for (var key in p) {\n    var val = p[key];\n    if (key === 'customMetadata') {\n      if (!type.isObject(val)) {\n        throw 'Expected object for \\'customMetadata\\' mapping.';\n      }\n    } else {\n      if (type.isNonNullObject(val)) {\n        throw \"Mapping for '\" + key + \"' cannot be an object.\";\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["json","Location","path","type","UrlUtils","metadata","value","server","opt_local","opt_writable","opt_xform","local","writable","xform","noXform_","mappings_","fullPath","valid","isString","length","lastComponent","mappings","push","Mapping","xformPath","nameMapping","mappingsXformPath","size","isDef","sizeMapping","xformSize","tokens","encode","encodeURIComponent","tokensList","split","urls","map","token","bucket","urlPart","base","makeDownloadUrl","queryString","makeQueryString","alt","xformTokens","authWrapper","loc","makeStorageReference","Object","defineProperty","get","generateRef","resource","len","i","mapping","addRef","resourceString","obj","jsonObjectOrNull","fromResource","JSON","stringify","p","validType","isObject","key","val","isNonNullObject"],"sources":["../src/implementation/metadata.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Documentation for the metadata format\n */\nimport { Metadata } from '../metadata';\n\nimport { AuthWrapper } from './authwrapper';\nimport * as json from './json';\nimport { Location } from './location';\nimport * as path from './path';\nimport * as type from './type';\nimport * as UrlUtils from './url';\n\nexport function noXform_(metadata: Metadata, value: any): any {\n  return value;\n}\n\n/**\n * @struct\n */\nexport class Mapping {\n  local: string;\n  writable: boolean;\n  xform: (p1: Metadata, p2: any) => any;\n\n  constructor(\n    public server: string,\n    opt_local?: string | null,\n    opt_writable?: boolean,\n    opt_xform?: (p1: Metadata, p2: any) => any | null\n  ) {\n    this.local = opt_local || server;\n    this.writable = !!opt_writable;\n    this.xform = opt_xform || noXform_;\n  }\n}\ntype Mappings = Mapping[];\n\nexport { Mappings };\n\nlet mappings_: Mappings | null = null;\n\nexport function xformPath(fullPath: any): string {\n  let valid = type.isString(fullPath);\n  if (!valid || fullPath.length < 2) {\n    return fullPath;\n  } else {\n    fullPath = fullPath as string;\n    return path.lastComponent(fullPath);\n  }\n}\n\nexport function getMappings(): Mappings {\n  if (mappings_) {\n    return mappings_;\n  }\n  let mappings = [];\n  mappings.push(new Mapping('bucket'));\n  mappings.push(new Mapping('generation'));\n  mappings.push(new Mapping('metageneration'));\n  mappings.push(new Mapping('name', 'fullPath', true));\n\n  function mappingsXformPath(metadata: Metadata, fullPath: any): string {\n    return xformPath(fullPath);\n  }\n  let nameMapping = new Mapping('name');\n  nameMapping.xform = mappingsXformPath;\n  mappings.push(nameMapping);\n\n  /**\n   * Coerces the second param to a number, if it is defined.\n   */\n  function xformSize(metadata: Metadata, size: any): number | null | undefined {\n    if (type.isDef(size)) {\n      return +(size as number);\n    } else {\n      return size;\n    }\n  }\n  let sizeMapping = new Mapping('size');\n  sizeMapping.xform = xformSize;\n  mappings.push(sizeMapping);\n  mappings.push(new Mapping('timeCreated'));\n  mappings.push(new Mapping('updated'));\n  mappings.push(new Mapping('md5Hash', null, true));\n  mappings.push(new Mapping('cacheControl', null, true));\n  mappings.push(new Mapping('contentDisposition', null, true));\n  mappings.push(new Mapping('contentEncoding', null, true));\n  mappings.push(new Mapping('contentLanguage', null, true));\n  mappings.push(new Mapping('contentType', null, true));\n  mappings.push(new Mapping('metadata', 'customMetadata', true));\n\n  /**\n   * Transforms a comma-separated string of tokens into a list of download\n   * URLs.\n   */\n  function xformTokens(metadata: Metadata, tokens: any): string[] {\n    let valid = type.isString(tokens) && tokens.length > 0;\n    if (!valid) {\n      // This can happen if objects are uploaded through GCS and retrieved\n      // through list, so we don't want to throw an Error.\n      return [];\n    }\n    let encode = encodeURIComponent;\n    let tokensList = tokens.split(',');\n    let urls = tokensList.map(function(token: string) {\n      let bucket: string = metadata['bucket'] as string;\n      let path: string = metadata['fullPath'] as string;\n      let urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n      let base = UrlUtils.makeDownloadUrl(urlPart);\n      let queryString = UrlUtils.makeQueryString({\n        alt: 'media',\n        token: token\n      });\n      return base + queryString;\n    });\n    return urls;\n  }\n  mappings.push(\n    new Mapping('downloadTokens', 'downloadURLs', false, xformTokens)\n  );\n  mappings_ = mappings;\n  return mappings_;\n}\n\nexport function addRef(metadata: Metadata, authWrapper: AuthWrapper) {\n  function generateRef() {\n    let bucket: string = metadata['bucket'] as string;\n    let path: string = metadata['fullPath'] as string;\n    let loc = new Location(bucket, path);\n    return authWrapper.makeStorageReference(loc);\n  }\n  Object.defineProperty(metadata, 'ref', { get: generateRef });\n}\n\nexport function fromResource(\n  authWrapper: AuthWrapper,\n  resource: { [name: string]: any },\n  mappings: Mappings\n): Metadata {\n  let metadata: Metadata = {} as Metadata;\n  metadata['type'] = 'file';\n  let len = mappings.length;\n  for (let i = 0; i < len; i++) {\n    let mapping = mappings[i];\n    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n  }\n  addRef(metadata, authWrapper);\n  return metadata;\n}\n\nexport function fromResourceString(\n  authWrapper: AuthWrapper,\n  resourceString: string,\n  mappings: Mappings\n): Metadata | null {\n  let obj = json.jsonObjectOrNull(resourceString);\n  if (obj === null) {\n    return null;\n  }\n  let resource = obj as Metadata;\n  return fromResource(authWrapper, resource, mappings);\n}\n\nexport function toResourceString(\n  metadata: Metadata,\n  mappings: Mappings\n): string {\n  let resource: {\n    [prop: string]: any;\n  } = {};\n  let len = mappings.length;\n  for (let i = 0; i < len; i++) {\n    let mapping = mappings[i];\n    if (mapping.writable) {\n      resource[mapping.server] = metadata[mapping.local];\n    }\n  }\n  return JSON.stringify(resource);\n}\n\nexport function metadataValidator(p: any) {\n  let validType = p && type.isObject(p);\n  if (!validType) {\n    throw 'Expected Metadata object.';\n  }\n  for (let key in p) {\n    let val = p[key];\n    if (key === 'customMetadata') {\n      if (!type.isObject(val)) {\n        throw 'Expected object for \\'customMetadata\\' mapping.';\n      }\n    } else {\n      if (type.isNonNullObject(val)) {\n        throw \"Mapping for '\" + key + \"' cannot be an object.\";\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}