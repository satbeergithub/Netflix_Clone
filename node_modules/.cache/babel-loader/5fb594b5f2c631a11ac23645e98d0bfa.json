{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"../util/util\");\nvar snap_1 = require(\"./snap\");\nvar __childrenNodeConstructor;\n/**\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\n * implements Node and stores the value of the node (a string,\n * number, or boolean) accessible via getValue().\n */\nvar LeafNode = /** @class */function () {\n  /**\n   * @implements {Node}\n   * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.\n   *                                         The object type is possible in the event of a deferred value\n   * @param {!Node=} priorityNode_ The priority of this node.\n   */\n  function LeafNode(value_, priorityNode_) {\n    if (priorityNode_ === void 0) {\n      priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n    this.value_ = value_;\n    this.priorityNode_ = priorityNode_;\n    this.lazyHash_ = null;\n    util_1.assert(this.value_ !== undefined && this.value_ !== null, \"LeafNode shouldn't be created with null/undefined value.\");\n    snap_1.validatePriorityNode(this.priorityNode_);\n  }\n  Object.defineProperty(LeafNode, \"__childrenNodeConstructor\", {\n    get: function () {\n      return __childrenNodeConstructor;\n    },\n    set: function (val) {\n      __childrenNodeConstructor = val;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @inheritDoc */\n  LeafNode.prototype.isLeafNode = function () {\n    return true;\n  };\n  /** @inheritDoc */\n  LeafNode.prototype.getPriority = function () {\n    return this.priorityNode_;\n  };\n  /** @inheritDoc */\n  LeafNode.prototype.updatePriority = function (newPriorityNode) {\n    return new LeafNode(this.value_, newPriorityNode);\n  };\n  /** @inheritDoc */\n  LeafNode.prototype.getImmediateChild = function (childName) {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  };\n  /** @inheritDoc */\n  LeafNode.prototype.getChild = function (path) {\n    if (path.isEmpty()) {\n      return this;\n    } else if (path.getFront() === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  LeafNode.prototype.hasChild = function () {\n    return false;\n  };\n  /** @inheritDoc */\n  LeafNode.prototype.getPredecessorChildName = function (childName, childNode) {\n    return null;\n  };\n  /** @inheritDoc */\n  LeafNode.prototype.updateImmediateChild = function (childName, newChildNode) {\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else if (newChildNode.isEmpty() && childName !== '.priority') {\n      return this;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);\n    }\n  };\n  /** @inheritDoc */\n  LeafNode.prototype.updateChild = function (path, newChildNode) {\n    var front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else if (newChildNode.isEmpty() && front !== '.priority') {\n      return this;\n    } else {\n      util_1.assert(front !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');\n      return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(path.popFront(), newChildNode));\n    }\n  };\n  /** @inheritDoc */\n  LeafNode.prototype.isEmpty = function () {\n    return false;\n  };\n  /** @inheritDoc */\n  LeafNode.prototype.numChildren = function () {\n    return 0;\n  };\n  /** @inheritDoc */\n  LeafNode.prototype.forEachChild = function (index, action) {\n    return false;\n  };\n  /**\n   * @inheritDoc\n   */\n  LeafNode.prototype.val = function (exportFormat) {\n    if (exportFormat && !this.getPriority().isEmpty()) return {\n      '.value': this.getValue(),\n      '.priority': this.getPriority().val()\n    };else return this.getValue();\n  };\n  /** @inheritDoc */\n  LeafNode.prototype.hash = function () {\n    if (this.lazyHash_ === null) {\n      var toHash = '';\n      if (!this.priorityNode_.isEmpty()) toHash += 'priority:' + snap_1.priorityHashText(this.priorityNode_.val()) + ':';\n      var type = typeof this.value_;\n      toHash += type + ':';\n      if (type === 'number') {\n        toHash += util_2.doubleToIEEE754String(this.value_);\n      } else {\n        toHash += this.value_;\n      }\n      this.lazyHash_ = util_2.sha1(toHash);\n    }\n    return this.lazyHash_;\n  };\n  /**\n   * Returns the value of the leaf node.\n   * @return {Object|string|number|boolean} The value of the node.\n   */\n  LeafNode.prototype.getValue = function () {\n    return this.value_;\n  };\n  /**\n   * @inheritDoc\n   */\n  LeafNode.prototype.compareTo = function (other) {\n    if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n      return 1;\n    } else if (other instanceof LeafNode.__childrenNodeConstructor) {\n      return -1;\n    } else {\n      util_1.assert(other.isLeafNode(), 'Unknown node type');\n      return this.compareToLeafNode_(other);\n    }\n  };\n  /**\n   * Comparison specifically for two leaf nodes\n   * @param {!LeafNode} otherLeaf\n   * @return {!number}\n   * @private\n   */\n  LeafNode.prototype.compareToLeafNode_ = function (otherLeaf) {\n    var otherLeafType = typeof otherLeaf.value_;\n    var thisLeafType = typeof this.value_;\n    var otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n    var thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n    util_1.assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\n    util_1.assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\n    if (otherIndex === thisIndex) {\n      // Same type, compare values\n      if (thisLeafType === 'object') {\n        // Deferred value nodes are all equal, but we should also never get to this point...\n        return 0;\n      } else {\n        // Note that this works because true > false, all others are number or string comparisons\n        if (this.value_ < otherLeaf.value_) {\n          return -1;\n        } else if (this.value_ === otherLeaf.value_) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n    } else {\n      return thisIndex - otherIndex;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  LeafNode.prototype.withIndex = function () {\n    return this;\n  };\n  /**\n   * @inheritDoc\n   */\n  LeafNode.prototype.isIndexed = function () {\n    return true;\n  };\n  /**\n   * @inheritDoc\n   */\n  LeafNode.prototype.equals = function (other) {\n    /**\n     * @inheritDoc\n     */\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      var otherLeaf = other;\n      return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);\n    } else {\n      return false;\n    }\n  };\n  /**\n   * The sort order for comparing leaf nodes of different types. If two leaf nodes have\n   * the same type, the comparison falls back to their value\n   * @type {Array.<!string>}\n   * @const\n   */\n  LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\n  return LeafNode;\n}();\nexports.LeafNode = LeafNode;","map":{"version":3,"mappings":"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","names":["__childrenNodeConstructor","value_","priorityNode_","LeafNode","EMPTY_NODE","util_1","undefined","snap_1","Object","val","newPriorityNode","childName","path","isEmpty","getFront","childNode","newChildNode","updatePriority","updateImmediateChild","front","getLength","updateChild","popFront","index","action","exportFormat","getPriority","getValue","lazyHash_","toHash","type","util_2","other","isLeafNode","compareToLeafNode_","otherLeaf","otherLeafType","thisLeafType","otherIndex","VALUE_TYPE_ORDER","indexOf","thisIndex","equals","exports"],"sources":["../src/core/snap/LeafNode.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { doubleToIEEE754String, sha1 } from '../util/util';\nimport { priorityHashText, validatePriorityNode } from './snap';\nimport { Node } from './Node';\nimport { Path } from '../util/Path';\nimport { Index } from './indexes/Index';\nimport { ChildrenNodeConstructor } from './ChildrenNode';\n\nlet __childrenNodeConstructor: ChildrenNodeConstructor;\n\n/**\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\n * implements Node and stores the value of the node (a string,\n * number, or boolean) accessible via getValue().\n */\nexport class LeafNode implements Node {\n  static set __childrenNodeConstructor(val: ChildrenNodeConstructor) {\n    __childrenNodeConstructor = val;\n  }\n\n  static get __childrenNodeConstructor() {\n    return __childrenNodeConstructor;\n  }\n\n  /**\n   * The sort order for comparing leaf nodes of different types. If two leaf nodes have\n   * the same type, the comparison falls back to their value\n   * @type {Array.<!string>}\n   * @const\n   */\n  static VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\n\n  private lazyHash_: string | null = null;\n\n  /**\n   * @implements {Node}\n   * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.\n   *                                         The object type is possible in the event of a deferred value\n   * @param {!Node=} priorityNode_ The priority of this node.\n   */\n  constructor(\n    private readonly value_: string | number | boolean | object,\n    private priorityNode_: Node = LeafNode.__childrenNodeConstructor.EMPTY_NODE\n  ) {\n    assert(\n      this.value_ !== undefined && this.value_ !== null,\n      \"LeafNode shouldn't be created with null/undefined value.\"\n    );\n\n    validatePriorityNode(this.priorityNode_);\n  }\n\n  /** @inheritDoc */\n  isLeafNode(): boolean {\n    return true;\n  }\n\n  /** @inheritDoc */\n  getPriority(): Node {\n    return this.priorityNode_;\n  }\n\n  /** @inheritDoc */\n  updatePriority(newPriorityNode: Node): Node {\n    return new LeafNode(this.value_, newPriorityNode);\n  }\n\n  /** @inheritDoc */\n  getImmediateChild(childName: string): Node {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  }\n\n  /** @inheritDoc */\n  getChild(path: Path): Node {\n    if (path.isEmpty()) {\n      return this;\n    } else if (path.getFront() === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasChild(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  getPredecessorChildName(childName: String, childNode: Node): null {\n    return null;\n  }\n\n  /** @inheritDoc */\n  updateImmediateChild(childName: string, newChildNode: Node): Node {\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else if (newChildNode.isEmpty() && childName !== '.priority') {\n      return this;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(\n        childName,\n        newChildNode\n      ).updatePriority(this.priorityNode_);\n    }\n  }\n\n  /** @inheritDoc */\n  updateChild(path: Path, newChildNode: Node): Node {\n    const front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else if (newChildNode.isEmpty() && front !== '.priority') {\n      return this;\n    } else {\n      assert(\n        front !== '.priority' || path.getLength() === 1,\n        '.priority must be the last token in a path'\n      );\n\n      return this.updateImmediateChild(\n        front,\n        LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(\n          path.popFront(),\n          newChildNode\n        )\n      );\n    }\n  }\n\n  /** @inheritDoc */\n  isEmpty(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  numChildren(): number {\n    return 0;\n  }\n\n  /** @inheritDoc */\n  forEachChild(index: Index, action: (s: string, n: Node) => void): any {\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  val(exportFormat?: boolean): Object {\n    if (exportFormat && !this.getPriority().isEmpty())\n      return {\n        '.value': this.getValue(),\n        '.priority': this.getPriority().val()\n      };\n    else return this.getValue();\n  }\n\n  /** @inheritDoc */\n  hash(): string {\n    if (this.lazyHash_ === null) {\n      let toHash = '';\n      if (!this.priorityNode_.isEmpty())\n        toHash +=\n          'priority:' +\n          priorityHashText(this.priorityNode_.val() as number | string) +\n          ':';\n\n      const type = typeof this.value_;\n      toHash += type + ':';\n      if (type === 'number') {\n        toHash += doubleToIEEE754String(this.value_ as number);\n      } else {\n        toHash += this.value_;\n      }\n      this.lazyHash_ = sha1(toHash);\n    }\n    return this.lazyHash_;\n  }\n\n  /**\n   * Returns the value of the leaf node.\n   * @return {Object|string|number|boolean} The value of the node.\n   */\n  getValue(): object | string | number | boolean {\n    return this.value_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compareTo(other: Node): number {\n    if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n      return 1;\n    } else if (other instanceof LeafNode.__childrenNodeConstructor) {\n      return -1;\n    } else {\n      assert(other.isLeafNode(), 'Unknown node type');\n      return this.compareToLeafNode_(other as LeafNode);\n    }\n  }\n\n  /**\n   * Comparison specifically for two leaf nodes\n   * @param {!LeafNode} otherLeaf\n   * @return {!number}\n   * @private\n   */\n  private compareToLeafNode_(otherLeaf: LeafNode): number {\n    const otherLeafType = typeof otherLeaf.value_;\n    const thisLeafType = typeof this.value_;\n    const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n    const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n    assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\n    assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\n    if (otherIndex === thisIndex) {\n      // Same type, compare values\n      if (thisLeafType === 'object') {\n        // Deferred value nodes are all equal, but we should also never get to this point...\n        return 0;\n      } else {\n        // Note that this works because true > false, all others are number or string comparisons\n        if (this.value_ < otherLeaf.value_) {\n          return -1;\n        } else if (this.value_ === otherLeaf.value_) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n    } else {\n      return thisIndex - otherIndex;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  withIndex(): Node {\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isIndexed(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  equals(other: Node): boolean {\n    /**\n     * @inheritDoc\n     */\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      const otherLeaf = other as LeafNode;\n      return (\n        this.value_ === otherLeaf.value_ &&\n        this.priorityNode_.equals(otherLeaf.priorityNode_)\n      );\n    } else {\n      return false;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}