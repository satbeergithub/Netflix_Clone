{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"../util/util\");\nvar StatsListener_1 = require(\"./StatsListener\");\n// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\n// seconds to try to ensure the Firebase connection is established / settled.\nvar FIRST_STATS_MIN_TIME = 10 * 1000;\nvar FIRST_STATS_MAX_TIME = 30 * 1000;\n// We'll continue to report stats on average every 5 minutes.\nvar REPORT_STATS_INTERVAL = 5 * 60 * 1000;\n/**\n * @constructor\n */\nvar StatsReporter = /** @class */function () {\n  /**\n   * @param collection\n   * @param server_\n   */\n  function StatsReporter(collection, server_) {\n    this.server_ = server_;\n    this.statsToReport_ = {};\n    this.statsListener_ = new StatsListener_1.StatsListener(collection);\n    var timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\n    util_2.setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\n  }\n  StatsReporter.prototype.includeStat = function (stat) {\n    this.statsToReport_[stat] = true;\n  };\n  StatsReporter.prototype.reportStats_ = function () {\n    var _this = this;\n    var stats = this.statsListener_.get();\n    var reportedStats = {};\n    var haveStatsToReport = false;\n    util_1.forEach(stats, function (stat, value) {\n      if (value > 0 && util_1.contains(_this.statsToReport_, stat)) {\n        reportedStats[stat] = value;\n        haveStatsToReport = true;\n      }\n    });\n    if (haveStatsToReport) {\n      this.server_.reportStats(reportedStats);\n    }\n    // queue our next run.\n    util_2.setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));\n  };\n  return StatsReporter;\n}();\nexports.StatsReporter = StatsReporter;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AAIA;AACA;AACA;AACA,IAAMA,oBAAoB,GAAG,EAAE,GAAG,IAAI;AACtC,IAAMC,oBAAoB,GAAG,EAAE,GAAG,IAAI;AAEtC;AACA,IAAMC,qBAAqB,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI;AAE3C;;;AAGA;EAIE;;;;EAIA,uBAAYC,UAA2B,EAAUC,OAAsB;IAAtB,YAAO,GAAPA,OAAO;IANhD,mBAAc,GAA6B,EAAE;IAOnD,IAAI,CAACC,cAAc,GAAG,IAAIC,6BAAa,CAACH,UAAU,CAAC;IAEnD,IAAMI,OAAO,GACXP,oBAAoB,GACpB,CAACC,oBAAoB,GAAGD,oBAAoB,IAAIQ,IAAI,CAACC,MAAM,EAAE;IAC/DC,4BAAqB,CAAC,IAAI,CAACC,YAAY,CAACC,IAAI,CAAC,IAAI,CAAC,EAAEJ,IAAI,CAACK,KAAK,CAACN,OAAO,CAAC,CAAC;EAC1E;EAEAO,mCAAW,GAAX,UAAYC,IAAY;IACtB,IAAI,CAACC,cAAc,CAACD,IAAI,CAAC,GAAG,IAAI;EAClC,CAAC;EAEOD,oCAAY,GAApB;IAAA;IACE,IAAMG,KAAK,GAAG,IAAI,CAACZ,cAAc,CAACa,GAAG,EAAE;IACvC,IAAMC,aAAa,GAAiB,EAAE;IACtC,IAAIC,iBAAiB,GAAG,KAAK;IAE7BC,cAAO,CAACJ,KAAK,EAAE,UAACF,IAAY,EAAEO,KAAa;MACzC,IAAIA,KAAK,GAAG,CAAC,IAAID,eAAQ,CAACE,KAAI,CAACP,cAAc,EAAED,IAAI,CAAC,EAAE;QACpDI,aAAa,CAACJ,IAAI,CAAC,GAAGO,KAAK;QAC3BF,iBAAiB,GAAG,IAAI;MAC1B;IACF,CAAC,CAAC;IAEF,IAAIA,iBAAiB,EAAE;MACrB,IAAI,CAAChB,OAAO,CAACoB,WAAW,CAACL,aAAa,CAAC;IACzC;IAEA;IACAT,4BAAqB,CACnB,IAAI,CAACC,YAAY,CAACC,IAAI,CAAC,IAAI,CAAC,EAC5BJ,IAAI,CAACK,KAAK,CAACL,IAAI,CAACC,MAAM,EAAE,GAAG,CAAC,GAAGP,qBAAqB,CAAC,CACtD;EACH,CAAC;EACH,oBAAC;AAAD,CA3CA,EA2CC;AA3CYuB","names":["FIRST_STATS_MIN_TIME","FIRST_STATS_MAX_TIME","REPORT_STATS_INTERVAL","collection","server_","statsListener_","StatsListener_1","timeout","Math","random","util_2","reportStats_","bind","floor","StatsReporter","stat","statsToReport_","stats","get","reportedStats","haveStatsToReport","util_1","value","_this","reportStats","exports"],"sources":["../src/core/stats/StatsReporter.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { contains, forEach } from '@firebase/util';\nimport { setTimeoutNonBlocking } from '../util/util';\nimport { StatsListener } from './StatsListener';\nimport { StatsCollection } from './StatsCollection';\nimport { ServerActions } from '../ServerActions';\n\n// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\n// seconds to try to ensure the Firebase connection is established / settled.\nconst FIRST_STATS_MIN_TIME = 10 * 1000;\nconst FIRST_STATS_MAX_TIME = 30 * 1000;\n\n// We'll continue to report stats on average every 5 minutes.\nconst REPORT_STATS_INTERVAL = 5 * 60 * 1000;\n\n/**\n * @constructor\n */\nexport class StatsReporter {\n  private statsListener_: StatsListener;\n  private statsToReport_: { [k: string]: boolean } = {};\n\n  /**\n   * @param collection\n   * @param server_\n   */\n  constructor(collection: StatsCollection, private server_: ServerActions) {\n    this.statsListener_ = new StatsListener(collection);\n\n    const timeout =\n      FIRST_STATS_MIN_TIME +\n      (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\n    setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\n  }\n\n  includeStat(stat: string) {\n    this.statsToReport_[stat] = true;\n  }\n\n  private reportStats_() {\n    const stats = this.statsListener_.get();\n    const reportedStats: typeof stats = {};\n    let haveStatsToReport = false;\n\n    forEach(stats, (stat: string, value: number) => {\n      if (value > 0 && contains(this.statsToReport_, stat)) {\n        reportedStats[stat] = value;\n        haveStatsToReport = true;\n      }\n    });\n\n    if (haveStatsToReport) {\n      this.server_.reportStats(reportedStats);\n    }\n\n    // queue our next run.\n    setTimeoutNonBlocking(\n      this.reportStats_.bind(this),\n      Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL)\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}