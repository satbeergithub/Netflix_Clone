{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"../util/util\");\nvar SortedMap_1 = require(\"../util/SortedMap\");\nvar Node_1 = require(\"./Node\");\nvar snap_1 = require(\"./snap\");\nvar PriorityIndex_1 = require(\"./indexes/PriorityIndex\");\nvar KeyIndex_1 = require(\"./indexes/KeyIndex\");\nvar IndexMap_1 = require(\"./IndexMap\");\nvar LeafNode_1 = require(\"./LeafNode\");\nvar comparators_1 = require(\"./comparators\");\n// TODO: For memory savings, don't store priorityNode_ if it's empty.\nvar EMPTY_NODE;\n/**\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\n * (i.e. nodes with children).  It implements Node and stores the\n * list of children in the children property, sorted by child name.\n *\n * @constructor\n * @implements {Node}\n */\nvar ChildrenNode = /** @class */function () {\n  /**\n   *\n   * @param {!SortedMap.<string, !Node>} children_ List of children\n   * of this node..\n   * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).\n   * @param {!IndexMap} indexMap_\n   */\n  function ChildrenNode(children_, priorityNode_, indexMap_) {\n    this.children_ = children_;\n    this.priorityNode_ = priorityNode_;\n    this.indexMap_ = indexMap_;\n    this.lazyHash_ = null;\n    /**\n     * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\n     * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\n     * class instead of an empty ChildrenNode.\n     */\n    if (this.priorityNode_) {\n      snap_1.validatePriorityNode(this.priorityNode_);\n    }\n    if (this.children_.isEmpty()) {\n      util_1.assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');\n    }\n  }\n  Object.defineProperty(ChildrenNode, \"EMPTY_NODE\", {\n    get: function get() {\n      return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode(new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), null, IndexMap_1.IndexMap.Default));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @inheritDoc */\n  ChildrenNode.prototype.isLeafNode = function () {\n    return false;\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.getPriority = function () {\n    return this.priorityNode_ || EMPTY_NODE;\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.updatePriority = function (newPriorityNode) {\n    if (this.children_.isEmpty()) {\n      // Don't allow priorities on empty nodes\n      return this;\n    } else {\n      return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n    }\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.getImmediateChild = function (childName) {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.getPriority();\n    } else {\n      var child = this.children_.get(childName);\n      return child === null ? EMPTY_NODE : child;\n    }\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.getChild = function (path) {\n    var front = path.getFront();\n    if (front === null) return this;\n    return this.getImmediateChild(front).getChild(path.popFront());\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.hasChild = function (childName) {\n    return this.children_.get(childName) !== null;\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.updateImmediateChild = function (childName, newChildNode) {\n    util_1.assert(newChildNode, 'We should always be passing snapshot nodes');\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else {\n      var namedNode = new Node_1.NamedNode(childName, newChildNode);\n      var newChildren = void 0,\n        newIndexMap = void 0,\n        newPriority = void 0;\n      if (newChildNode.isEmpty()) {\n        newChildren = this.children_.remove(childName);\n        newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);\n      } else {\n        newChildren = this.children_.insert(childName, newChildNode);\n        newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n      }\n      newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n      return new ChildrenNode(newChildren, newPriority, newIndexMap);\n    }\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.updateChild = function (path, newChildNode) {\n    var front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else {\n      util_1.assert(path.getFront() !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');\n      var newImmediateChild = this.getImmediateChild(front).updateChild(path.popFront(), newChildNode);\n      return this.updateImmediateChild(front, newImmediateChild);\n    }\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.isEmpty = function () {\n    return this.children_.isEmpty();\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.numChildren = function () {\n    return this.children_.count();\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.val = function (exportFormat) {\n    if (this.isEmpty()) return null;\n    var obj = {};\n    var numKeys = 0,\n      maxKey = 0,\n      allIntegerKeys = true;\n    this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n      obj[key] = childNode.val(exportFormat);\n      numKeys++;\n      if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n        maxKey = Math.max(maxKey, Number(key));\n      } else {\n        allIntegerKeys = false;\n      }\n    });\n    if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n      // convert to array.\n      var array = [];\n      for (var key in obj) {\n        array[key] = obj[key];\n      }\n      return array;\n    } else {\n      if (exportFormat && !this.getPriority().isEmpty()) {\n        obj['.priority'] = this.getPriority().val();\n      }\n      return obj;\n    }\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.hash = function () {\n    if (this.lazyHash_ === null) {\n      var toHash_1 = '';\n      if (!this.getPriority().isEmpty()) toHash_1 += 'priority:' + snap_1.priorityHashText(this.getPriority().val()) + ':';\n      this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n        var childHash = childNode.hash();\n        if (childHash !== '') toHash_1 += ':' + key + ':' + childHash;\n      });\n      this.lazyHash_ = toHash_1 === '' ? '' : util_2.sha1(toHash_1);\n    }\n    return this.lazyHash_;\n  };\n  /** @inheritDoc */\n  ChildrenNode.prototype.getPredecessorChildName = function (childName, childNode, index) {\n    var idx = this.resolveIndex_(index);\n    if (idx) {\n      var predecessor = idx.getPredecessorKey(new Node_1.NamedNode(childName, childNode));\n      return predecessor ? predecessor.name : null;\n    } else {\n      return this.children_.getPredecessorKey(childName);\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  ChildrenNode.prototype.getFirstChildName = function (indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      var minKey = idx.minKey();\n      return minKey && minKey.name;\n    } else {\n      return this.children_.minKey();\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  ChildrenNode.prototype.getFirstChild = function (indexDefinition) {\n    var minKey = this.getFirstChildName(indexDefinition);\n    if (minKey) {\n      return new Node_1.NamedNode(minKey, this.children_.get(minKey));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Given an index, return the key name of the largest value we have, according to that index\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  ChildrenNode.prototype.getLastChildName = function (indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      var maxKey = idx.maxKey();\n      return maxKey && maxKey.name;\n    } else {\n      return this.children_.maxKey();\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  ChildrenNode.prototype.getLastChild = function (indexDefinition) {\n    var maxKey = this.getLastChildName(indexDefinition);\n    if (maxKey) {\n      return new Node_1.NamedNode(maxKey, this.children_.get(maxKey));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  ChildrenNode.prototype.forEachChild = function (index, action) {\n    var idx = this.resolveIndex_(index);\n    if (idx) {\n      return idx.inorderTraversal(function (wrappedNode) {\n        return action(wrappedNode.name, wrappedNode.node);\n      });\n    } else {\n      return this.children_.inorderTraversal(action);\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {SortedMapIterator}\n   */\n  ChildrenNode.prototype.getIterator = function (indexDefinition) {\n    return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n  };\n  /**\n   *\n   * @param {!NamedNode} startPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  ChildrenNode.prototype.getIteratorFrom = function (startPost, indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getIteratorFrom(startPost, function (key) {\n        return key;\n      });\n    } else {\n      var iterator = this.children_.getIteratorFrom(startPost.name, Node_1.NamedNode.Wrap);\n      var next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, startPost) < 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  ChildrenNode.prototype.getReverseIterator = function (indexDefinition) {\n    return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);\n  };\n  /**\n   * @param {!NamedNode} endPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  ChildrenNode.prototype.getReverseIteratorFrom = function (endPost, indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getReverseIteratorFrom(endPost, function (key) {\n        return key;\n      });\n    } else {\n      var iterator = this.children_.getReverseIteratorFrom(endPost.name, Node_1.NamedNode.Wrap);\n      var next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, endPost) > 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  ChildrenNode.prototype.compareTo = function (other) {\n    if (this.isEmpty()) {\n      if (other.isEmpty()) {\n        return 0;\n      } else {\n        return -1;\n      }\n    } else if (other.isLeafNode() || other.isEmpty()) {\n      return 1;\n    } else if (other === exports.MAX_NODE) {\n      return -1;\n    } else {\n      // Must be another node with children.\n      return 0;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  ChildrenNode.prototype.withIndex = function (indexDefinition) {\n    if (indexDefinition === KeyIndex_1.KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {\n      return this;\n    } else {\n      var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);\n      return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  ChildrenNode.prototype.isIndexed = function (index) {\n    return index === KeyIndex_1.KEY_INDEX || this.indexMap_.hasIndex(index);\n  };\n  /**\n   * @inheritDoc\n   */\n  ChildrenNode.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      return false;\n    } else {\n      var otherChildrenNode = other;\n      if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n        return false;\n      } else if (this.children_.count() === otherChildrenNode.children_.count()) {\n        var thisIter = this.getIterator(PriorityIndex_1.PRIORITY_INDEX);\n        var otherIter = otherChildrenNode.getIterator(PriorityIndex_1.PRIORITY_INDEX);\n        var thisCurrent = thisIter.getNext();\n        var otherCurrent = otherIter.getNext();\n        while (thisCurrent && otherCurrent) {\n          if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {\n            return false;\n          }\n          thisCurrent = thisIter.getNext();\n          otherCurrent = otherIter.getNext();\n        }\n        return thisCurrent === null && otherCurrent === null;\n      } else {\n        return false;\n      }\n    }\n  };\n  /**\n   * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\n   * instead.\n   *\n   * @private\n   * @param {!Index} indexDefinition\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n  ChildrenNode.prototype.resolveIndex_ = function (indexDefinition) {\n    if (indexDefinition === KeyIndex_1.KEY_INDEX) {\n      return null;\n    } else {\n      return this.indexMap_.get(indexDefinition.toString());\n    }\n  };\n  /**\n   * @private\n   * @type {RegExp}\n   */\n  ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\n  return ChildrenNode;\n}();\nexports.ChildrenNode = ChildrenNode;\n/**\n * @constructor\n * @extends {ChildrenNode}\n * @private\n */\nvar MaxNode = /** @class */function (_super) {\n  __extends(MaxNode, _super);\n  function MaxNode() {\n    return _super.call(this, new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap_1.IndexMap.Default) || this;\n  }\n  MaxNode.prototype.compareTo = function (other) {\n    if (other === this) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n  MaxNode.prototype.equals = function (other) {\n    // Not that we every compare it, but MAX_NODE is only ever equal to itself\n    return other === this;\n  };\n  MaxNode.prototype.getPriority = function () {\n    return this;\n  };\n  MaxNode.prototype.getImmediateChild = function (childName) {\n    return ChildrenNode.EMPTY_NODE;\n  };\n  MaxNode.prototype.isEmpty = function () {\n    return false;\n  };\n  return MaxNode;\n}(ChildrenNode);\nexports.MaxNode = MaxNode;\n/**\n * Marker that will sort higher than any other snapshot.\n * @type {!MAX_NODE}\n * @const\n */\nexports.MAX_NODE = new MaxNode();\nObject.defineProperties(Node_1.NamedNode, {\n  MIN: {\n    value: new Node_1.NamedNode(util_2.MIN_NAME, ChildrenNode.EMPTY_NODE)\n  },\n  MAX: {\n    value: new Node_1.NamedNode(util_2.MAX_NAME, exports.MAX_NODE)\n  }\n});\n/**\n * Reference Extensions\n */\nKeyIndex_1.KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode_1.LeafNode.__childrenNodeConstructor = ChildrenNode;\nsnap_1.setMaxNode(exports.MAX_NODE);\nPriorityIndex_1.setMaxNode(exports.MAX_NODE);","map":{"version":3,"mappings":"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","names":["EMPTY_NODE","children_","priorityNode_","indexMap_","snap_1","isEmpty","util_1","Object","ChildrenNode","SortedMap_1","comparators_1","IndexMap_1","Default","newPriorityNode","childName","getPriority","child","get","path","front","getFront","getImmediateChild","getChild","popFront","newChildNode","updatePriority","namedNode","Node_1","newChildren","newIndexMap","newPriority","remove","removeFromIndexes","insert","addToIndexes","getLength","newImmediateChild","updateChild","updateImmediateChild","count","exportFormat","obj","numKeys","maxKey","allIntegerKeys","forEachChild","PriorityIndex_1","key","childNode","val","INTEGER_REGEXP_","test","Math","max","Number","array","lazyHash_","toHash_1","childHash","hash","util_2","index","idx","resolveIndex_","predecessor","getPredecessorKey","name","indexDefinition","minKey","getFirstChildName","getLastChildName","action","inorderTraversal","wrappedNode","node","getIteratorFrom","minPost","startPost","iterator","Wrap","next","peek","compare","getNext","getReverseIteratorFrom","maxPost","endPost","other","isLeafNode","exports","KeyIndex_1","hasIndex","addIndex","otherChildrenNode","equals","thisIter","getIterator","otherIter","thisCurrent","otherCurrent","toString","__extends","_super","MaxNode","defineProperties","MIN","value","MAX","__EMPTY_NODE","LeafNode_1","__childrenNodeConstructor"],"sources":["../src/core/snap/ChildrenNode.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { sha1, MAX_NAME, MIN_NAME } from '../util/util';\nimport { SortedMap, SortedMapIterator } from '../util/SortedMap';\nimport { Node, NamedNode } from './Node';\nimport { validatePriorityNode, priorityHashText, setMaxNode } from './snap';\nimport {\n  PRIORITY_INDEX,\n  setMaxNode as setPriorityMaxNode\n} from './indexes/PriorityIndex';\nimport { KEY_INDEX, KeyIndex } from './indexes/KeyIndex';\nimport { IndexMap } from './IndexMap';\nimport { LeafNode } from './LeafNode';\nimport { NAME_COMPARATOR } from './comparators';\nimport { Index } from './indexes/Index';\nimport { Path } from '../util/Path';\n\nexport interface ChildrenNodeConstructor {\n  new (\n    children_: SortedMap<string, Node>,\n    priorityNode_: Node | null,\n    indexMap_: IndexMap\n  ): ChildrenNode;\n  EMPTY_NODE: ChildrenNode;\n}\n\n// TODO: For memory savings, don't store priorityNode_ if it's empty.\n\nlet EMPTY_NODE: ChildrenNode;\n\n/**\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\n * (i.e. nodes with children).  It implements Node and stores the\n * list of children in the children property, sorted by child name.\n *\n * @constructor\n * @implements {Node}\n */\nexport class ChildrenNode implements Node {\n  private lazyHash_: string | null = null;\n\n  static get EMPTY_NODE(): ChildrenNode {\n    return (\n      EMPTY_NODE ||\n      (EMPTY_NODE = new ChildrenNode(\n        new SortedMap<string, Node>(NAME_COMPARATOR),\n        null,\n        IndexMap.Default\n      ))\n    );\n  }\n\n  /**\n   *\n   * @param {!SortedMap.<string, !Node>} children_ List of children\n   * of this node..\n   * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).\n   * @param {!IndexMap} indexMap_\n   */\n  constructor(\n    private readonly children_: SortedMap<string, Node>,\n    private readonly priorityNode_: Node | null,\n    private indexMap_: IndexMap\n  ) {\n    /**\n     * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\n     * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\n     * class instead of an empty ChildrenNode.\n     */\n    if (this.priorityNode_) {\n      validatePriorityNode(this.priorityNode_);\n    }\n\n    if (this.children_.isEmpty()) {\n      assert(\n        !this.priorityNode_ || this.priorityNode_.isEmpty(),\n        'An empty node cannot have a priority'\n      );\n    }\n  }\n\n  /** @inheritDoc */\n  isLeafNode(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  getPriority(): Node {\n    return this.priorityNode_ || EMPTY_NODE;\n  }\n\n  /** @inheritDoc */\n  updatePriority(newPriorityNode: Node): Node {\n    if (this.children_.isEmpty()) {\n      // Don't allow priorities on empty nodes\n      return this;\n    } else {\n      return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n    }\n  }\n\n  /** @inheritDoc */\n  getImmediateChild(childName: string): Node {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.getPriority();\n    } else {\n      const child = this.children_.get(childName);\n      return child === null ? EMPTY_NODE : child;\n    }\n  }\n\n  /** @inheritDoc */\n  getChild(path: Path): Node {\n    const front = path.getFront();\n    if (front === null) return this;\n\n    return this.getImmediateChild(front).getChild(path.popFront());\n  }\n\n  /** @inheritDoc */\n  hasChild(childName: string): boolean {\n    return this.children_.get(childName) !== null;\n  }\n\n  /** @inheritDoc */\n  updateImmediateChild(childName: string, newChildNode: Node): Node {\n    assert(newChildNode, 'We should always be passing snapshot nodes');\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else {\n      const namedNode = new NamedNode(childName, newChildNode);\n      let newChildren, newIndexMap, newPriority;\n      if (newChildNode.isEmpty()) {\n        newChildren = this.children_.remove(childName);\n        newIndexMap = this.indexMap_.removeFromIndexes(\n          namedNode,\n          this.children_\n        );\n      } else {\n        newChildren = this.children_.insert(childName, newChildNode);\n        newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n      }\n\n      newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n      return new ChildrenNode(newChildren, newPriority, newIndexMap);\n    }\n  }\n\n  /** @inheritDoc */\n  updateChild(path: Path, newChildNode: Node): Node {\n    const front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else {\n      assert(\n        path.getFront() !== '.priority' || path.getLength() === 1,\n        '.priority must be the last token in a path'\n      );\n      const newImmediateChild = this.getImmediateChild(front).updateChild(\n        path.popFront(),\n        newChildNode\n      );\n      return this.updateImmediateChild(front, newImmediateChild);\n    }\n  }\n\n  /** @inheritDoc */\n  isEmpty(): boolean {\n    return this.children_.isEmpty();\n  }\n\n  /** @inheritDoc */\n  numChildren(): number {\n    return this.children_.count();\n  }\n\n  /**\n   * @private\n   * @type {RegExp}\n   */\n  private static INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\n\n  /** @inheritDoc */\n  val(exportFormat?: boolean): object {\n    if (this.isEmpty()) return null;\n\n    const obj: { [k: string]: Object } = {};\n    let numKeys = 0,\n      maxKey = 0,\n      allIntegerKeys = true;\n    this.forEachChild(PRIORITY_INDEX, function(key: string, childNode: Node) {\n      obj[key] = childNode.val(exportFormat);\n\n      numKeys++;\n      if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n        maxKey = Math.max(maxKey, Number(key));\n      } else {\n        allIntegerKeys = false;\n      }\n    });\n\n    if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n      // convert to array.\n      const array: Object[] = [];\n      for (let key in obj) array[(key as any) as number] = obj[key];\n\n      return array;\n    } else {\n      if (exportFormat && !this.getPriority().isEmpty()) {\n        obj['.priority'] = this.getPriority().val();\n      }\n      return obj;\n    }\n  }\n\n  /** @inheritDoc */\n  hash(): string {\n    if (this.lazyHash_ === null) {\n      let toHash = '';\n      if (!this.getPriority().isEmpty())\n        toHash +=\n          'priority:' +\n          priorityHashText(this.getPriority().val() as string | number) +\n          ':';\n\n      this.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n        const childHash = childNode.hash();\n        if (childHash !== '') toHash += ':' + key + ':' + childHash;\n      });\n\n      this.lazyHash_ = toHash === '' ? '' : sha1(toHash);\n    }\n    return this.lazyHash_;\n  }\n\n  /** @inheritDoc */\n  getPredecessorChildName(\n    childName: string,\n    childNode: Node,\n    index: Index\n  ): string {\n    const idx = this.resolveIndex_(index);\n    if (idx) {\n      const predecessor = idx.getPredecessorKey(\n        new NamedNode(childName, childNode)\n      );\n      return predecessor ? predecessor.name : null;\n    } else {\n      return this.children_.getPredecessorKey(childName);\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  getFirstChildName(indexDefinition: Index): string | null {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      const minKey = idx.minKey();\n      return minKey && minKey.name;\n    } else {\n      return this.children_.minKey();\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  getFirstChild(indexDefinition: Index): NamedNode | null {\n    const minKey = this.getFirstChildName(indexDefinition);\n    if (minKey) {\n      return new NamedNode(minKey, this.children_.get(minKey));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Given an index, return the key name of the largest value we have, according to that index\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  getLastChildName(indexDefinition: Index): string | null {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      const maxKey = idx.maxKey();\n      return maxKey && maxKey.name;\n    } else {\n      return this.children_.maxKey();\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  getLastChild(indexDefinition: Index): NamedNode | null {\n    const maxKey = this.getLastChildName(indexDefinition);\n    if (maxKey) {\n      return new NamedNode(maxKey, this.children_.get(maxKey));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachChild(index: Index, action: (key: string, node: Node) => void): any {\n    const idx = this.resolveIndex_(index);\n    if (idx) {\n      return idx.inorderTraversal(function(wrappedNode) {\n        return action(wrappedNode.name, wrappedNode.node);\n      });\n    } else {\n      return this.children_.inorderTraversal(action);\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {SortedMapIterator}\n   */\n  getIterator(\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n  }\n\n  /**\n   *\n   * @param {!NamedNode} startPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getIteratorFrom(\n    startPost: NamedNode,\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getIteratorFrom(startPost, key => key);\n    } else {\n      const iterator = this.children_.getIteratorFrom(\n        startPost.name,\n        NamedNode.Wrap\n      );\n      let next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, startPost) < 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getReverseIterator(\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    return this.getReverseIteratorFrom(\n      indexDefinition.maxPost(),\n      indexDefinition\n    );\n  }\n\n  /**\n   * @param {!NamedNode} endPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getReverseIteratorFrom(\n    endPost: NamedNode,\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getReverseIteratorFrom(endPost, function(key) {\n        return key;\n      });\n    } else {\n      const iterator = this.children_.getReverseIteratorFrom(\n        endPost.name,\n        NamedNode.Wrap\n      );\n      let next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, endPost) > 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compareTo(other: ChildrenNode): number {\n    if (this.isEmpty()) {\n      if (other.isEmpty()) {\n        return 0;\n      } else {\n        return -1;\n      }\n    } else if (other.isLeafNode() || other.isEmpty()) {\n      return 1;\n    } else if (other === MAX_NODE) {\n      return -1;\n    } else {\n      // Must be another node with children.\n      return 0;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  withIndex(indexDefinition: Index): Node {\n    if (\n      indexDefinition === KEY_INDEX ||\n      this.indexMap_.hasIndex(indexDefinition)\n    ) {\n      return this;\n    } else {\n      const newIndexMap = this.indexMap_.addIndex(\n        indexDefinition,\n        this.children_\n      );\n      return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isIndexed(index: Index): boolean {\n    return index === KEY_INDEX || this.indexMap_.hasIndex(index);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  equals(other: Node): boolean {\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      return false;\n    } else {\n      const otherChildrenNode = other as ChildrenNode;\n      if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n        return false;\n      } else if (\n        this.children_.count() === otherChildrenNode.children_.count()\n      ) {\n        const thisIter = this.getIterator(PRIORITY_INDEX);\n        const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\n        let thisCurrent = thisIter.getNext();\n        let otherCurrent = otherIter.getNext();\n        while (thisCurrent && otherCurrent) {\n          if (\n            thisCurrent.name !== otherCurrent.name ||\n            !thisCurrent.node.equals(otherCurrent.node)\n          ) {\n            return false;\n          }\n          thisCurrent = thisIter.getNext();\n          otherCurrent = otherIter.getNext();\n        }\n        return thisCurrent === null && otherCurrent === null;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\n   * instead.\n   *\n   * @private\n   * @param {!Index} indexDefinition\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n  private resolveIndex_(\n    indexDefinition: Index\n  ): SortedMap<NamedNode, Node> | null {\n    if (indexDefinition === KEY_INDEX) {\n      return null;\n    } else {\n      return this.indexMap_.get(indexDefinition.toString());\n    }\n  }\n}\n\n/**\n * @constructor\n * @extends {ChildrenNode}\n * @private\n */\nexport class MaxNode extends ChildrenNode {\n  constructor() {\n    super(\n      new SortedMap<string, Node>(NAME_COMPARATOR),\n      ChildrenNode.EMPTY_NODE,\n      IndexMap.Default\n    );\n  }\n\n  compareTo(other: Node): number {\n    if (other === this) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n\n  equals(other: Node): boolean {\n    // Not that we every compare it, but MAX_NODE is only ever equal to itself\n    return other === this;\n  }\n\n  getPriority(): MaxNode {\n    return this;\n  }\n\n  getImmediateChild(childName: string): ChildrenNode {\n    return ChildrenNode.EMPTY_NODE;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n}\n\n/**\n * Marker that will sort higher than any other snapshot.\n * @type {!MAX_NODE}\n * @const\n */\nexport const MAX_NODE = new MaxNode();\n\n/**\n * Document NamedNode extensions\n */\ndeclare module './Node' {\n  interface NamedNode {\n    MIN: NamedNode;\n    MAX: NamedNode;\n  }\n}\n\nObject.defineProperties(NamedNode, {\n  MIN: {\n    value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\n  },\n  MAX: {\n    value: new NamedNode(MAX_NAME, MAX_NODE)\n  }\n});\n\n/**\n * Reference Extensions\n */\nKeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode.__childrenNodeConstructor = ChildrenNode;\nsetMaxNode(MAX_NODE);\nsetPriorityMaxNode(MAX_NODE);\n"]},"metadata":{},"sourceType":"script"}