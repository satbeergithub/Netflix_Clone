{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar Change_1 = require(\"../Change\");\nvar ChildrenNode_1 = require(\"../../snap/ChildrenNode\");\nvar PriorityIndex_1 = require(\"../../snap/indexes/PriorityIndex\");\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\nvar IndexedFilter = /** @class */function () {\n  function IndexedFilter(index_) {\n    this.index_ = index_;\n  }\n  IndexedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n    util_1.assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');\n    var oldChild = snap.getImmediateChild(key);\n    // Check if anything actually changed.\n    if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\n      // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n      // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n      // to avoid treating these cases as \"nothing changed.\"\n      if (oldChild.isEmpty() == newChild.isEmpty()) {\n        // Nothing changed.\n        // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n        //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n        return snap;\n      }\n    }\n    if (optChangeAccumulator != null) {\n      if (newChild.isEmpty()) {\n        if (snap.hasChild(key)) {\n          optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, oldChild));\n        } else {\n          util_1.assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');\n        }\n      } else if (oldChild.isEmpty()) {\n        optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, newChild));\n      } else {\n        optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, newChild, oldChild));\n      }\n    }\n    if (snap.isLeafNode() && newChild.isEmpty()) {\n      return snap;\n    } else {\n      // Make sure the node is indexed\n      return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  IndexedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n    if (optChangeAccumulator != null) {\n      if (!oldSnap.isLeafNode()) {\n        oldSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n          if (!newSnap.hasChild(key)) {\n            optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, childNode));\n          }\n        });\n      }\n      if (!newSnap.isLeafNode()) {\n        newSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n          if (oldSnap.hasChild(key)) {\n            var oldChild = oldSnap.getImmediateChild(key);\n            if (!oldChild.equals(childNode)) {\n              optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, childNode, oldChild));\n            }\n          } else {\n            optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, childNode));\n          }\n        });\n      }\n    }\n    return newSnap.withIndex(this.index_);\n  };\n  /**\n   * @inheritDoc\n   */\n  IndexedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n    if (oldSnap.isEmpty()) {\n      return ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    } else {\n      return oldSnap.updatePriority(newPriority);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  IndexedFilter.prototype.filtersNodes = function () {\n    return false;\n  };\n  /**\n   * @inheritDoc\n   */\n  IndexedFilter.prototype.getIndexedFilter = function () {\n    return this;\n  };\n  /**\n   * @inheritDoc\n   */\n  IndexedFilter.prototype.getIndex = function () {\n    return this.index_;\n  };\n  return IndexedFilter;\n}();\nexports.IndexedFilter = IndexedFilter;","map":{"version":3,"mappings":"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","names":["index_","IndexedFilter","snap","key","newChild","affectedPath","source","optChangeAccumulator","util_1","isIndexed","oldChild","getImmediateChild","getChild","equals","isEmpty","hasChild","trackChildChange","Change_1","childRemovedChange","isLeafNode","childAddedChange","childChangedChange","updateImmediateChild","withIndex","oldSnap","newSnap","forEachChild","PriorityIndex_1","childNode","newPriority","ChildrenNode_1","EMPTY_NODE","updatePriority","exports"],"sources":["../src/core/view/filter/IndexedFilter.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Change } from '../Change';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\nimport { Node } from '../../snap/Node';\n\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\nexport class IndexedFilter implements NodeFilter {\n  constructor(private readonly index_: Index) {}\n\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    assert(\n      snap.isIndexed(this.index_),\n      'A node must be indexed if only a child is updated'\n    );\n    const oldChild = snap.getImmediateChild(key);\n    // Check if anything actually changed.\n    if (\n      oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))\n    ) {\n      // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n      // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n      // to avoid treating these cases as \"nothing changed.\"\n      if (oldChild.isEmpty() == newChild.isEmpty()) {\n        // Nothing changed.\n\n        // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n        //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n        return snap;\n      }\n    }\n\n    if (optChangeAccumulator != null) {\n      if (newChild.isEmpty()) {\n        if (snap.hasChild(key)) {\n          optChangeAccumulator.trackChildChange(\n            Change.childRemovedChange(key, oldChild)\n          );\n        } else {\n          assert(\n            snap.isLeafNode(),\n            'A child remove without an old child only makes sense on a leaf node'\n          );\n        }\n      } else if (oldChild.isEmpty()) {\n        optChangeAccumulator.trackChildChange(\n          Change.childAddedChange(key, newChild)\n        );\n      } else {\n        optChangeAccumulator.trackChildChange(\n          Change.childChangedChange(key, newChild, oldChild)\n        );\n      }\n    }\n    if (snap.isLeafNode() && newChild.isEmpty()) {\n      return snap;\n    } else {\n      // Make sure the node is indexed\n      return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (optChangeAccumulator != null) {\n      if (!oldSnap.isLeafNode()) {\n        oldSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (!newSnap.hasChild(key)) {\n            optChangeAccumulator.trackChildChange(\n              Change.childRemovedChange(key, childNode)\n            );\n          }\n        });\n      }\n      if (!newSnap.isLeafNode()) {\n        newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (oldSnap.hasChild(key)) {\n            const oldChild = oldSnap.getImmediateChild(key);\n            if (!oldChild.equals(childNode)) {\n              optChangeAccumulator.trackChildChange(\n                Change.childChangedChange(key, childNode, oldChild)\n              );\n            }\n          } else {\n            optChangeAccumulator.trackChildChange(\n              Change.childAddedChange(key, childNode)\n            );\n          }\n        });\n      }\n    }\n    return newSnap.withIndex(this.index_);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    if (oldSnap.isEmpty()) {\n      return ChildrenNode.EMPTY_NODE;\n    } else {\n      return oldSnap.updatePriority(newPriority);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}