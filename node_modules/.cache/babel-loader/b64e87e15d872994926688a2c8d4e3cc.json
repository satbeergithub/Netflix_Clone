{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\n/**\n * Fancy ID generator that creates 20-character string identifiers with the\n * following properties:\n *\n * 1. They're based on timestamp so that they sort *after* any existing ids.\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\n *    collide with other clients' IDs.\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\n *    that will sort properly).\n * 4. They're monotonically increasing. Even if you generate more than one in\n *    the same timestamp, the latter ones will sort after the former ones. We do\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\n *    in the case of a timestamp collision).\n */\nexports.nextPushId = function () {\n  // Modeled after base64 web-safe chars, but ordered by ASCII.\n  var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\n  // Timestamp of last push, used to prevent local collisions if you push twice\n  // in one ms.\n  var lastPushTime = 0;\n  // We generate 72-bits of randomness which get turned into 12 characters and\n  // appended to the timestamp to prevent collisions with other clients. We\n  // store the last characters we generated because in the event of a collision,\n  // we'll use those same characters except \"incremented\" by one.\n  var lastRandChars = [];\n  return function (now) {\n    var duplicateTime = now === lastPushTime;\n    lastPushTime = now;\n    var i;\n    var timeStampChars = new Array(8);\n    for (i = 7; i >= 0; i--) {\n      timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n      // NOTE: Can't use << here because javascript will convert to int and lose\n      // the upper bits.\n      now = Math.floor(now / 64);\n    }\n    util_1.assert(now === 0, 'Cannot push at time == 0');\n    var id = timeStampChars.join('');\n    if (!duplicateTime) {\n      for (i = 0; i < 12; i++) {\n        lastRandChars[i] = Math.floor(Math.random() * 64);\n      }\n    } else {\n      // If the timestamp hasn't changed since last push, use the same random\n      // number, except incremented by 1.\n      for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n        lastRandChars[i] = 0;\n      }\n      lastRandChars[i]++;\n    }\n    for (i = 0; i < 12; i++) {\n      id += PUSH_CHARS.charAt(lastRandChars[i]);\n    }\n    util_1.assert(id.length === 20, 'nextPushId: Length should be 20.');\n    return id;\n  };\n}();","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;AAgBA;AAEA;;;;;;;;;;;;;;AAcaA,kBAAU,GAAI;EACzB;EACA,IAAMC,UAAU,GACd,kEAAkE;EAEpE;EACA;EACA,IAAIC,YAAY,GAAG,CAAC;EAEpB;EACA;EACA;EACA;EACA,IAAMC,aAAa,GAAa,EAAE;EAElC,OAAO,UAASC,GAAW;IACzB,IAAMC,aAAa,GAAGD,GAAG,KAAKF,YAAY;IAC1CA,YAAY,GAAGE,GAAG;IAElB,IAAIE,CAAC;IACL,IAAMC,cAAc,GAAG,IAAIC,KAAK,CAAC,CAAC,CAAC;IACnC,KAAKF,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACvBC,cAAc,CAACD,CAAC,CAAC,GAAGL,UAAU,CAACQ,MAAM,CAACL,GAAG,GAAG,EAAE,CAAC;MAC/C;MACA;MACAA,GAAG,GAAGM,IAAI,CAACC,KAAK,CAACP,GAAG,GAAG,EAAE,CAAC;IAC5B;IACAQ,aAAM,CAACR,GAAG,KAAK,CAAC,EAAE,0BAA0B,CAAC;IAE7C,IAAIS,EAAE,GAAGN,cAAc,CAACO,IAAI,CAAC,EAAE,CAAC;IAEhC,IAAI,CAACT,aAAa,EAAE;MAClB,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;QACvBH,aAAa,CAACG,CAAC,CAAC,GAAGI,IAAI,CAACC,KAAK,CAACD,IAAI,CAACK,MAAM,EAAE,GAAG,EAAE,CAAC;MACnD;IACF,CAAC,MAAM;MACL;MACA;MACA,KAAKT,CAAC,GAAG,EAAE,EAAEA,CAAC,IAAI,CAAC,IAAIH,aAAa,CAACG,CAAC,CAAC,KAAK,EAAE,EAAEA,CAAC,EAAE,EAAE;QACnDH,aAAa,CAACG,CAAC,CAAC,GAAG,CAAC;MACtB;MACAH,aAAa,CAACG,CAAC,CAAC,EAAE;IACpB;IACA,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;MACvBO,EAAE,IAAIZ,UAAU,CAACQ,MAAM,CAACN,aAAa,CAACG,CAAC,CAAC,CAAC;IAC3C;IACAM,aAAM,CAACC,EAAE,CAACG,MAAM,KAAK,EAAE,EAAE,kCAAkC,CAAC;IAE5D,OAAOH,EAAE;EACX,CAAC;AACH,CAAC,EAAG","names":["exports","PUSH_CHARS","lastPushTime","lastRandChars","now","duplicateTime","i","timeStampChars","Array","charAt","Math","floor","util_1","id","join","random","length"],"sources":["../src/core/util/NextPushId.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\n\n/**\n * Fancy ID generator that creates 20-character string identifiers with the\n * following properties:\n *\n * 1. They're based on timestamp so that they sort *after* any existing ids.\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\n *    collide with other clients' IDs.\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\n *    that will sort properly).\n * 4. They're monotonically increasing. Even if you generate more than one in\n *    the same timestamp, the latter ones will sort after the former ones. We do\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\n *    in the case of a timestamp collision).\n */\nexport const nextPushId = (function() {\n  // Modeled after base64 web-safe chars, but ordered by ASCII.\n  const PUSH_CHARS =\n    '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\n\n  // Timestamp of last push, used to prevent local collisions if you push twice\n  // in one ms.\n  let lastPushTime = 0;\n\n  // We generate 72-bits of randomness which get turned into 12 characters and\n  // appended to the timestamp to prevent collisions with other clients. We\n  // store the last characters we generated because in the event of a collision,\n  // we'll use those same characters except \"incremented\" by one.\n  const lastRandChars: number[] = [];\n\n  return function(now: number) {\n    const duplicateTime = now === lastPushTime;\n    lastPushTime = now;\n\n    let i;\n    const timeStampChars = new Array(8);\n    for (i = 7; i >= 0; i--) {\n      timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n      // NOTE: Can't use << here because javascript will convert to int and lose\n      // the upper bits.\n      now = Math.floor(now / 64);\n    }\n    assert(now === 0, 'Cannot push at time == 0');\n\n    let id = timeStampChars.join('');\n\n    if (!duplicateTime) {\n      for (i = 0; i < 12; i++) {\n        lastRandChars[i] = Math.floor(Math.random() * 64);\n      }\n    } else {\n      // If the timestamp hasn't changed since last push, use the same random\n      // number, except incremented by 1.\n      for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n        lastRandChars[i] = 0;\n      }\n      lastRandChars[i]++;\n    }\n    for (i = 0; i < 12; i++) {\n      id += PUSH_CHARS.charAt(lastRandChars[i]);\n    }\n    assert(id.length === 20, 'nextPushId: Length should be 20.');\n\n    return id;\n  };\n})();\n"]},"metadata":{},"sourceType":"script"}