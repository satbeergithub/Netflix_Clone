{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar Reference_1 = require(\"../api/Reference\");\nvar DataSnapshot_1 = require(\"../api/DataSnapshot\");\nvar Path_1 = require(\"./util/Path\");\nvar Tree_1 = require(\"./util/Tree\");\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\nvar util_2 = require(\"./util/util\");\nvar ServerValues_1 = require(\"./util/ServerValues\");\nvar validation_1 = require(\"./util/validation\");\nvar util_3 = require(\"@firebase/util\");\nvar nodeFromJSON_1 = require(\"./snap/nodeFromJSON\");\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\nvar Repo_1 = require(\"./Repo\");\n// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific\n// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well\n// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.\n// For now it's part of Repo, but in its own file.\n/**\n * @enum {number}\n */\nvar TransactionStatus;\n(function (TransactionStatus) {\n  // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the\n  // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to\n  // mismatched hash.\n  TransactionStatus[TransactionStatus[\"RUN\"] = 0] = \"RUN\";\n  // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted\n  // or rejected yet).\n  TransactionStatus[TransactionStatus[\"SENT\"] = 1] = \"SENT\";\n  // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be\n  // removed when we get a chance to prune completed ones.\n  TransactionStatus[TransactionStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n  // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).\n  // If it comes back as unsuccessful, we'll abort it.\n  TransactionStatus[TransactionStatus[\"SENT_NEEDS_ABORT\"] = 3] = \"SENT_NEEDS_ABORT\";\n  // Temporary state used to mark transactions that need to be aborted.\n  TransactionStatus[TransactionStatus[\"NEEDS_ABORT\"] = 4] = \"NEEDS_ABORT\";\n})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));\n/**\n * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's\n * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.\n * @type {number}\n * @const\n * @private\n */\nRepo_1.Repo.MAX_TRANSACTION_RETRIES_ = 25;\n/**\n * Setup the transaction data structures\n * @private\n */\nRepo_1.Repo.prototype.transactions_init_ = function () {\n  /**\n   * Stores queues of outstanding transactions for Firebase locations.\n   *\n   * @type {!Tree.<Array.<!Transaction>>}\n   * @private\n   */\n  this.transactionQueueTree_ = new Tree_1.Tree();\n};\n/**\n * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.\n *\n * @param {!Path} path Path at which to do transaction.\n * @param {function(*):*} transactionUpdate Update callback.\n * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.\n * @param {boolean} applyLocally Whether or not to make intermediate results visible\n */\nRepo_1.Repo.prototype.startTransaction = function (path, transactionUpdate, onComplete, applyLocally) {\n  this.log_('transaction on ' + path);\n  // Add a watch to make sure we get server updates.\n  var valueCallback = function () {};\n  var watchRef = new Reference_1.Reference(this, path);\n  watchRef.on('value', valueCallback);\n  var unwatcher = function () {\n    watchRef.off('value', valueCallback);\n  };\n  // Initialize transaction.\n  var transaction = {\n    path: path,\n    update: transactionUpdate,\n    onComplete: onComplete,\n    // One of TransactionStatus enums.\n    status: null,\n    // Used when combining transactions at different locations to figure out which one goes first.\n    order: util_2.LUIDGenerator(),\n    // Whether to raise local events for this transaction.\n    applyLocally: applyLocally,\n    // Count of how many times we've retried the transaction.\n    retryCount: 0,\n    // Function to call to clean up our .on() listener.\n    unwatcher: unwatcher,\n    // Stores why a transaction was aborted.\n    abortReason: null,\n    currentWriteId: null,\n    currentInputSnapshot: null,\n    currentOutputSnapshotRaw: null,\n    currentOutputSnapshotResolved: null\n  };\n  // Run transaction initially.\n  var currentState = this.getLatestState_(path);\n  transaction.currentInputSnapshot = currentState;\n  var newVal = transaction.update(currentState.val());\n  if (newVal === undefined) {\n    // Abort transaction.\n    transaction.unwatcher();\n    transaction.currentOutputSnapshotRaw = null;\n    transaction.currentOutputSnapshotResolved = null;\n    if (transaction.onComplete) {\n      // We just set the input snapshot, so this cast should be safe\n      var snapshot = new DataSnapshot_1.DataSnapshot(transaction.currentInputSnapshot, new Reference_1.Reference(this, transaction.path), PriorityIndex_1.PRIORITY_INDEX);\n      transaction.onComplete(null, false, snapshot);\n    }\n  } else {\n    validation_1.validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path);\n    // Mark as run and add to our queue.\n    transaction.status = TransactionStatus.RUN;\n    var queueNode = this.transactionQueueTree_.subTree(path);\n    var nodeQueue = queueNode.getValue() || [];\n    nodeQueue.push(transaction);\n    queueNode.setValue(nodeQueue);\n    // Update visibleData and raise events\n    // Note: We intentionally raise events after updating all of our transaction state, since the user could\n    // start new transactions from the event callbacks.\n    var priorityForNode = void 0;\n    if (typeof newVal === 'object' && newVal !== null && util_3.contains(newVal, '.priority')) {\n      priorityForNode = util_3.safeGet(newVal, '.priority');\n      util_1.assert(validation_1.isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' + 'Priority must be a valid string, finite number, server value, or null.');\n    } else {\n      var currentNode = this.serverSyncTree_.calcCompleteEventCache(path) || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n      priorityForNode = currentNode.getPriority().val();\n    }\n    priorityForNode /** @type {null|number|string} */ = priorityForNode;\n    var serverValues = this.generateServerValues();\n    var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, priorityForNode);\n    var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n    transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n    transaction.currentOutputSnapshotResolved = newNode;\n    transaction.currentWriteId = this.getNextWriteId_();\n    var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, transaction.currentWriteId, transaction.applyLocally);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    this.sendReadyTransactions_();\n  }\n};\n/**\n * @param {!Path} path\n * @param {Array.<number>=} excludeSets A specific set to exclude\n * @return {Node}\n * @private\n */\nRepo_1.Repo.prototype.getLatestState_ = function (path, excludeSets) {\n  return this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n};\n/**\n * Sends any already-run transactions that aren't waiting for outstanding transactions to\n * complete.\n *\n * Externally it's called with no arguments, but it calls itself recursively with a particular\n * transactionQueueTree node to recurse through the tree.\n *\n * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.\n * @private\n */\nRepo_1.Repo.prototype.sendReadyTransactions_ = function (node) {\n  var _this = this;\n  if (node === void 0) {\n    node = this.transactionQueueTree_;\n  }\n  // Before recursing, make sure any completed transactions are removed.\n  if (!node) {\n    this.pruneCompletedTransactionsBelowNode_(node);\n  }\n  if (node.getValue() !== null) {\n    var queue = this.buildTransactionQueue_(node);\n    util_1.assert(queue.length > 0, 'Sending zero length transaction queue');\n    var allRun = queue.every(function (transaction) {\n      return transaction.status === TransactionStatus.RUN;\n    });\n    // If they're all run (and not sent), we can send them.  Else, we must wait.\n    if (allRun) {\n      this.sendTransactionQueue_(node.path(), queue);\n    }\n  } else if (node.hasChildren()) {\n    node.forEachChild(function (childNode) {\n      _this.sendReadyTransactions_(childNode);\n    });\n  }\n};\n/**\n * Given a list of run transactions, send them to the server and then handle the result (success or failure).\n *\n * @param {!Path} path The location of the queue.\n * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.\n * @private\n */\nRepo_1.Repo.prototype.sendTransactionQueue_ = function (path, queue) {\n  var _this = this;\n  // Mark transactions as sent and increment retry count!\n  var setsToIgnore = queue.map(function (txn) {\n    return txn.currentWriteId;\n  });\n  var latestState = this.getLatestState_(path, setsToIgnore);\n  var snapToSend = latestState;\n  var latestHash = latestState.hash();\n  for (var i = 0; i < queue.length; i++) {\n    var txn = queue[i];\n    util_1.assert(txn.status === TransactionStatus.RUN, 'tryToSendTransactionQueue_: items in queue should all be run.');\n    txn.status = TransactionStatus.SENT;\n    txn.retryCount++;\n    var relativePath = Path_1.Path.relativePath(path, txn.path);\n    // If we've gotten to this point, the output snapshot must be defined.\n    snapToSend = snapToSend.updateChild(relativePath /**@type {!Node} */, txn.currentOutputSnapshotRaw);\n  }\n  var dataToSend = snapToSend.val(true);\n  var pathToSend = path;\n  // Send the put.\n  this.server_.put(pathToSend.toString(), dataToSend, function (status) {\n    _this.log_('transaction put response', {\n      path: pathToSend.toString(),\n      status: status\n    });\n    var events = [];\n    if (status === 'ok') {\n      // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n      // the callback could trigger more transactions or sets.\n      var callbacks = [];\n      for (var i = 0; i < queue.length; i++) {\n        queue[i].status = TransactionStatus.COMPLETED;\n        events = events.concat(_this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId));\n        if (queue[i].onComplete) {\n          // We never unset the output snapshot, and given that this transaction is complete, it should be set\n          var node = queue[i].currentOutputSnapshotResolved;\n          var ref = new Reference_1.Reference(_this, queue[i].path);\n          var snapshot = new DataSnapshot_1.DataSnapshot(node, ref, PriorityIndex_1.PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, true, snapshot));\n        }\n        queue[i].unwatcher();\n      }\n      // Now remove the completed transactions.\n      _this.pruneCompletedTransactionsBelowNode_(_this.transactionQueueTree_.subTree(path));\n      // There may be pending transactions that we can now send.\n      _this.sendReadyTransactions_();\n      _this.eventQueue_.raiseEventsForChangedPath(path, events);\n      // Finally, trigger onComplete callbacks.\n      for (var i = 0; i < callbacks.length; i++) {\n        util_2.exceptionGuard(callbacks[i]);\n      }\n    } else {\n      // transactions are no longer sent.  Update their status appropriately.\n      if (status === 'datastale') {\n        for (var i = 0; i < queue.length; i++) {\n          if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) queue[i].status = TransactionStatus.NEEDS_ABORT;else queue[i].status = TransactionStatus.RUN;\n        }\n      } else {\n        util_2.warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);\n        for (var i = 0; i < queue.length; i++) {\n          queue[i].status = TransactionStatus.NEEDS_ABORT;\n          queue[i].abortReason = status;\n        }\n      }\n      _this.rerunTransactions_(path);\n    }\n  }, latestHash);\n};\n/**\n * Finds all transactions dependent on the data at changedPath and reruns them.\n *\n * Should be called any time cached data changes.\n *\n * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to\n * be raised for.\n *\n * @param {!Path} changedPath The path in mergedData that changed.\n * @return {!Path} The rootmost path that was affected by rerunning transactions.\n * @private\n */\nRepo_1.Repo.prototype.rerunTransactions_ = function (changedPath) {\n  var rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);\n  var path = rootMostTransactionNode.path();\n  var queue = this.buildTransactionQueue_(rootMostTransactionNode);\n  this.rerunTransactionQueue_(queue, path);\n  return path;\n};\n/**\n * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).\n *\n * @param {Array.<Transaction>} queue The queue of transactions to run.\n * @param {!Path} path The path the queue is for.\n * @private\n */\nRepo_1.Repo.prototype.rerunTransactionQueue_ = function (queue, path) {\n  if (queue.length === 0) {\n    return; // Nothing to do!\n  }\n  // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n  // the callback could trigger more transactions or sets.\n  var callbacks = [];\n  var events = [];\n  // Ignore all of the sets we're going to re-run.\n  var txnsToRerun = queue.filter(function (q) {\n    return q.status === TransactionStatus.RUN;\n  });\n  var setsToIgnore = txnsToRerun.map(function (q) {\n    return q.currentWriteId;\n  });\n  for (var i = 0; i < queue.length; i++) {\n    var transaction = queue[i];\n    var relativePath = Path_1.Path.relativePath(path, transaction.path);\n    var abortTransaction = false,\n      abortReason = void 0;\n    util_1.assert(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');\n    if (transaction.status === TransactionStatus.NEEDS_ABORT) {\n      abortTransaction = true;\n      abortReason = transaction.abortReason;\n      events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n    } else if (transaction.status === TransactionStatus.RUN) {\n      if (transaction.retryCount >= Repo_1.Repo.MAX_TRANSACTION_RETRIES_) {\n        abortTransaction = true;\n        abortReason = 'maxretry';\n        events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n      } else {\n        // This code reruns a transaction\n        var currentNode = this.getLatestState_(transaction.path, setsToIgnore);\n        transaction.currentInputSnapshot = currentNode;\n        var newData = queue[i].update(currentNode.val());\n        if (newData !== undefined) {\n          validation_1.validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);\n          var newDataNode = nodeFromJSON_1.nodeFromJSON(newData);\n          var hasExplicitPriority = typeof newData === 'object' && newData != null && util_3.contains(newData, '.priority');\n          if (!hasExplicitPriority) {\n            // Keep the old priority if there wasn't a priority explicitly specified.\n            newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n          }\n          var oldWriteId = transaction.currentWriteId;\n          var serverValues = this.generateServerValues();\n          var newNodeResolved = ServerValues_1.resolveDeferredValueSnapshot(newDataNode, serverValues);\n          transaction.currentOutputSnapshotRaw = newDataNode;\n          transaction.currentOutputSnapshotResolved = newNodeResolved;\n          transaction.currentWriteId = this.getNextWriteId_();\n          // Mutates setsToIgnore in place\n          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n          events = events.concat(this.serverSyncTree_.applyUserOverwrite(transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));\n          events = events.concat(this.serverSyncTree_.ackUserWrite(oldWriteId, true));\n        } else {\n          abortTransaction = true;\n          abortReason = 'nodata';\n          events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n        }\n      }\n    }\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    events = [];\n    if (abortTransaction) {\n      // Abort.\n      queue[i].status = TransactionStatus.COMPLETED;\n      // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).\n      // So defer the unwatcher until we're done.\n      (function (unwatcher) {\n        setTimeout(unwatcher, Math.floor(0));\n      })(queue[i].unwatcher);\n      if (queue[i].onComplete) {\n        if (abortReason === 'nodata') {\n          var ref = new Reference_1.Reference(this, queue[i].path);\n          // We set this field immediately, so it's safe to cast to an actual snapshot\n          var lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;\n          var snapshot = new DataSnapshot_1.DataSnapshot(lastInput, ref, PriorityIndex_1.PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));\n        } else {\n          callbacks.push(queue[i].onComplete.bind(null, new Error(abortReason), false, null));\n        }\n      }\n    }\n  }\n  // Clean up completed transactions.\n  this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);\n  // Now fire callbacks, now that we're in a good, known state.\n  for (var i = 0; i < callbacks.length; i++) {\n    util_2.exceptionGuard(callbacks[i]);\n  }\n  // Try to send the transaction result to the server.\n  this.sendReadyTransactions_();\n};\n/**\n * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns\n * the node for the given path if there are no pending transactions on any ancestor.\n *\n * @param {!Path} path The location to start at.\n * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.\n * @private\n */\nRepo_1.Repo.prototype.getAncestorTransactionNode_ = function (path) {\n  var front;\n  // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.\n  var transactionNode = this.transactionQueueTree_;\n  while ((front = path.getFront()) !== null && transactionNode.getValue() === null) {\n    transactionNode = transactionNode.subTree(front);\n    path = path.popFront();\n  }\n  return transactionNode;\n};\n/**\n * Builds the queue of all transactions at or below the specified transactionNode.\n *\n * @param {!Tree.<Array.<Transaction>>} transactionNode\n * @return {Array.<Transaction>} The generated queue.\n * @private\n */\nRepo_1.Repo.prototype.buildTransactionQueue_ = function (transactionNode) {\n  // Walk any child transaction queues and aggregate them into a single queue.\n  var transactionQueue = [];\n  this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);\n  // Sort them by the order the transactions were created.\n  transactionQueue.sort(function (a, b) {\n    return a.order - b.order;\n  });\n  return transactionQueue;\n};\n/**\n * @param {!Tree.<Array.<Transaction>>} node\n * @param {Array.<Transaction>} queue\n * @private\n */\nRepo_1.Repo.prototype.aggregateTransactionQueuesForNode_ = function (node, queue) {\n  var _this = this;\n  var nodeQueue = node.getValue();\n  if (nodeQueue !== null) {\n    for (var i = 0; i < nodeQueue.length; i++) {\n      queue.push(nodeQueue[i]);\n    }\n  }\n  node.forEachChild(function (child) {\n    _this.aggregateTransactionQueuesForNode_(child, queue);\n  });\n};\n/**\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\n *\n * @param {!Tree.<Array.<!Transaction>>} node\n * @private\n */\nRepo_1.Repo.prototype.pruneCompletedTransactionsBelowNode_ = function (node) {\n  var _this = this;\n  var queue = node.getValue();\n  if (queue) {\n    var to = 0;\n    for (var from = 0; from < queue.length; from++) {\n      if (queue[from].status !== TransactionStatus.COMPLETED) {\n        queue[to] = queue[from];\n        to++;\n      }\n    }\n    queue.length = to;\n    node.setValue(queue.length > 0 ? queue : null);\n  }\n  node.forEachChild(function (childNode) {\n    _this.pruneCompletedTransactionsBelowNode_(childNode);\n  });\n};\n/**\n * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()\n * since we consider them incompatible with transactions.\n *\n * @param {!Path} path Path for which we want to abort related transactions.\n * @return {!Path}\n * @private\n */\nRepo_1.Repo.prototype.abortTransactions_ = function (path) {\n  var _this = this;\n  var affectedPath = this.getAncestorTransactionNode_(path).path();\n  var transactionNode = this.transactionQueueTree_.subTree(path);\n  transactionNode.forEachAncestor(function (node) {\n    _this.abortTransactionsOnNode_(node);\n  });\n  this.abortTransactionsOnNode_(transactionNode);\n  transactionNode.forEachDescendant(function (node) {\n    _this.abortTransactionsOnNode_(node);\n  });\n  return affectedPath;\n};\n/**\n * Abort transactions stored in this transaction queue node.\n *\n * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.\n * @private\n */\nRepo_1.Repo.prototype.abortTransactionsOnNode_ = function (node) {\n  var queue = node.getValue();\n  if (queue !== null) {\n    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n    // the callback could trigger more transactions or sets.\n    var callbacks = [];\n    // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones\n    // can be immediately aborted and removed.\n    var events = [];\n    var lastSent = -1;\n    for (var i = 0; i < queue.length; i++) {\n      if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {\n        // Already marked.  No action needed.\n      } else if (queue[i].status === TransactionStatus.SENT) {\n        util_1.assert(lastSent === i - 1, 'All SENT items should be at beginning of queue.');\n        lastSent = i;\n        // Mark transaction for abort when it comes back.\n        queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;\n        queue[i].abortReason = 'set';\n      } else {\n        util_1.assert(queue[i].status === TransactionStatus.RUN, 'Unexpected transaction status in abort');\n        // We can abort it immediately.\n        queue[i].unwatcher();\n        events = events.concat(this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true));\n        if (queue[i].onComplete) {\n          var snapshot = null;\n          callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, snapshot));\n        }\n      }\n    }\n    if (lastSent === -1) {\n      // We're not waiting for any sent transactions.  We can clear the queue.\n      node.setValue(null);\n    } else {\n      // Remove the transactions we aborted.\n      queue.length = lastSent + 1;\n    }\n    // Now fire the callbacks.\n    this.eventQueue_.raiseEventsForChangedPath(node.path(), events);\n    for (var i = 0; i < callbacks.length; i++) {\n      util_2.exceptionGuard(callbacks[i]);\n    }\n  }\n};","map":{"version":3,"mappings":"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","names":["TransactionStatus","exports","Repo_1","MAX_TRANSACTION_RETRIES_","prototype","transactions_init_","transactionQueueTree_","Tree_1","startTransaction","path","transactionUpdate","onComplete","applyLocally","log_","valueCallback","watchRef","Reference_1","on","unwatcher","off","transaction","update","status","order","util_2","retryCount","abortReason","currentWriteId","currentInputSnapshot","currentOutputSnapshotRaw","currentOutputSnapshotResolved","currentState","getLatestState_","newVal","val","undefined","snapshot","DataSnapshot_1","PriorityIndex_1","validation_1","RUN","queueNode","subTree","nodeQueue","getValue","push","setValue","priorityForNode","util_3","util_1","currentNode","serverSyncTree_","calcCompleteEventCache","ChildrenNode_1","EMPTY_NODE","getPriority","serverValues","generateServerValues","newNodeUnresolved","nodeFromJSON_1","newNode","ServerValues_1","getNextWriteId_","events","applyUserOverwrite","eventQueue_","raiseEventsForChangedPath","sendReadyTransactions_","excludeSets","node","pruneCompletedTransactionsBelowNode_","queue","buildTransactionQueue_","length","allRun","every","sendTransactionQueue_","hasChildren","forEachChild","_this","childNode","setsToIgnore","map","txn","latestState","snapToSend","latestHash","hash","i","SENT","relativePath","Path_1","updateChild","dataToSend","pathToSend","server_","put","toString","callbacks","COMPLETED","concat","ackUserWrite","ref","bind","SENT_NEEDS_ABORT","NEEDS_ABORT","rerunTransactions_","changedPath","rootMostTransactionNode","getAncestorTransactionNode_","rerunTransactionQueue_","txnsToRerun","filter","q","abortTransaction","newData","newDataNode","hasExplicitPriority","updatePriority","oldWriteId","newNodeResolved","splice","indexOf","setTimeout","Math","floor","lastInput","Error","front","transactionNode","getFront","popFront","transactionQueue","aggregateTransactionQueuesForNode_","sort","a","b","child","to","from","abortTransactions_","affectedPath","forEachAncestor","abortTransactionsOnNode_","forEachDescendant","lastSent"],"sources":["../src/core/Repo_transaction.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Reference } from '../api/Reference';\nimport { DataSnapshot } from '../api/DataSnapshot';\nimport { Path } from './util/Path';\nimport { Tree } from './util/Tree';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { Node } from './snap/Node';\nimport { LUIDGenerator, warn, exceptionGuard } from './util/util';\nimport { resolveDeferredValueSnapshot } from './util/ServerValues';\nimport { isValidPriority, validateFirebaseData } from './util/validation';\nimport { contains, safeGet } from '@firebase/util';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { Repo } from './Repo';\nimport { Event } from './view/Event';\n\n// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific\n// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well\n// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.\n// For now it's part of Repo, but in its own file.\n\n/**\n * @enum {number}\n */\nexport enum TransactionStatus {\n  // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the\n  // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to\n  // mismatched hash.\n  RUN,\n\n  // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted\n  // or rejected yet).\n  SENT,\n\n  // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be\n  // removed when we get a chance to prune completed ones.\n  COMPLETED,\n\n  // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).\n  // If it comes back as unsuccessful, we'll abort it.\n  SENT_NEEDS_ABORT,\n\n  // Temporary state used to mark transactions that need to be aborted.\n  NEEDS_ABORT\n}\n\n/**\n * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's\n * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.\n * @type {number}\n * @const\n * @private\n */\n(Repo as any).MAX_TRANSACTION_RETRIES_ = 25;\n\n/**\n * @typedef {{\n *   path: !Path,\n *   update: function(*):*,\n *   onComplete: ?function(?Error, boolean, ?DataSnapshot),\n *   status: ?TransactionStatus,\n *   order: !number,\n *   applyLocally: boolean,\n *   retryCount: !number,\n *   unwatcher: function(),\n *   abortReason: ?string,\n *   currentWriteId: !number,\n *   currentInputSnapshot: ?Node,\n *   currentOutputSnapshotRaw: ?Node,\n *   currentOutputSnapshotResolved: ?Node\n * }}\n */\ntype Transaction = {\n  path: Path;\n  update: (a: any) => any;\n  onComplete: (a: Error | null, b: boolean, c: DataSnapshot | null) => void;\n  status: TransactionStatus;\n  order: number;\n  applyLocally: boolean;\n  retryCount: number;\n  unwatcher: () => void;\n  abortReason: string | null;\n  currentWriteId: number;\n  currentInputSnapshot: Node | null;\n  currentOutputSnapshotRaw: Node | null;\n  currentOutputSnapshotResolved: Node | null;\n};\n\n/**\n * Setup the transaction data structures\n * @private\n */\n(Repo.prototype as any).transactions_init_ = function() {\n  /**\n   * Stores queues of outstanding transactions for Firebase locations.\n   *\n   * @type {!Tree.<Array.<!Transaction>>}\n   * @private\n   */\n  this.transactionQueueTree_ = new Tree<Transaction[]>();\n};\n\ndeclare module './Repo' {\n  interface Repo {\n    startTransaction(\n      path: Path,\n      transactionUpdate: (a: any) => void,\n      onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n      applyLocally: boolean\n    ): void;\n  }\n}\n\n/**\n * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.\n *\n * @param {!Path} path Path at which to do transaction.\n * @param {function(*):*} transactionUpdate Update callback.\n * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.\n * @param {boolean} applyLocally Whether or not to make intermediate results visible\n */\nRepo.prototype.startTransaction = function(\n  path: Path,\n  transactionUpdate: (a: any) => any,\n  onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n  applyLocally: boolean\n) {\n  this.log_('transaction on ' + path);\n\n  // Add a watch to make sure we get server updates.\n  const valueCallback = function() {};\n  const watchRef = new Reference(this, path);\n  watchRef.on('value', valueCallback);\n  const unwatcher = function() {\n    watchRef.off('value', valueCallback);\n  };\n\n  // Initialize transaction.\n  const transaction: Transaction = {\n    path,\n    update: transactionUpdate,\n    onComplete,\n\n    // One of TransactionStatus enums.\n    status: null,\n\n    // Used when combining transactions at different locations to figure out which one goes first.\n    order: LUIDGenerator(),\n\n    // Whether to raise local events for this transaction.\n    applyLocally: applyLocally,\n\n    // Count of how many times we've retried the transaction.\n    retryCount: 0,\n\n    // Function to call to clean up our .on() listener.\n    unwatcher,\n\n    // Stores why a transaction was aborted.\n    abortReason: null,\n\n    currentWriteId: null,\n\n    currentInputSnapshot: null,\n\n    currentOutputSnapshotRaw: null,\n\n    currentOutputSnapshotResolved: null\n  };\n\n  // Run transaction initially.\n  const currentState = this.getLatestState_(path);\n  transaction.currentInputSnapshot = currentState;\n  const newVal = transaction.update(currentState.val());\n  if (newVal === undefined) {\n    // Abort transaction.\n    transaction.unwatcher();\n    transaction.currentOutputSnapshotRaw = null;\n    transaction.currentOutputSnapshotResolved = null;\n    if (transaction.onComplete) {\n      // We just set the input snapshot, so this cast should be safe\n      const snapshot = new DataSnapshot(\n        transaction.currentInputSnapshot,\n        new Reference(this, transaction.path),\n        PRIORITY_INDEX\n      );\n      transaction.onComplete(null, false, snapshot);\n    }\n  } else {\n    validateFirebaseData(\n      'transaction failed: Data returned ',\n      newVal,\n      transaction.path\n    );\n\n    // Mark as run and add to our queue.\n    transaction.status = TransactionStatus.RUN;\n    const queueNode = this.transactionQueueTree_.subTree(path);\n    const nodeQueue = queueNode.getValue() || [];\n    nodeQueue.push(transaction);\n\n    queueNode.setValue(nodeQueue);\n\n    // Update visibleData and raise events\n    // Note: We intentionally raise events after updating all of our transaction state, since the user could\n    // start new transactions from the event callbacks.\n    let priorityForNode;\n    if (\n      typeof newVal === 'object' &&\n      newVal !== null &&\n      contains(newVal, '.priority')\n    ) {\n      priorityForNode = safeGet(newVal, '.priority');\n      assert(\n        isValidPriority(priorityForNode),\n        'Invalid priority returned by transaction. ' +\n          'Priority must be a valid string, finite number, server value, or null.'\n      );\n    } else {\n      const currentNode =\n        this.serverSyncTree_.calcCompleteEventCache(path) ||\n        ChildrenNode.EMPTY_NODE;\n      priorityForNode = currentNode.getPriority().val();\n    }\n    priorityForNode /** @type {null|number|string} */ = priorityForNode;\n\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);\n    const newNode = resolveDeferredValueSnapshot(\n      newNodeUnresolved,\n      serverValues\n    );\n    transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n    transaction.currentOutputSnapshotResolved = newNode;\n    transaction.currentWriteId = this.getNextWriteId_();\n\n    const events = this.serverSyncTree_.applyUserOverwrite(\n      path,\n      newNode,\n      transaction.currentWriteId,\n      transaction.applyLocally\n    );\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n    this.sendReadyTransactions_();\n  }\n};\n\n/**\n * @param {!Path} path\n * @param {Array.<number>=} excludeSets A specific set to exclude\n * @return {Node}\n * @private\n */\n(Repo.prototype as any).getLatestState_ = function(\n  path: Path,\n  excludeSets?: number[]\n): Node {\n  return (\n    this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) ||\n    ChildrenNode.EMPTY_NODE\n  );\n};\n\n/**\n * Sends any already-run transactions that aren't waiting for outstanding transactions to\n * complete.\n *\n * Externally it's called with no arguments, but it calls itself recursively with a particular\n * transactionQueueTree node to recurse through the tree.\n *\n * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.\n * @private\n */\n(Repo.prototype as any).sendReadyTransactions_ = function(\n  node: Tree<Transaction[]> = this.transactionQueueTree_\n) {\n  // Before recursing, make sure any completed transactions are removed.\n  if (!node) {\n    this.pruneCompletedTransactionsBelowNode_(node);\n  }\n\n  if (node.getValue() !== null) {\n    const queue = this.buildTransactionQueue_(node);\n    assert(queue.length > 0, 'Sending zero length transaction queue');\n\n    const allRun = queue.every(\n      (transaction: Transaction) => transaction.status === TransactionStatus.RUN\n    );\n\n    // If they're all run (and not sent), we can send them.  Else, we must wait.\n    if (allRun) {\n      this.sendTransactionQueue_(node.path(), queue);\n    }\n  } else if (node.hasChildren()) {\n    node.forEachChild(childNode => {\n      this.sendReadyTransactions_(childNode);\n    });\n  }\n};\n\n/**\n * Given a list of run transactions, send them to the server and then handle the result (success or failure).\n *\n * @param {!Path} path The location of the queue.\n * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.\n * @private\n */\n(Repo.prototype as any).sendTransactionQueue_ = function(\n  path: Path,\n  queue: Array<Transaction>\n) {\n  // Mark transactions as sent and increment retry count!\n  const setsToIgnore = queue.map(function(txn) {\n    return txn.currentWriteId;\n  });\n  const latestState = this.getLatestState_(path, setsToIgnore);\n  let snapToSend = latestState;\n  const latestHash = latestState.hash();\n  for (let i = 0; i < queue.length; i++) {\n    const txn = queue[i];\n    assert(\n      txn.status === TransactionStatus.RUN,\n      'tryToSendTransactionQueue_: items in queue should all be run.'\n    );\n    txn.status = TransactionStatus.SENT;\n    txn.retryCount++;\n    const relativePath = Path.relativePath(path, txn.path);\n    // If we've gotten to this point, the output snapshot must be defined.\n    snapToSend = snapToSend.updateChild(\n      relativePath /**@type {!Node} */,\n      txn.currentOutputSnapshotRaw\n    );\n  }\n\n  const dataToSend = snapToSend.val(true);\n  const pathToSend = path;\n\n  // Send the put.\n  this.server_.put(\n    pathToSend.toString(),\n    dataToSend,\n    (status: string) => {\n      this.log_('transaction put response', {\n        path: pathToSend.toString(),\n        status\n      });\n\n      let events: Event[] = [];\n      if (status === 'ok') {\n        // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n        // the callback could trigger more transactions or sets.\n        const callbacks = [];\n        for (let i = 0; i < queue.length; i++) {\n          queue[i].status = TransactionStatus.COMPLETED;\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId)\n          );\n          if (queue[i].onComplete) {\n            // We never unset the output snapshot, and given that this transaction is complete, it should be set\n            const node = queue[i].currentOutputSnapshotResolved as Node;\n            const ref = new Reference(this, queue[i].path);\n            const snapshot = new DataSnapshot(node, ref, PRIORITY_INDEX);\n            callbacks.push(\n              queue[i].onComplete.bind(null, null, true, snapshot)\n            );\n          }\n          queue[i].unwatcher();\n        }\n\n        // Now remove the completed transactions.\n        this.pruneCompletedTransactionsBelowNode_(\n          this.transactionQueueTree_.subTree(path)\n        );\n        // There may be pending transactions that we can now send.\n        this.sendReadyTransactions_();\n\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n        // Finally, trigger onComplete callbacks.\n        for (let i = 0; i < callbacks.length; i++) {\n          exceptionGuard(callbacks[i]);\n        }\n      } else {\n        // transactions are no longer sent.  Update their status appropriately.\n        if (status === 'datastale') {\n          for (let i = 0; i < queue.length; i++) {\n            if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT)\n              queue[i].status = TransactionStatus.NEEDS_ABORT;\n            else queue[i].status = TransactionStatus.RUN;\n          }\n        } else {\n          warn(\n            'transaction at ' + pathToSend.toString() + ' failed: ' + status\n          );\n          for (let i = 0; i < queue.length; i++) {\n            queue[i].status = TransactionStatus.NEEDS_ABORT;\n            queue[i].abortReason = status;\n          }\n        }\n\n        this.rerunTransactions_(path);\n      }\n    },\n    latestHash\n  );\n};\n\n/**\n * Finds all transactions dependent on the data at changedPath and reruns them.\n *\n * Should be called any time cached data changes.\n *\n * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to\n * be raised for.\n *\n * @param {!Path} changedPath The path in mergedData that changed.\n * @return {!Path} The rootmost path that was affected by rerunning transactions.\n * @private\n */\n(Repo.prototype as any).rerunTransactions_ = function(changedPath: Path): Path {\n  const rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);\n  const path = rootMostTransactionNode.path();\n\n  const queue = this.buildTransactionQueue_(rootMostTransactionNode);\n  this.rerunTransactionQueue_(queue, path);\n\n  return path;\n};\n\n/**\n * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).\n *\n * @param {Array.<Transaction>} queue The queue of transactions to run.\n * @param {!Path} path The path the queue is for.\n * @private\n */\n(Repo.prototype as any).rerunTransactionQueue_ = function(\n  queue: Array<Transaction>,\n  path: Path\n) {\n  if (queue.length === 0) {\n    return; // Nothing to do!\n  }\n\n  // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n  // the callback could trigger more transactions or sets.\n  const callbacks = [];\n  let events: Event[] = [];\n  // Ignore all of the sets we're going to re-run.\n  const txnsToRerun = queue.filter(function(q) {\n    return q.status === TransactionStatus.RUN;\n  });\n  const setsToIgnore = txnsToRerun.map(function(q) {\n    return q.currentWriteId;\n  });\n  for (let i = 0; i < queue.length; i++) {\n    const transaction = queue[i];\n    const relativePath = Path.relativePath(path, transaction.path);\n    let abortTransaction = false,\n      abortReason;\n    assert(\n      relativePath !== null,\n      'rerunTransactionsUnderNode_: relativePath should not be null.'\n    );\n\n    if (transaction.status === TransactionStatus.NEEDS_ABORT) {\n      abortTransaction = true;\n      abortReason = transaction.abortReason;\n      events = events.concat(\n        this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n      );\n    } else if (transaction.status === TransactionStatus.RUN) {\n      if (transaction.retryCount >= (Repo as any).MAX_TRANSACTION_RETRIES_) {\n        abortTransaction = true;\n        abortReason = 'maxretry';\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n        );\n      } else {\n        // This code reruns a transaction\n        const currentNode = this.getLatestState_(\n          transaction.path,\n          setsToIgnore\n        );\n        transaction.currentInputSnapshot = currentNode;\n        const newData = queue[i].update(currentNode.val());\n        if (newData !== undefined) {\n          validateFirebaseData(\n            'transaction failed: Data returned ',\n            newData,\n            transaction.path\n          );\n          let newDataNode = nodeFromJSON(newData);\n          const hasExplicitPriority =\n            typeof newData === 'object' &&\n            newData != null &&\n            contains(newData, '.priority');\n          if (!hasExplicitPriority) {\n            // Keep the old priority if there wasn't a priority explicitly specified.\n            newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n          }\n\n          const oldWriteId = transaction.currentWriteId;\n          const serverValues = this.generateServerValues();\n          const newNodeResolved = resolveDeferredValueSnapshot(\n            newDataNode,\n            serverValues\n          );\n\n          transaction.currentOutputSnapshotRaw = newDataNode;\n          transaction.currentOutputSnapshotResolved = newNodeResolved;\n          transaction.currentWriteId = this.getNextWriteId_();\n          // Mutates setsToIgnore in place\n          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n          events = events.concat(\n            this.serverSyncTree_.applyUserOverwrite(\n              transaction.path,\n              newNodeResolved,\n              transaction.currentWriteId,\n              transaction.applyLocally\n            )\n          );\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(oldWriteId, true)\n          );\n        } else {\n          abortTransaction = true;\n          abortReason = 'nodata';\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n          );\n        }\n      }\n    }\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    events = [];\n    if (abortTransaction) {\n      // Abort.\n      queue[i].status = TransactionStatus.COMPLETED;\n\n      // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).\n      // So defer the unwatcher until we're done.\n      (function(unwatcher) {\n        setTimeout(unwatcher, Math.floor(0));\n      })(queue[i].unwatcher);\n\n      if (queue[i].onComplete) {\n        if (abortReason === 'nodata') {\n          const ref = new Reference(this, queue[i].path);\n          // We set this field immediately, so it's safe to cast to an actual snapshot\n          const lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;\n          const snapshot = new DataSnapshot(lastInput, ref, PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));\n        } else {\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error(abortReason), false, null)\n          );\n        }\n      }\n    }\n  }\n\n  // Clean up completed transactions.\n  this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);\n\n  // Now fire callbacks, now that we're in a good, known state.\n  for (let i = 0; i < callbacks.length; i++) {\n    exceptionGuard(callbacks[i]);\n  }\n\n  // Try to send the transaction result to the server.\n  this.sendReadyTransactions_();\n};\n\n/**\n * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns\n * the node for the given path if there are no pending transactions on any ancestor.\n *\n * @param {!Path} path The location to start at.\n * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.\n * @private\n */\n(Repo.prototype as any).getAncestorTransactionNode_ = function(\n  path: Path\n): Tree<Transaction[]> {\n  let front;\n\n  // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.\n  let transactionNode = this.transactionQueueTree_;\n  while (\n    (front = path.getFront()) !== null &&\n    transactionNode.getValue() === null\n  ) {\n    transactionNode = transactionNode.subTree(front);\n    path = path.popFront();\n  }\n\n  return transactionNode;\n};\n\n/**\n * Builds the queue of all transactions at or below the specified transactionNode.\n *\n * @param {!Tree.<Array.<Transaction>>} transactionNode\n * @return {Array.<Transaction>} The generated queue.\n * @private\n */\n(Repo.prototype as any).buildTransactionQueue_ = function(\n  transactionNode: Tree<Transaction[]>\n): Array<Transaction> {\n  // Walk any child transaction queues and aggregate them into a single queue.\n  const transactionQueue: Transaction[] = [];\n  this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);\n\n  // Sort them by the order the transactions were created.\n  transactionQueue.sort(function(a, b) {\n    return a.order - b.order;\n  });\n\n  return transactionQueue;\n};\n\n/**\n * @param {!Tree.<Array.<Transaction>>} node\n * @param {Array.<Transaction>} queue\n * @private\n */\n(Repo.prototype as any).aggregateTransactionQueuesForNode_ = function(\n  node: Tree<Transaction[]>,\n  queue: Array<Transaction>\n) {\n  const nodeQueue = node.getValue();\n  if (nodeQueue !== null) {\n    for (let i = 0; i < nodeQueue.length; i++) {\n      queue.push(nodeQueue[i]);\n    }\n  }\n\n  node.forEachChild(child => {\n    this.aggregateTransactionQueuesForNode_(child, queue);\n  });\n};\n\n/**\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\n *\n * @param {!Tree.<Array.<!Transaction>>} node\n * @private\n */\n(Repo.prototype as any).pruneCompletedTransactionsBelowNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue) {\n    let to = 0;\n    for (let from = 0; from < queue.length; from++) {\n      if (queue[from].status !== TransactionStatus.COMPLETED) {\n        queue[to] = queue[from];\n        to++;\n      }\n    }\n    queue.length = to;\n    node.setValue(queue.length > 0 ? queue : null);\n  }\n\n  node.forEachChild(childNode => {\n    this.pruneCompletedTransactionsBelowNode_(childNode);\n  });\n};\n\n/**\n * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()\n * since we consider them incompatible with transactions.\n *\n * @param {!Path} path Path for which we want to abort related transactions.\n * @return {!Path}\n * @private\n */\n(Repo.prototype as any).abortTransactions_ = function(path: Path): Path {\n  const affectedPath = this.getAncestorTransactionNode_(path).path();\n\n  const transactionNode = this.transactionQueueTree_.subTree(path);\n\n  transactionNode.forEachAncestor((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  this.abortTransactionsOnNode_(transactionNode);\n\n  transactionNode.forEachDescendant((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  return affectedPath;\n};\n\n/**\n * Abort transactions stored in this transaction queue node.\n *\n * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.\n * @private\n */\n(Repo.prototype as any).abortTransactionsOnNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue !== null) {\n    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n    // the callback could trigger more transactions or sets.\n    const callbacks = [];\n\n    // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones\n    // can be immediately aborted and removed.\n    let events: Event[] = [];\n    let lastSent = -1;\n    for (let i = 0; i < queue.length; i++) {\n      if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {\n        // Already marked.  No action needed.\n      } else if (queue[i].status === TransactionStatus.SENT) {\n        assert(\n          lastSent === i - 1,\n          'All SENT items should be at beginning of queue.'\n        );\n        lastSent = i;\n        // Mark transaction for abort when it comes back.\n        queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;\n        queue[i].abortReason = 'set';\n      } else {\n        assert(\n          queue[i].status === TransactionStatus.RUN,\n          'Unexpected transaction status in abort'\n        );\n        // We can abort it immediately.\n        queue[i].unwatcher();\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true)\n        );\n        if (queue[i].onComplete) {\n          const snapshot: DataSnapshot | null = null;\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error('set'), false, snapshot)\n          );\n        }\n      }\n    }\n    if (lastSent === -1) {\n      // We're not waiting for any sent transactions.  We can clear the queue.\n      node.setValue(null);\n    } else {\n      // Remove the transactions we aborted.\n      queue.length = lastSent + 1;\n    }\n\n    // Now fire the callbacks.\n    this.eventQueue_.raiseEventsForChangedPath(node.path(), events);\n    for (let i = 0; i < callbacks.length; i++) {\n      exceptionGuard(callbacks[i]);\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}