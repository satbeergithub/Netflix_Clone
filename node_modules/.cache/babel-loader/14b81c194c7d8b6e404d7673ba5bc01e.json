{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar childSet_1 = require(\"./childSet\");\nvar util_2 = require(\"@firebase/util\");\nvar Node_1 = require(\"./Node\");\nvar PriorityIndex_1 = require(\"./indexes/PriorityIndex\");\nvar KeyIndex_1 = require(\"./indexes/KeyIndex\");\nvar _defaultIndexMap;\nvar fallbackObject = {};\n/**\n *\n * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes\n * @param {Object.<string, Index>} indexSet\n * @constructor\n */\nvar IndexMap = /** @class */function () {\n  function IndexMap(indexes_, indexSet_) {\n    this.indexes_ = indexes_;\n    this.indexSet_ = indexSet_;\n  }\n  Object.defineProperty(IndexMap, \"Default\", {\n    /**\n     * The default IndexMap for nodes without a priority\n     * @type {!IndexMap}\n     * @const\n     */\n    get: function () {\n      util_1.assert(fallbackObject && PriorityIndex_1.PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');\n      _defaultIndexMap = _defaultIndexMap || new IndexMap({\n        '.priority': fallbackObject\n      }, {\n        '.priority': PriorityIndex_1.PRIORITY_INDEX\n      });\n      return _defaultIndexMap;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   *\n   * @param {!string} indexKey\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n  IndexMap.prototype.get = function (indexKey) {\n    var sortedMap = util_2.safeGet(this.indexes_, indexKey);\n    if (!sortedMap) throw new Error('No index defined for ' + indexKey);\n    if (sortedMap === fallbackObject) {\n      // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n      // regular child map\n      return null;\n    } else {\n      return sortedMap;\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {boolean}\n   */\n  IndexMap.prototype.hasIndex = function (indexDefinition) {\n    return util_2.contains(this.indexSet_, indexDefinition.toString());\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  IndexMap.prototype.addIndex = function (indexDefinition, existingChildren) {\n    util_1.assert(indexDefinition !== KeyIndex_1.KEY_INDEX, \"KeyIndex always exists and isn't meant to be added to the IndexMap.\");\n    var childList = [];\n    var sawIndexedValue = false;\n    var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);\n    var next = iter.getNext();\n    while (next) {\n      sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n      childList.push(next);\n      next = iter.getNext();\n    }\n    var newIndex;\n    if (sawIndexedValue) {\n      newIndex = childSet_1.buildChildSet(childList, indexDefinition.getCompare());\n    } else {\n      newIndex = fallbackObject;\n    }\n    var indexName = indexDefinition.toString();\n    var newIndexSet = util_2.clone(this.indexSet_);\n    newIndexSet[indexName] = indexDefinition;\n    var newIndexes = util_2.clone(this.indexes_);\n    newIndexes[indexName] = newIndex;\n    return new IndexMap(newIndexes, newIndexSet);\n  };\n  /**\n   * Ensure that this node is properly tracked in any indexes that we're maintaining\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  IndexMap.prototype.addToIndexes = function (namedNode, existingChildren) {\n    var _this = this;\n    var newIndexes = util_2.map(this.indexes_, function (indexedChildren, indexName) {\n      var index = util_2.safeGet(_this.indexSet_, indexName);\n      util_1.assert(index, 'Missing index implementation for ' + indexName);\n      if (indexedChildren === fallbackObject) {\n        // Check to see if we need to index everything\n        if (index.isDefinedOn(namedNode.node)) {\n          // We need to build this index\n          var childList = [];\n          var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);\n          var next = iter.getNext();\n          while (next) {\n            if (next.name != namedNode.name) {\n              childList.push(next);\n            }\n            next = iter.getNext();\n          }\n          childList.push(namedNode);\n          return childSet_1.buildChildSet(childList, index.getCompare());\n        } else {\n          // No change, this remains a fallback\n          return fallbackObject;\n        }\n      } else {\n        var existingSnap = existingChildren.get(namedNode.name);\n        var newChildren = indexedChildren;\n        if (existingSnap) {\n          newChildren = newChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));\n        }\n        return newChildren.insert(namedNode, namedNode.node);\n      }\n    });\n    return new IndexMap(newIndexes, this.indexSet_);\n  };\n  /**\n   * Create a new IndexMap instance with the given value removed\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  IndexMap.prototype.removeFromIndexes = function (namedNode, existingChildren) {\n    var newIndexes = util_2.map(this.indexes_, function (indexedChildren) {\n      if (indexedChildren === fallbackObject) {\n        // This is the fallback. Just return it, nothing to do in this case\n        return indexedChildren;\n      } else {\n        var existingSnap = existingChildren.get(namedNode.name);\n        if (existingSnap) {\n          return indexedChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));\n        } else {\n          // No record of this child\n          return indexedChildren;\n        }\n      }\n    });\n    return new IndexMap(newIndexes, this.indexSet_);\n  };\n  return IndexMap;\n}();\nexports.IndexMap = IndexMap;","map":{"version":3,"mappings":"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","names":["_defaultIndexMap","fallbackObject","indexes_","indexSet_","Object","IndexMap","util_1","PriorityIndex_1","indexKey","sortedMap","util_2","Error","indexDefinition","toString","existingChildren","KeyIndex_1","childList","sawIndexedValue","iter","getIterator","Node_1","Wrap","next","getNext","isDefinedOn","node","push","newIndex","childSet_1","getCompare","indexName","newIndexSet","newIndexes","namedNode","indexedChildren","index","_this","name","existingSnap","get","newChildren","remove","insert","exports"],"sources":["../src/core/snap/IndexMap.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { buildChildSet } from './childSet';\nimport { contains, clone, map, safeGet } from '@firebase/util';\nimport { NamedNode, Node } from './Node';\nimport { PRIORITY_INDEX } from './indexes/PriorityIndex';\nimport { KEY_INDEX } from './indexes/KeyIndex';\nimport { SortedMap } from '../util/SortedMap';\nimport { Index } from './indexes/Index';\n\nlet _defaultIndexMap: IndexMap;\n\nconst fallbackObject = {};\n\n/**\n *\n * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes\n * @param {Object.<string, Index>} indexSet\n * @constructor\n */\nexport class IndexMap {\n  /**\n   * The default IndexMap for nodes without a priority\n   * @type {!IndexMap}\n   * @const\n   */\n  static get Default(): IndexMap {\n    assert(\n      fallbackObject && PRIORITY_INDEX,\n      'ChildrenNode.ts has not been loaded'\n    );\n    _defaultIndexMap =\n      _defaultIndexMap ||\n      new IndexMap(\n        { '.priority': fallbackObject },\n        { '.priority': PRIORITY_INDEX }\n      );\n    return _defaultIndexMap;\n  }\n\n  constructor(\n    private indexes_: {\n      [k: string]: SortedMap<NamedNode, Node> | /*FallbackType*/ object;\n    },\n    private indexSet_: { [k: string]: Index }\n  ) {}\n\n  /**\n   *\n   * @param {!string} indexKey\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n  get(indexKey: string): SortedMap<NamedNode, Node> | null {\n    const sortedMap = safeGet(this.indexes_, indexKey);\n    if (!sortedMap) throw new Error('No index defined for ' + indexKey);\n\n    if (sortedMap === fallbackObject) {\n      // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n      // regular child map\n      return null;\n    } else {\n      return sortedMap;\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {boolean}\n   */\n  hasIndex(indexDefinition: Index): boolean {\n    return contains(this.indexSet_, indexDefinition.toString());\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  addIndex(\n    indexDefinition: Index,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    assert(\n      indexDefinition !== KEY_INDEX,\n      \"KeyIndex always exists and isn't meant to be added to the IndexMap.\"\n    );\n    const childList = [];\n    let sawIndexedValue = false;\n    const iter = existingChildren.getIterator(NamedNode.Wrap);\n    let next = iter.getNext();\n    while (next) {\n      sawIndexedValue =\n        sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n      childList.push(next);\n      next = iter.getNext();\n    }\n    let newIndex;\n    if (sawIndexedValue) {\n      newIndex = buildChildSet(childList, indexDefinition.getCompare());\n    } else {\n      newIndex = fallbackObject;\n    }\n    const indexName = indexDefinition.toString();\n    const newIndexSet = clone(this.indexSet_);\n    newIndexSet[indexName] = indexDefinition;\n    const newIndexes = clone(this.indexes_);\n    newIndexes[indexName] = newIndex;\n    return new IndexMap(newIndexes, newIndexSet);\n  }\n\n  /**\n   * Ensure that this node is properly tracked in any indexes that we're maintaining\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  addToIndexes(\n    namedNode: NamedNode,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    const newIndexes = map(\n      this.indexes_,\n      (indexedChildren: SortedMap<NamedNode, Node>, indexName: string) => {\n        const index = safeGet(this.indexSet_, indexName);\n        assert(index, 'Missing index implementation for ' + indexName);\n        if (indexedChildren === fallbackObject) {\n          // Check to see if we need to index everything\n          if (index.isDefinedOn(namedNode.node)) {\n            // We need to build this index\n            const childList = [];\n            const iter = existingChildren.getIterator(NamedNode.Wrap);\n            let next = iter.getNext();\n            while (next) {\n              if (next.name != namedNode.name) {\n                childList.push(next);\n              }\n              next = iter.getNext();\n            }\n            childList.push(namedNode);\n            return buildChildSet(childList, index.getCompare());\n          } else {\n            // No change, this remains a fallback\n            return fallbackObject;\n          }\n        } else {\n          const existingSnap = existingChildren.get(namedNode.name);\n          let newChildren = indexedChildren;\n          if (existingSnap) {\n            newChildren = newChildren.remove(\n              new NamedNode(namedNode.name, existingSnap)\n            );\n          }\n          return newChildren.insert(namedNode, namedNode.node);\n        }\n      }\n    );\n    return new IndexMap(newIndexes, this.indexSet_);\n  }\n\n  /**\n   * Create a new IndexMap instance with the given value removed\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  removeFromIndexes(\n    namedNode: NamedNode,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    const newIndexes = map(this.indexes_, function(\n      indexedChildren: SortedMap<NamedNode, Node>\n    ) {\n      if (indexedChildren === fallbackObject) {\n        // This is the fallback. Just return it, nothing to do in this case\n        return indexedChildren;\n      } else {\n        const existingSnap = existingChildren.get(namedNode.name);\n        if (existingSnap) {\n          return indexedChildren.remove(\n            new NamedNode(namedNode.name, existingSnap)\n          );\n        } else {\n          // No record of this child\n          return indexedChildren;\n        }\n      }\n    });\n    return new IndexMap(newIndexes, this.indexSet_);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}