{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Path_1 = require(\"./util/Path\");\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\nvar CountedSet_1 = require(\"./util/CountedSet\");\n/**\n * Helper class to store a sparse set of snapshots.\n *\n * @constructor\n */\nvar SparseSnapshotTree = /** @class */function () {\n  function SparseSnapshotTree() {\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.value_ = null;\n    /**\n     * @private\n     * @type {CountedSet}\n     */\n    this.children_ = null;\n  }\n  /**\n   * Gets the node stored at the given path if one exists.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {?Node} The retrieved node, or null.\n   */\n  SparseSnapshotTree.prototype.find = function (path) {\n    if (this.value_ != null) {\n      return this.value_.getChild(path);\n    } else if (!path.isEmpty() && this.children_ != null) {\n      var childKey = path.getFront();\n      path = path.popFront();\n      if (this.children_.contains(childKey)) {\n        var childTree = this.children_.get(childKey);\n        return childTree.find(path);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Stores the given node at the specified path. If there is already a node\n   * at a shallower path, it merges the new data into that snapshot node.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @param {!Node} data The new data, or null.\n   */\n  SparseSnapshotTree.prototype.remember = function (path, data) {\n    if (path.isEmpty()) {\n      this.value_ = data;\n      this.children_ = null;\n    } else if (this.value_ !== null) {\n      this.value_ = this.value_.updateChild(path, data);\n    } else {\n      if (this.children_ == null) {\n        this.children_ = new CountedSet_1.CountedSet();\n      }\n      var childKey = path.getFront();\n      if (!this.children_.contains(childKey)) {\n        this.children_.add(childKey, new SparseSnapshotTree());\n      }\n      var child = this.children_.get(childKey);\n      path = path.popFront();\n      child.remember(path, data);\n    }\n  };\n  /**\n   * Purge the data at path from the cache.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {boolean} True if this node should now be removed.\n   */\n  SparseSnapshotTree.prototype.forget = function (path) {\n    if (path.isEmpty()) {\n      this.value_ = null;\n      this.children_ = null;\n      return true;\n    } else {\n      if (this.value_ !== null) {\n        if (this.value_.isLeafNode()) {\n          // We're trying to forget a node that doesn't exist\n          return false;\n        } else {\n          var value = this.value_;\n          this.value_ = null;\n          var self_1 = this;\n          value.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, tree) {\n            self_1.remember(new Path_1.Path(key), tree);\n          });\n          return this.forget(path);\n        }\n      } else if (this.children_ !== null) {\n        var childKey = path.getFront();\n        path = path.popFront();\n        if (this.children_.contains(childKey)) {\n          var safeToRemove = this.children_.get(childKey).forget(path);\n          if (safeToRemove) {\n            this.children_.remove(childKey);\n          }\n        }\n        if (this.children_.isEmpty()) {\n          this.children_ = null;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    }\n  };\n  /**\n   * Recursively iterates through all of the stored tree and calls the\n   * callback on each one.\n   *\n   * @param {!Path} prefixPath Path to look up node for.\n   * @param {!Function} func The function to invoke for each tree.\n   */\n  SparseSnapshotTree.prototype.forEachTree = function (prefixPath, func) {\n    if (this.value_ !== null) {\n      func(prefixPath, this.value_);\n    } else {\n      this.forEachChild(function (key, tree) {\n        var path = new Path_1.Path(prefixPath.toString() + '/' + key);\n        tree.forEachTree(path, func);\n      });\n    }\n  };\n  /**\n   * Iterates through each immediate child and triggers the callback.\n   *\n   * @param {!Function} func The function to invoke for each child.\n   */\n  SparseSnapshotTree.prototype.forEachChild = function (func) {\n    if (this.children_ !== null) {\n      this.children_.each(function (key, tree) {\n        func(key, tree);\n      });\n    }\n  };\n  return SparseSnapshotTree;\n}();\nexports.SparseSnapshotTree = SparseSnapshotTree;","map":{"version":3,"mappings":"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","names":["SparseSnapshotTree","path","value_","getChild","isEmpty","children_","childKey","getFront","popFront","contains","childTree","get","find","data","updateChild","CountedSet_1","add","child","remember","isLeafNode","value","self_1","forEachChild","PriorityIndex_1","key","tree","Path_1","forget","safeToRemove","remove","prefixPath","func","toString","forEachTree","each","exports"],"sources":["../src/core/SparseSnapshotTree.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from './util/Path';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { CountedSet } from './util/CountedSet';\nimport { Node } from './snap/Node';\n\n/**\n * Helper class to store a sparse set of snapshots.\n *\n * @constructor\n */\nexport class SparseSnapshotTree {\n  /**\n   * @private\n   * @type {Node}\n   */\n  private value_: Node | null = null;\n\n  /**\n   * @private\n   * @type {CountedSet}\n   */\n  private children_: CountedSet<string, SparseSnapshotTree> | null = null;\n\n  /**\n   * Gets the node stored at the given path if one exists.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {?Node} The retrieved node, or null.\n   */\n  find(path: Path): Node | null {\n    if (this.value_ != null) {\n      return this.value_.getChild(path);\n    } else if (!path.isEmpty() && this.children_ != null) {\n      const childKey = path.getFront();\n      path = path.popFront();\n      if (this.children_.contains(childKey)) {\n        const childTree = this.children_.get(childKey) as SparseSnapshotTree;\n        return childTree.find(path);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Stores the given node at the specified path. If there is already a node\n   * at a shallower path, it merges the new data into that snapshot node.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @param {!Node} data The new data, or null.\n   */\n  remember(path: Path, data: Node) {\n    if (path.isEmpty()) {\n      this.value_ = data;\n      this.children_ = null;\n    } else if (this.value_ !== null) {\n      this.value_ = this.value_.updateChild(path, data);\n    } else {\n      if (this.children_ == null) {\n        this.children_ = new CountedSet<string, SparseSnapshotTree>();\n      }\n\n      const childKey = path.getFront();\n      if (!this.children_.contains(childKey)) {\n        this.children_.add(childKey, new SparseSnapshotTree());\n      }\n\n      const child = this.children_.get(childKey) as SparseSnapshotTree;\n      path = path.popFront();\n      child.remember(path, data);\n    }\n  }\n\n  /**\n   * Purge the data at path from the cache.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {boolean} True if this node should now be removed.\n   */\n  forget(path: Path): boolean {\n    if (path.isEmpty()) {\n      this.value_ = null;\n      this.children_ = null;\n      return true;\n    } else {\n      if (this.value_ !== null) {\n        if (this.value_.isLeafNode()) {\n          // We're trying to forget a node that doesn't exist\n          return false;\n        } else {\n          const value = this.value_;\n          this.value_ = null;\n\n          const self = this;\n          value.forEachChild(PRIORITY_INDEX, function(key, tree) {\n            self.remember(new Path(key), tree);\n          });\n\n          return this.forget(path);\n        }\n      } else if (this.children_ !== null) {\n        const childKey = path.getFront();\n        path = path.popFront();\n        if (this.children_.contains(childKey)) {\n          const safeToRemove = (this.children_.get(\n            childKey\n          ) as SparseSnapshotTree).forget(path);\n          if (safeToRemove) {\n            this.children_.remove(childKey);\n          }\n        }\n\n        if (this.children_.isEmpty()) {\n          this.children_ = null;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Recursively iterates through all of the stored tree and calls the\n   * callback on each one.\n   *\n   * @param {!Path} prefixPath Path to look up node for.\n   * @param {!Function} func The function to invoke for each tree.\n   */\n  forEachTree(prefixPath: Path, func: (a: Path, b: Node) => any) {\n    if (this.value_ !== null) {\n      func(prefixPath, this.value_);\n    } else {\n      this.forEachChild((key, tree) => {\n        const path = new Path(prefixPath.toString() + '/' + key);\n        tree.forEachTree(path, func);\n      });\n    }\n  }\n\n  /**\n   * Iterates through each immediate child and triggers the callback.\n   *\n   * @param {!Function} func The function to invoke for each child.\n   */\n  forEachChild(func: (a: string, b: SparseSnapshotTree) => void) {\n    if (this.children_ !== null) {\n      this.children_.each((key, tree) => {\n        func(key, tree);\n      });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}