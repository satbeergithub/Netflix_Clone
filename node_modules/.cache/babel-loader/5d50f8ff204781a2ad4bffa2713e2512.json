{"ast":null,"code":"import * as constants from './constants';\nimport * as errorsExports from './error';\nimport { FailRequest } from './failrequest';\nimport { Location } from './location';\nimport * as promiseimpl from './promise_external';\nimport { RequestMap } from './requestmap';\nimport * as type from './type';\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\nvar AuthWrapper = /** @class */function () {\n  function AuthWrapper(app, maker, requestMaker, service, pool) {\n    this.bucket_ = null;\n    this.deleted_ = false;\n    this.app_ = app;\n    if (this.app_ !== null) {\n      var options = this.app_.options;\n      if (type.isDef(options)) {\n        this.bucket_ = AuthWrapper.extractBucket_(options);\n      }\n    }\n    this.storageRefMaker_ = maker;\n    this.requestMaker_ = requestMaker;\n    this.pool_ = pool;\n    this.service_ = service;\n    this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n    this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n    this.requestMap_ = new RequestMap();\n  }\n  AuthWrapper.extractBucket_ = function (config) {\n    var bucketString = config[constants.configOption] || null;\n    if (bucketString == null) {\n      return null;\n    }\n    var loc = Location.makeFromBucketSpec(bucketString);\n    return loc.bucket;\n  };\n  AuthWrapper.prototype.getAuthToken = function () {\n    // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n    // (b/28673818).\n    if (this.app_ !== null && type.isDef(this.app_.INTERNAL) && type.isDef(this.app_.INTERNAL.getToken)) {\n      return this.app_.INTERNAL.getToken().then(function (response) {\n        if (response !== null) {\n          return response.accessToken;\n        } else {\n          return null;\n        }\n      }, function (_error) {\n        return null;\n      });\n    } else {\n      return promiseimpl.resolve(null);\n    }\n  };\n  AuthWrapper.prototype.bucket = function () {\n    if (this.deleted_) {\n      throw errorsExports.appDeleted();\n    } else {\n      return this.bucket_;\n    }\n  };\n  /**\n   * The service associated with this auth wrapper. Untyped to avoid circular\n   * type dependencies.\n   */\n  AuthWrapper.prototype.service = function () {\n    return this.service_;\n  };\n  /**\n   * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n   * at the given Location.\n   * @param loc The Location.\n   * @return Actually a firebaseStorage.Reference, typing not allowed\n   *     because of circular dependency problems.\n   */\n  AuthWrapper.prototype.makeStorageReference = function (loc) {\n    return this.storageRefMaker_(this, loc);\n  };\n  AuthWrapper.prototype.makeRequest = function (requestInfo, authToken) {\n    if (!this.deleted_) {\n      var request = this.requestMaker_(requestInfo, authToken, this.pool_);\n      this.requestMap_.addRequest(request);\n      return request;\n    } else {\n      return new FailRequest(errorsExports.appDeleted());\n    }\n  };\n  /**\n   * Stop running requests and prevent more from being created.\n   */\n  AuthWrapper.prototype.deleteApp = function () {\n    this.deleted_ = true;\n    this.app_ = null;\n    this.requestMap_.clear();\n  };\n  AuthWrapper.prototype.maxUploadRetryTime = function () {\n    return this.maxUploadRetryTime_;\n  };\n  AuthWrapper.prototype.setMaxUploadRetryTime = function (time) {\n    this.maxUploadRetryTime_ = time;\n  };\n  AuthWrapper.prototype.maxOperationRetryTime = function () {\n    return this.maxOperationRetryTime_;\n  };\n  AuthWrapper.prototype.setMaxOperationRetryTime = function (time) {\n    this.maxOperationRetryTime_ = time;\n  };\n  return AuthWrapper;\n}();\nexport { AuthWrapper };","map":{"version":3,"mappings":"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","names":["constants","errorsExports","FailRequest","Location","promiseimpl","RequestMap","type","app","maker","requestMaker","service","pool","app_","options","isDef","bucket_","AuthWrapper","extractBucket_","storageRefMaker_","requestMaker_","pool_","service_","maxOperationRetryTime_","defaultMaxOperationRetryTime","maxUploadRetryTime_","defaultMaxUploadRetryTime","requestMap_","config","bucketString","configOption","loc","makeFromBucketSpec","bucket","INTERNAL","getToken","then","response","accessToken","_error","resolve","deleted_","appDeleted","requestInfo","authToken","request","addRequest","clear","time"],"sources":["../src/implementation/authwrapper.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Reference } from '../reference';\nimport { Service } from '../service';\nimport * as constants from './constants';\nimport * as errorsExports from './error';\nimport { errors } from './error';\nimport { FailRequest } from './failrequest';\nimport { Location } from './location';\nimport * as promiseimpl from './promise_external';\nimport { Request } from './request';\nimport { RequestInfo } from './requestinfo';\nimport { requestMaker } from './requestmaker';\nimport { RequestMap } from './requestmap';\nimport * as type from './type';\nimport { XhrIoPool } from './xhriopool';\nimport { FirebaseApp, FirebaseAuthTokenData } from '@firebase/app';\n\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\nexport class AuthWrapper {\n  private app_: FirebaseApp | null;\n  private bucket_: string | null = null;\n\n  /**\n  maker\n     */\n  private storageRefMaker_: (p1: AuthWrapper, p2: Location) => Reference;\n  private requestMaker_: requestMaker;\n  private pool_: XhrIoPool;\n  private service_: Service;\n  private maxOperationRetryTime_: number;\n  private maxUploadRetryTime_: number;\n  private requestMap_: RequestMap;\n  private deleted_: boolean = false;\n\n  constructor(\n    app: FirebaseApp | null,\n    maker: (p1: AuthWrapper, p2: Location) => Reference,\n    requestMaker: requestMaker,\n    service: Service,\n    pool: XhrIoPool\n  ) {\n    this.app_ = app;\n    if (this.app_ !== null) {\n      let options = this.app_.options;\n      if (type.isDef(options)) {\n        this.bucket_ = AuthWrapper.extractBucket_(options);\n      }\n    }\n    this.storageRefMaker_ = maker;\n    this.requestMaker_ = requestMaker;\n    this.pool_ = pool;\n    this.service_ = service;\n    this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n    this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n    this.requestMap_ = new RequestMap();\n  }\n\n  private static extractBucket_(config: {\n    [prop: string]: any;\n  }): string | null {\n    let bucketString = config[constants.configOption] || null;\n    if (bucketString == null) {\n      return null;\n    }\n    let loc: Location = Location.makeFromBucketSpec(bucketString);\n    return loc.bucket;\n  }\n\n  getAuthToken(): Promise<string | null> {\n    // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n    // (b/28673818).\n    if (\n      this.app_ !== null &&\n      type.isDef(this.app_.INTERNAL) &&\n      type.isDef(this.app_.INTERNAL.getToken)\n    ) {\n      return this.app_.INTERNAL.getToken().then(\n        function(response: FirebaseAuthTokenData | null): string | null {\n          if (response !== null) {\n            return response.accessToken;\n          } else {\n            return null;\n          }\n        },\n        function(_error) {\n          return null;\n        }\n      );\n    } else {\n      return promiseimpl.resolve(null) as Promise<string | null>;\n    }\n  }\n\n  bucket(): string | null {\n    if (this.deleted_) {\n      throw errorsExports.appDeleted();\n    } else {\n      return this.bucket_;\n    }\n  }\n\n  /**\n   * The service associated with this auth wrapper. Untyped to avoid circular\n   * type dependencies.\n   */\n  service(): Service {\n    return this.service_;\n  }\n\n  /**\n   * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n   * at the given Location.\n   * @param loc The Location.\n   * @return Actually a firebaseStorage.Reference, typing not allowed\n   *     because of circular dependency problems.\n   */\n  makeStorageReference(loc: Location): Reference {\n    return this.storageRefMaker_(this, loc);\n  }\n\n  makeRequest<T>(\n    requestInfo: RequestInfo<T>,\n    authToken: string | null\n  ): Request<T> {\n    if (!this.deleted_) {\n      let request = this.requestMaker_(requestInfo, authToken, this.pool_);\n      this.requestMap_.addRequest(request);\n      return request;\n    } else {\n      return new FailRequest(errorsExports.appDeleted());\n    }\n  }\n\n  /**\n   * Stop running requests and prevent more from being created.\n   */\n  deleteApp() {\n    this.deleted_ = true;\n    this.app_ = null;\n    this.requestMap_.clear();\n  }\n\n  maxUploadRetryTime(): number {\n    return this.maxUploadRetryTime_;\n  }\n\n  setMaxUploadRetryTime(time: number) {\n    this.maxUploadRetryTime_ = time;\n  }\n\n  maxOperationRetryTime(): number {\n    return this.maxOperationRetryTime_;\n  }\n\n  setMaxOperationRetryTime(time: number) {\n    this.maxOperationRetryTime_ = time;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}