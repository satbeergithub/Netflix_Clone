{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @file Provides a Blob-like wrapper for various binary types (including the\n * native Blob type). This makes it possible to upload types like ArrayBuffers,\n * making uploads possible in environments without the native Blob type.\n */\nimport * as fs from './fs';\nimport * as string from './string';\nimport { StringFormat } from './string';\nimport * as type from './type';\n/**\n * @param opt_elideCopy If true, doesn't copy mutable input data\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\n *     modified after this blob's construction.\n */\nvar FbsBlob = /** @class */function () {\n  function FbsBlob(data, opt_elideCopy) {\n    var size = 0;\n    var blobType = '';\n    if (type.isNativeBlob(data)) {\n      this.data_ = data;\n      size = data.size;\n      blobType = data.type;\n    } else if (data instanceof ArrayBuffer) {\n      if (opt_elideCopy) {\n        this.data_ = new Uint8Array(data);\n      } else {\n        this.data_ = new Uint8Array(data.byteLength);\n        this.data_.set(new Uint8Array(data));\n      }\n      size = this.data_.length;\n    } else if (data instanceof Uint8Array) {\n      if (opt_elideCopy) {\n        this.data_ = data;\n      } else {\n        this.data_ = new Uint8Array(data.length);\n        this.data_.set(data);\n      }\n      size = data.length;\n    }\n    this.size_ = size;\n    this.type_ = blobType;\n  }\n  FbsBlob.prototype.size = function () {\n    return this.size_;\n  };\n  FbsBlob.prototype.type = function () {\n    return this.type_;\n  };\n  FbsBlob.prototype.slice = function (startByte, endByte) {\n    if (type.isNativeBlob(this.data_)) {\n      var realBlob = this.data_;\n      var sliced = fs.sliceBlob(realBlob, startByte, endByte);\n      if (sliced === null) {\n        return null;\n      }\n      return new FbsBlob(sliced);\n    } else {\n      var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);\n      return new FbsBlob(slice, true);\n    }\n  };\n  FbsBlob.getBlob = function () {\n    var var_args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      var_args[_i] = arguments[_i];\n    }\n    if (type.isNativeBlobDefined()) {\n      var blobby = var_args.map(function (val) {\n        if (val instanceof FbsBlob) {\n          return val.data_;\n        } else {\n          return val;\n        }\n      });\n      return new FbsBlob(fs.getBlob.apply(null, blobby));\n    } else {\n      var uint8Arrays = var_args.map(function (val) {\n        if (type.isString(val)) {\n          return string.dataFromString(StringFormat.RAW, val).data;\n        } else {\n          // Blobs don't exist, so this has to be a Uint8Array.\n          return val.data_;\n        }\n      });\n      var finalLength_1 = 0;\n      uint8Arrays.forEach(function (array) {\n        finalLength_1 += array.byteLength;\n      });\n      var merged_1 = new Uint8Array(finalLength_1);\n      var index_1 = 0;\n      uint8Arrays.forEach(function (array) {\n        for (var i = 0; i < array.length; i++) {\n          merged_1[index_1++] = array[i];\n        }\n      });\n      return new FbsBlob(merged_1, true);\n    }\n  };\n  FbsBlob.prototype.uploadData = function () {\n    return this.data_;\n  };\n  return FbsBlob;\n}();\nexport { FbsBlob };","map":{"version":3,"mappings":"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","names":["fs","string","StringFormat","type","data","opt_elideCopy","size","blobType","isNativeBlob","data_","ArrayBuffer","Uint8Array","byteLength","set","length","size_","type_","FbsBlob","startByte","endByte","realBlob","sliced","sliceBlob","slice","buffer","_i","var_args","isNativeBlobDefined","blobby","map","val","getBlob","apply","uint8Arrays","isString","dataFromString","RAW","finalLength_1","forEach","array","merged_1","index_1","i"],"sources":["../src/implementation/blob.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Provides a Blob-like wrapper for various binary types (including the\n * native Blob type). This makes it possible to upload types like ArrayBuffers,\n * making uploads possible in environments without the native Blob type.\n */\nimport * as fs from './fs';\nimport * as string from './string';\nimport { StringFormat } from './string';\nimport * as type from './type';\n\n/**\n * @param opt_elideCopy If true, doesn't copy mutable input data\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\n *     modified after this blob's construction.\n */\nexport class FbsBlob {\n  private data_: Blob | Uint8Array;\n  private size_: number;\n  private type_: string;\n\n  constructor(data: Blob | Uint8Array | ArrayBuffer, opt_elideCopy?: boolean) {\n    let size: number = 0;\n    let blobType: string = '';\n    if (type.isNativeBlob(data)) {\n      this.data_ = data as Blob;\n      size = (data as Blob).size;\n      blobType = (data as Blob).type;\n    } else if (data instanceof ArrayBuffer) {\n      if (opt_elideCopy) {\n        this.data_ = new Uint8Array(data);\n      } else {\n        this.data_ = new Uint8Array(data.byteLength);\n        this.data_.set(new Uint8Array(data));\n      }\n      size = this.data_.length;\n    } else if (data instanceof Uint8Array) {\n      if (opt_elideCopy) {\n        this.data_ = data as Uint8Array;\n      } else {\n        this.data_ = new Uint8Array(data.length);\n        this.data_.set(data as Uint8Array);\n      }\n      size = data.length;\n    }\n    this.size_ = size;\n    this.type_ = blobType;\n  }\n\n  size(): number {\n    return this.size_;\n  }\n\n  type(): string {\n    return this.type_;\n  }\n\n  slice(startByte: number, endByte: number): FbsBlob | null {\n    if (type.isNativeBlob(this.data_)) {\n      let realBlob = this.data_ as Blob;\n      let sliced = fs.sliceBlob(realBlob, startByte, endByte);\n      if (sliced === null) {\n        return null;\n      }\n      return new FbsBlob(sliced);\n    } else {\n      let slice = new Uint8Array(\n        (this.data_ as Uint8Array).buffer,\n        startByte,\n        endByte - startByte\n      );\n      return new FbsBlob(slice, true);\n    }\n  }\n\n  static getBlob(...var_args: (string | FbsBlob)[]): FbsBlob | null {\n    if (type.isNativeBlobDefined()) {\n      var blobby: (Blob | Uint8Array | string)[] = var_args.map(function(\n        val: string | FbsBlob\n      ): Blob | Uint8Array | string {\n        if (val instanceof FbsBlob) {\n          return val.data_;\n        } else {\n          return val;\n        }\n      });\n      return new FbsBlob(fs.getBlob.apply(null, blobby));\n    } else {\n      let uint8Arrays: Uint8Array[] = var_args.map(function(\n        val: string | FbsBlob\n      ): Uint8Array {\n        if (type.isString(val)) {\n          return string.dataFromString(StringFormat.RAW, val as string).data;\n        } else {\n          // Blobs don't exist, so this has to be a Uint8Array.\n          return (val as FbsBlob).data_ as Uint8Array;\n        }\n      });\n      let finalLength = 0;\n      uint8Arrays.forEach(function(array: Uint8Array): void {\n        finalLength += array.byteLength;\n      });\n      let merged = new Uint8Array(finalLength);\n      let index = 0;\n      uint8Arrays.forEach(function(array: Uint8Array) {\n        for (let i = 0; i < array.length; i++) {\n          merged[index++] = array[i];\n        }\n      });\n      return new FbsBlob(merged, true);\n    }\n  }\n\n  uploadData(): Blob | Uint8Array {\n    return this.data_;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}