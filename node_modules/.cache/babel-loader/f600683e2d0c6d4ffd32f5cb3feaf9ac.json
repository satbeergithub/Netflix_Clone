{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as array from './array';\nimport { FbsBlob } from './blob';\nimport * as errorsExports from './error';\nimport * as MetadataUtils from './metadata';\nimport * as object from './object';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\n/**\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\n */\nexport function handlerCheck(cndn) {\n  if (!cndn) {\n    throw errorsExports.unknown();\n  }\n}\nexport function metadataHandler(authWrapper, mappings) {\n  function handler(xhr, text) {\n    var metadata = MetadataUtils.fromResourceString(authWrapper, text, mappings);\n    handlerCheck(metadata !== null);\n    return metadata;\n  }\n  return handler;\n}\nexport function sharedErrorHandler(location) {\n  function errorHandler(xhr, err) {\n    var newErr;\n    if (xhr.getStatus() === 401) {\n      newErr = errorsExports.unauthenticated();\n    } else {\n      if (xhr.getStatus() === 402) {\n        newErr = errorsExports.quotaExceeded(location.bucket);\n      } else {\n        if (xhr.getStatus() === 403) {\n          newErr = errorsExports.unauthorized(location.path);\n        } else {\n          newErr = err;\n        }\n      }\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\nexport function objectErrorHandler(location) {\n  var shared = sharedErrorHandler(location);\n  function errorHandler(xhr, err) {\n    var newErr = shared(xhr, err);\n    if (xhr.getStatus() === 404) {\n      newErr = errorsExports.objectNotFound(location.path);\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\nexport function getMetadata(authWrapper, location, mappings) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'GET';\n  var timeout = authWrapper.maxOperationRetryTime();\n  var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nexport function updateMetadata(authWrapper, location, metadata, mappings) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'PATCH';\n  var body = MetadataUtils.toResourceString(metadata, mappings);\n  var headers = {\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  var timeout = authWrapper.maxOperationRetryTime();\n  var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nexport function deleteObject(authWrapper, location) {\n  var urlPart = location.fullServerUrl();\n  var url = UrlUtils.makeNormalUrl(urlPart);\n  var method = 'DELETE';\n  var timeout = authWrapper.maxOperationRetryTime();\n  function handler(xhr, text) {}\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.successCodes = [200, 204];\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\nexport function determineContentType_(metadata, blob) {\n  return metadata && metadata['contentType'] || blob && blob.type() || 'application/octet-stream';\n}\nexport function metadataForUpload_(location, blob, opt_metadata) {\n  var metadata = object.clone(opt_metadata);\n  metadata['fullPath'] = location.path;\n  metadata['size'] = blob.size();\n  if (!metadata['contentType']) {\n    metadata['contentType'] = determineContentType_(null, blob);\n  }\n  return metadata;\n}\nexport function multipartUpload(authWrapper, location, mappings, blob, opt_metadata) {\n  var urlPart = location.bucketOnlyServerUrl();\n  var headers = {\n    'X-Goog-Upload-Protocol': 'multipart'\n  };\n  function genBoundary() {\n    var str = '';\n    for (var i = 0; i < 2; i++) {\n      str = str + Math.random().toString().slice(2);\n    }\n    return str;\n  }\n  var boundary = genBoundary();\n  headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n  var metadata = metadataForUpload_(location, blob, opt_metadata);\n  var metadataString = MetadataUtils.toResourceString(metadata, mappings);\n  var preBlobPart = '--' + boundary + '\\r\\n' + 'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' + metadataString + '\\r\\n--' + boundary + '\\r\\n' + 'Content-Type: ' + metadata['contentType'] + '\\r\\n\\r\\n';\n  var postBlobPart = '\\r\\n--' + boundary + '--';\n  var body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n  var urlParams = {\n    name: metadata['fullPath']\n  };\n  var url = UrlUtils.makeUploadUrl(urlPart);\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n * @struct\n */\nvar ResumableUploadStatus = /** @class */function () {\n  function ResumableUploadStatus(current, total, finalized, metadata) {\n    this.current = current;\n    this.total = total;\n    this.finalized = !!finalized;\n    this.metadata = metadata || null;\n  }\n  return ResumableUploadStatus;\n}();\nexport { ResumableUploadStatus };\nexport function checkResumeHeader_(xhr, opt_allowed) {\n  var status;\n  try {\n    status = xhr.getResponseHeader('X-Goog-Upload-Status');\n  } catch (e) {\n    handlerCheck(false);\n  }\n  var allowed = opt_allowed || ['active'];\n  handlerCheck(array.contains(allowed, status));\n  return status;\n}\nexport function createResumableUpload(authWrapper, location, mappings, blob, opt_metadata) {\n  var urlPart = location.bucketOnlyServerUrl();\n  var metadata = metadataForUpload_(location, blob, opt_metadata);\n  var urlParams = {\n    name: metadata['fullPath']\n  };\n  var url = UrlUtils.makeUploadUrl(urlPart);\n  var method = 'POST';\n  var headers = {\n    'X-Goog-Upload-Protocol': 'resumable',\n    'X-Goog-Upload-Command': 'start',\n    'X-Goog-Upload-Header-Content-Length': blob.size(),\n    'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  var body = MetadataUtils.toResourceString(metadata, mappings);\n  var timeout = authWrapper.maxUploadRetryTime();\n  function handler(xhr, text) {\n    checkResumeHeader_(xhr);\n    var url;\n    try {\n      url = xhr.getResponseHeader('X-Goog-Upload-URL');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    handlerCheck(type.isString(url));\n    return url;\n  }\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nexport function getResumableUploadStatus(authWrapper, location, url, blob) {\n  var headers = {\n    'X-Goog-Upload-Command': 'query'\n  };\n  function handler(xhr, text) {\n    var status = checkResumeHeader_(xhr, ['active', 'final']);\n    var sizeString;\n    try {\n      sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    var size = parseInt(sizeString, 10);\n    handlerCheck(!isNaN(size));\n    return new ResumableUploadStatus(size, blob.size(), status === 'final');\n  }\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nexport var resumableUploadChunkSize = 256 * 1024;\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param opt_status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nexport function continueResumableUpload(location, authWrapper, url, blob, chunkSize, mappings, opt_status, opt_progressCallback) {\n  // TODO(andysoto): standardize on internal asserts\n  // assert(!(opt_status && opt_status.finalized));\n  var status = new ResumableUploadStatus(0, 0);\n  if (opt_status) {\n    status.current = opt_status.current;\n    status.total = opt_status.total;\n  } else {\n    status.current = 0;\n    status.total = blob.size();\n  }\n  if (blob.size() !== status.total) {\n    throw errorsExports.serverFileWrongSize();\n  }\n  var bytesLeft = status.total - status.current;\n  var bytesToUpload = bytesLeft;\n  if (chunkSize > 0) {\n    bytesToUpload = Math.min(bytesToUpload, chunkSize);\n  }\n  var startByte = status.current;\n  var endByte = startByte + bytesToUpload;\n  var uploadCommand = bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n  var headers = {\n    'X-Goog-Upload-Command': uploadCommand,\n    'X-Goog-Upload-Offset': status.current\n  };\n  var body = blob.slice(startByte, endByte);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n  function handler(xhr, text) {\n    // TODO(andysoto): Verify the MD5 of each uploaded range:\n    // the 'x-range-md5' header comes back with status code 308 responses.\n    // We'll only be able to bail out though, because you can't re-upload a\n    // range that you previously uploaded.\n    var uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n    var newCurrent = status.current + bytesToUpload;\n    var size = blob.size();\n    var metadata;\n    if (uploadStatus === 'final') {\n      metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n    } else {\n      metadata = null;\n    }\n    return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);\n  }\n  var method = 'POST';\n  var timeout = authWrapper.maxUploadRetryTime();\n  var requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.progressCallback = opt_progressCallback || null;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}","map":{"version":3,"mappings":"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","names":["array","FbsBlob","errorsExports","MetadataUtils","object","RequestInfo","type","UrlUtils","cndn","unknown","authWrapper","mappings","xhr","text","metadata","fromResourceString","handlerCheck","handler","location","err","newErr","getStatus","unauthenticated","quotaExceeded","bucket","unauthorized","path","setServerResponseProp","serverResponseProp","errorHandler","shared","sharedErrorHandler","objectNotFound","urlPart","fullServerUrl","url","makeNormalUrl","method","timeout","maxOperationRetryTime","requestInfo","metadataHandler","objectErrorHandler","body","toResourceString","headers","successCodes","blob","opt_metadata","clone","size","determineContentType_","bucketOnlyServerUrl","str","i","Math","random","toString","slice","boundary","genBoundary","metadataForUpload_","metadataString","preBlobPart","postBlobPart","getBlob","cannotSliceBlob","urlParams","name","makeUploadUrl","maxUploadRetryTime","uploadData","current","total","finalized","opt_allowed","status","getResponseHeader","e","allowed","contains","checkResumeHeader_","isString","sizeString","parseInt","isNaN","ResumableUploadStatus","resumableUploadChunkSize","chunkSize","opt_status","opt_progressCallback","serverFileWrongSize","bytesLeft","bytesToUpload","min","startByte","endByte","uploadCommand","uploadStatus","newCurrent","progressCallback"],"sources":["../src/implementation/requests.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines methods for interacting with the network.\n */\n\nimport { Metadata } from '../metadata';\n\nimport * as array from './array';\nimport { AuthWrapper } from './authwrapper';\nimport { FbsBlob } from './blob';\nimport * as errorsExports from './error';\nimport { FirebaseStorageError } from './error';\nimport { errors } from './error';\nimport { Location } from './location';\nimport * as MetadataUtils from './metadata';\nimport * as object from './object';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport { XhrIo } from './xhrio';\n\n/**\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\n */\nexport function handlerCheck(cndn: boolean) {\n  if (!cndn) {\n    throw errorsExports.unknown();\n  }\n}\n\nexport function metadataHandler(\n  authWrapper: AuthWrapper,\n  mappings: MetadataUtils.Mappings\n): (p1: XhrIo, p2: string) => Metadata {\n  function handler(xhr: XhrIo, text: string): Metadata {\n    let metadata = MetadataUtils.fromResourceString(\n      authWrapper,\n      text,\n      mappings\n    );\n    handlerCheck(metadata !== null);\n    return metadata as Metadata;\n  }\n  return handler;\n}\n\nexport function sharedErrorHandler(\n  location: Location\n): (p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  function errorHandler(\n    xhr: XhrIo,\n    err: FirebaseStorageError\n  ): FirebaseStorageError {\n    let newErr;\n    if (xhr.getStatus() === 401) {\n      newErr = errorsExports.unauthenticated();\n    } else {\n      if (xhr.getStatus() === 402) {\n        newErr = errorsExports.quotaExceeded(location.bucket);\n      } else {\n        if (xhr.getStatus() === 403) {\n          newErr = errorsExports.unauthorized(location.path);\n        } else {\n          newErr = err;\n        }\n      }\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function objectErrorHandler(\n  location: Location\n): (p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  let shared = sharedErrorHandler(location);\n\n  function errorHandler(\n    xhr: XhrIo,\n    err: FirebaseStorageError\n  ): FirebaseStorageError {\n    let newErr = shared(xhr, err);\n    if (xhr.getStatus() === 404) {\n      newErr = errorsExports.objectNotFound(location.path);\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function getMetadata(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings\n): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'GET';\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function updateMetadata(\n  authWrapper: AuthWrapper,\n  location: Location,\n  metadata: Metadata,\n  mappings: MetadataUtils.Mappings\n): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'PATCH';\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let headers = { 'Content-Type': 'application/json; charset=utf-8' };\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function deleteObject(\n  authWrapper: AuthWrapper,\n  location: Location\n): RequestInfo<void> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'DELETE';\n  let timeout = authWrapper.maxOperationRetryTime();\n\n  function handler(xhr: XhrIo, text: string) {}\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.successCodes = [200, 204];\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function determineContentType_(\n  metadata: Metadata | null,\n  blob: FbsBlob | null\n): string {\n  return (\n    (metadata && metadata['contentType']) ||\n    (blob && blob.type()) ||\n    'application/octet-stream'\n  );\n}\n\nexport function metadataForUpload_(\n  location: Location,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): Metadata {\n  let metadata = object.clone<Metadata>(opt_metadata);\n  metadata['fullPath'] = location.path;\n  metadata['size'] = blob.size();\n  if (!metadata['contentType']) {\n    metadata['contentType'] = determineContentType_(null, blob);\n  }\n  return metadata;\n}\n\nexport function multipartUpload(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): RequestInfo<Metadata> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let headers: { [prop: string]: string } = {\n    'X-Goog-Upload-Protocol': 'multipart'\n  };\n\n  function genBoundary() {\n    let str = '';\n    for (let i = 0; i < 2; i++) {\n      str =\n        str +\n        Math.random()\n          .toString()\n          .slice(2);\n    }\n    return str;\n  }\n  let boundary = genBoundary();\n  headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let metadataString = MetadataUtils.toResourceString(metadata, mappings);\n  let preBlobPart =\n    '--' +\n    boundary +\n    '\\r\\n' +\n    'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' +\n    metadataString +\n    '\\r\\n--' +\n    boundary +\n    '\\r\\n' +\n    'Content-Type: ' +\n    metadata['contentType'] +\n    '\\r\\n\\r\\n';\n  let postBlobPart = '\\r\\n--' + boundary + '--';\n  let body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n  let urlParams = { name: metadata['fullPath'] };\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(\n    url,\n    method,\n    metadataHandler(authWrapper, mappings),\n    timeout\n  );\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n * @struct\n */\nexport class ResumableUploadStatus {\n  finalized: boolean;\n  metadata: Metadata | null;\n\n  constructor(\n    public current: number,\n    public total: number,\n    finalized?: boolean,\n    metadata?: Metadata | null\n  ) {\n    this.finalized = !!finalized;\n    this.metadata = metadata || null;\n  }\n}\n\nexport function checkResumeHeader_(xhr: XhrIo, opt_allowed?: string[]): string {\n  let status;\n  try {\n    status = xhr.getResponseHeader('X-Goog-Upload-Status');\n  } catch (e) {\n    handlerCheck(false);\n  }\n  let allowed = opt_allowed || ['active'];\n  handlerCheck(array.contains(allowed, status));\n  return status as string;\n}\n\nexport function createResumableUpload(\n  authWrapper: AuthWrapper,\n  location: Location,\n  mappings: MetadataUtils.Mappings,\n  blob: FbsBlob,\n  opt_metadata?: Metadata | null\n): RequestInfo<string> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let urlParams = { name: metadata['fullPath'] };\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let headers = {\n    'X-Goog-Upload-Protocol': 'resumable',\n    'X-Goog-Upload-Command': 'start',\n    'X-Goog-Upload-Header-Content-Length': blob.size(),\n    'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let timeout = authWrapper.maxUploadRetryTime();\n\n  function handler(xhr: XhrIo, text: string): string {\n    checkResumeHeader_(xhr);\n    let url;\n    try {\n      url = xhr.getResponseHeader('X-Goog-Upload-URL');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    handlerCheck(type.isString(url));\n    return url as string;\n  }\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nexport function getResumableUploadStatus(\n  authWrapper: AuthWrapper,\n  location: Location,\n  url: string,\n  blob: FbsBlob\n): RequestInfo<ResumableUploadStatus> {\n  let headers = { 'X-Goog-Upload-Command': 'query' };\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    let status = checkResumeHeader_(xhr, ['active', 'final']);\n    let sizeString;\n    try {\n      sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    let size = parseInt(sizeString, 10);\n    handlerCheck(!isNaN(size));\n    return new ResumableUploadStatus(size, blob.size(), status === 'final');\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nexport const resumableUploadChunkSize: number = 256 * 1024;\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param opt_status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nexport function continueResumableUpload(\n  location: Location,\n  authWrapper: AuthWrapper,\n  url: string,\n  blob: FbsBlob,\n  chunkSize: number,\n  mappings: MetadataUtils.Mappings,\n  opt_status?: ResumableUploadStatus | null,\n  opt_progressCallback?: ((p1: number, p2: number) => void) | null\n): RequestInfo<ResumableUploadStatus> {\n  // TODO(andysoto): standardize on internal asserts\n  // assert(!(opt_status && opt_status.finalized));\n  let status = new ResumableUploadStatus(0, 0);\n  if (opt_status) {\n    status.current = opt_status.current;\n    status.total = opt_status.total;\n  } else {\n    status.current = 0;\n    status.total = blob.size();\n  }\n  if (blob.size() !== status.total) {\n    throw errorsExports.serverFileWrongSize();\n  }\n  let bytesLeft = status.total - status.current;\n  let bytesToUpload = bytesLeft;\n  if (chunkSize > 0) {\n    bytesToUpload = Math.min(bytesToUpload, chunkSize);\n  }\n  let startByte = status.current;\n  let endByte = startByte + bytesToUpload;\n  let uploadCommand =\n    bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n  let headers = {\n    'X-Goog-Upload-Command': uploadCommand,\n    'X-Goog-Upload-Offset': status.current\n  };\n  let body = blob.slice(startByte, endByte);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    // TODO(andysoto): Verify the MD5 of each uploaded range:\n    // the 'x-range-md5' header comes back with status code 308 responses.\n    // We'll only be able to bail out though, because you can't re-upload a\n    // range that you previously uploaded.\n    let uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n    let newCurrent = status.current + bytesToUpload;\n    let size = blob.size();\n    let metadata;\n    if (uploadStatus === 'final') {\n      metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n    } else {\n      metadata = null;\n    }\n    return new ResumableUploadStatus(\n      newCurrent,\n      size,\n      uploadStatus === 'final',\n      metadata\n    );\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.progressCallback = opt_progressCallback || null;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n"]},"metadata":{},"sourceType":"module"}