{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Path_1 = require(\"./Path\");\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"./util\");\nvar util_3 = require(\"@firebase/util\");\nvar util_4 = require(\"@firebase/util\");\n/**\n * True for invalid Firebase keys\n * @type {RegExp}\n * @private\n */\nexports.INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\n/**\n * True for invalid Firebase paths.\n * Allows '/' in paths.\n * @type {RegExp}\n * @private\n */\nexports.INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\n/**\n * Maximum number of characters to allow in leaf value\n * @type {number}\n * @private\n */\nexports.MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\n/**\n * @param {*} key\n * @return {boolean}\n */\nexports.isValidKey = function (key) {\n  return typeof key === 'string' && key.length !== 0 && !exports.INVALID_KEY_REGEX_.test(key);\n};\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexports.isValidPathString = function (pathString) {\n  return typeof pathString === 'string' && pathString.length !== 0 && !exports.INVALID_PATH_REGEX_.test(pathString);\n};\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexports.isValidRootPathString = function (pathString) {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n  return exports.isValidPathString(pathString);\n};\n/**\n * @param {*} priority\n * @return {boolean}\n */\nexports.isValidPriority = function (priority) {\n  return priority === null || typeof priority === 'string' || typeof priority === 'number' && !util_2.isInvalidJSONNumber(priority) || priority && typeof priority === 'object' && util_1.contains(priority, '.sv');\n};\n/**\n * Pre-validate a datum passed as an argument to Firebase function.\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexports.validateFirebaseDataArg = function (fnName, argumentNumber, data, path, optional) {\n  if (optional && data === undefined) return;\n  exports.validateFirebaseData(util_3.errorPrefix(fnName, argumentNumber, optional), data, path);\n};\n/**\n * Validate a data object client-side before sending to server.\n *\n * @param {string} errorPrefix\n * @param {*} data\n * @param {!Path|!ValidationPath} path_\n */\nexports.validateFirebaseData = function (errorPrefix, data, path_) {\n  var path = path_ instanceof Path_1.Path ? new Path_1.ValidationPath(path_, errorPrefix) : path_;\n  if (data === undefined) {\n    throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());\n  }\n  if (typeof data === 'function') {\n    throw new Error(errorPrefix + 'contains a function ' + path.toErrorString() + ' with contents = ' + data.toString());\n  }\n  if (util_2.isInvalidJSONNumber(data)) {\n    throw new Error(errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString());\n  }\n  // Check max leaf size, but try to avoid the utf8 conversion if we can.\n  if (typeof data === 'string' && data.length > exports.MAX_LEAF_SIZE_ / 3 && util_4.stringLength(data) > exports.MAX_LEAF_SIZE_) {\n    throw new Error(errorPrefix + 'contains a string greater than ' + exports.MAX_LEAF_SIZE_ + ' utf8 bytes ' + path.toErrorString() + \" ('\" + data.substring(0, 50) + \"...')\");\n  }\n  // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n  // to save extra walking of large objects.\n  if (data && typeof data === 'object') {\n    var hasDotValue_1 = false,\n      hasActualChild_1 = false;\n    util_1.forEach(data, function (key, value) {\n      if (key === '.value') {\n        hasDotValue_1 = true;\n      } else if (key !== '.priority' && key !== '.sv') {\n        hasActualChild_1 = true;\n        if (!exports.isValidKey(key)) {\n          throw new Error(errorPrefix + ' contains an invalid key (' + key + ') ' + path.toErrorString() + '.  Keys must be non-empty strings ' + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n        }\n      }\n      path.push(key);\n      exports.validateFirebaseData(errorPrefix, value, path);\n      path.pop();\n    });\n    if (hasDotValue_1 && hasActualChild_1) {\n      throw new Error(errorPrefix + ' contains \".value\" child ' + path.toErrorString() + ' in addition to actual children.');\n    }\n  }\n};\n/**\n * Pre-validate paths passed in the firebase function.\n *\n * @param {string} errorPrefix\n * @param {Array<!Path>} mergePaths\n */\nexports.validateFirebaseMergePaths = function (errorPrefix, mergePaths) {\n  var i, curPath;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    var keys = curPath.slice();\n    for (var j = 0; j < keys.length; j++) {\n      if (keys[j] === '.priority' && j === keys.length - 1) {\n        // .priority is OK\n      } else if (!exports.isValidKey(keys[j])) {\n        throw new Error(errorPrefix + 'contains an invalid key (' + keys[j] + ') in path ' + curPath.toString() + '. Keys must be non-empty strings ' + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n      }\n    }\n  }\n  // Check that update keys are not descendants of each other.\n  // We rely on the property that sorting guarantees that ancestors come\n  // right before descendants.\n  mergePaths.sort(Path_1.Path.comparePaths);\n  var prevPath = null;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    if (prevPath !== null && prevPath.contains(curPath)) {\n      throw new Error(errorPrefix + 'contains a path ' + prevPath.toString() + ' that is ancestor of another path ' + curPath.toString());\n    }\n    prevPath = curPath;\n  }\n};\n/**\n * pre-validate an object passed as an argument to firebase function (\n * must be an object - e.g. for firebase.update()).\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexports.validateFirebaseMergeDataArg = function (fnName, argumentNumber, data, path, optional) {\n  if (optional && data === undefined) return;\n  var errorPrefix = util_3.errorPrefix(fnName, argumentNumber, optional);\n  if (!(data && typeof data === 'object') || Array.isArray(data)) {\n    throw new Error(errorPrefix + ' must be an object containing the children to replace.');\n  }\n  var mergePaths = [];\n  util_1.forEach(data, function (key, value) {\n    var curPath = new Path_1.Path(key);\n    exports.validateFirebaseData(errorPrefix, value, path.child(curPath));\n    if (curPath.getBack() === '.priority') {\n      if (!exports.isValidPriority(value)) {\n        throw new Error(errorPrefix + \"contains an invalid value for '\" + curPath.toString() + \"', which must be a valid \" + 'Firebase priority (a string, finite number, server value, or null).');\n      }\n    }\n    mergePaths.push(curPath);\n  });\n  exports.validateFirebaseMergePaths(errorPrefix, mergePaths);\n};\nexports.validatePriority = function (fnName, argumentNumber, priority, optional) {\n  if (optional && priority === undefined) return;\n  if (util_2.isInvalidJSONNumber(priority)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'is ' + priority.toString() + ', but must be a valid Firebase priority (a string, finite number, ' + 'server value, or null).');\n  // Special case to allow importing data with a .sv.\n  if (!exports.isValidPriority(priority)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid Firebase priority ' + '(a string, finite number, server value, or null).');\n};\nexports.validateEventType = function (fnName, argumentNumber, eventType, optional) {\n  if (optional && eventType === undefined) return;\n  switch (eventType) {\n    case 'value':\n    case 'child_added':\n    case 'child_removed':\n    case 'child_changed':\n    case 'child_moved':\n      break;\n    default:\n      throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' + '\"child_changed\", or \"child_moved\".');\n  }\n};\nexports.validateKey = function (fnName, argumentNumber, key, optional) {\n  if (optional && key === undefined) return;\n  if (!exports.isValidKey(key)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'was an invalid key = \"' + key + '\".  Firebase keys must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").');\n};\nexports.validatePathString = function (fnName, argumentNumber, pathString, optional) {\n  if (optional && pathString === undefined) return;\n  if (!exports.isValidPathString(pathString)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'was an invalid path = \"' + pathString + '\". Paths must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"');\n};\nexports.validateRootPathString = function (fnName, argumentNumber, pathString, optional) {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n  exports.validatePathString(fnName, argumentNumber, pathString, optional);\n};\nexports.validateWritablePath = function (fnName, path) {\n  if (path.getFront() === '.info') {\n    throw new Error(fnName + \" failed = Can't modify data under /.info/\");\n  }\n};\nexports.validateUrl = function (fnName, argumentNumber, parsedUrl) {\n  // TODO = Validate server better.\n  var pathString = parsedUrl.path.toString();\n  if (!(typeof parsedUrl.repoInfo.host === 'string') || parsedUrl.repoInfo.host.length === 0 || !exports.isValidKey(parsedUrl.repoInfo.namespace) || pathString.length !== 0 && !exports.isValidRootPathString(pathString)) {\n    throw new Error(util_3.errorPrefix(fnName, argumentNumber, false) + 'must be a valid firebase URL and ' + 'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".');\n  }\n};\nexports.validateCredential = function (fnName, argumentNumber, cred, optional) {\n  if (optional && cred === undefined) return;\n  if (!(typeof cred === 'string')) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid credential (a string).');\n};\nexports.validateBoolean = function (fnName, argumentNumber, bool, optional) {\n  if (optional && bool === undefined) return;\n  if (typeof bool !== 'boolean') throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a boolean.');\n};\nexports.validateString = function (fnName, argumentNumber, string, optional) {\n  if (optional && string === undefined) return;\n  if (!(typeof string === 'string')) {\n    throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid string.');\n  }\n};\nexports.validateObject = function (fnName, argumentNumber, obj, optional) {\n  if (optional && obj === undefined) return;\n  if (!(obj && typeof obj === 'object') || obj === null) {\n    throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid object.');\n  }\n};\nexports.validateObjectContainsKey = function (fnName, argumentNumber, obj, key, optional, opt_type) {\n  var objectContainsKey = obj && typeof obj === 'object' && util_1.contains(obj, key);\n  if (!objectContainsKey) {\n    if (optional) {\n      return;\n    } else {\n      throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must contain the key \"' + key + '\"');\n    }\n  }\n  if (opt_type) {\n    var val = util_1.safeGet(obj, key);\n    if (opt_type === 'number' && !(typeof val === 'number') || opt_type === 'string' && !(typeof val === 'string') || opt_type === 'boolean' && !(typeof val === 'boolean') || opt_type === 'function' && !(typeof val === 'function') || opt_type === 'object' && !(typeof val === 'object') && val) {\n      if (optional) {\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'contains invalid value for key \"' + key + '\" (must be of type \"' + opt_type + '\")');\n      } else {\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must contain the key \"' + key + '\" with type \"' + opt_type + '\"');\n      }\n    }\n  }\n};","map":{"version":3,"mappings":"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","names":["exports","key","length","test","pathString","replace","priority","util_2","util_1","fnName","argumentNumber","data","path","optional","undefined","util_3","errorPrefix","path_","Path_1","Error","toErrorString","toString","util_4","substring","hasDotValue_1","hasActualChild_1","value","push","pop","mergePaths","i","curPath","keys","slice","j","sort","comparePaths","prevPath","contains","Array","isArray","child","getBack","eventType","getFront","parsedUrl","repoInfo","host","namespace","cred","bool","string","obj","opt_type","objectContainsKey","val"],"sources":["../src/core/util/validation.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path, ValidationPath } from './Path';\nimport { forEach, contains, safeGet } from '@firebase/util';\nimport { isInvalidJSONNumber } from './util';\nimport { errorPrefix as errorPrefixFxn } from '@firebase/util';\nimport { stringLength } from '@firebase/util';\nimport { RepoInfo } from '../RepoInfo';\n\n/**\n * True for invalid Firebase keys\n * @type {RegExp}\n * @private\n */\nexport const INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\n\n/**\n * True for invalid Firebase paths.\n * Allows '/' in paths.\n * @type {RegExp}\n * @private\n */\nexport const INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\n\n/**\n * Maximum number of characters to allow in leaf value\n * @type {number}\n * @private\n */\nexport const MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\n\n/**\n * @param {*} key\n * @return {boolean}\n */\nexport const isValidKey = function(key: any): boolean {\n  return (\n    typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key)\n  );\n};\n\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexport const isValidPathString = function(pathString: string): boolean {\n  return (\n    typeof pathString === 'string' &&\n    pathString.length !== 0 &&\n    !INVALID_PATH_REGEX_.test(pathString)\n  );\n};\n\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexport const isValidRootPathString = function(pathString: string): boolean {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  return isValidPathString(pathString);\n};\n\n/**\n * @param {*} priority\n * @return {boolean}\n */\nexport const isValidPriority = function(priority: any): boolean {\n  return (\n    priority === null ||\n    typeof priority === 'string' ||\n    (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||\n    (priority && typeof priority === 'object' && contains(priority, '.sv'))\n  );\n};\n\n/**\n * Pre-validate a datum passed as an argument to Firebase function.\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexport const validateFirebaseDataArg = function(\n  fnName: string,\n  argumentNumber: number,\n  data: any,\n  path: Path,\n  optional: boolean\n) {\n  if (optional && data === undefined) return;\n\n  validateFirebaseData(\n    errorPrefixFxn(fnName, argumentNumber, optional),\n    data,\n    path\n  );\n};\n\n/**\n * Validate a data object client-side before sending to server.\n *\n * @param {string} errorPrefix\n * @param {*} data\n * @param {!Path|!ValidationPath} path_\n */\nexport const validateFirebaseData = function(\n  errorPrefix: string,\n  data: any,\n  path_: Path | ValidationPath\n) {\n  const path =\n    path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;\n\n  if (data === undefined) {\n    throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());\n  }\n  if (typeof data === 'function') {\n    throw new Error(\n      errorPrefix +\n        'contains a function ' +\n        path.toErrorString() +\n        ' with contents = ' +\n        data.toString()\n    );\n  }\n  if (isInvalidJSONNumber(data)) {\n    throw new Error(\n      errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString()\n    );\n  }\n\n  // Check max leaf size, but try to avoid the utf8 conversion if we can.\n  if (\n    typeof data === 'string' &&\n    data.length > MAX_LEAF_SIZE_ / 3 &&\n    stringLength(data) > MAX_LEAF_SIZE_\n  ) {\n    throw new Error(\n      errorPrefix +\n        'contains a string greater than ' +\n        MAX_LEAF_SIZE_ +\n        ' utf8 bytes ' +\n        path.toErrorString() +\n        \" ('\" +\n        data.substring(0, 50) +\n        \"...')\"\n    );\n  }\n\n  // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n  // to save extra walking of large objects.\n  if (data && typeof data === 'object') {\n    let hasDotValue = false,\n      hasActualChild = false;\n    forEach(data, function(key: string, value: any) {\n      if (key === '.value') {\n        hasDotValue = true;\n      } else if (key !== '.priority' && key !== '.sv') {\n        hasActualChild = true;\n        if (!isValidKey(key)) {\n          throw new Error(\n            errorPrefix +\n              ' contains an invalid key (' +\n              key +\n              ') ' +\n              path.toErrorString() +\n              '.  Keys must be non-empty strings ' +\n              'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"'\n          );\n        }\n      }\n\n      path.push(key);\n      validateFirebaseData(errorPrefix, value, path);\n      path.pop();\n    });\n\n    if (hasDotValue && hasActualChild) {\n      throw new Error(\n        errorPrefix +\n          ' contains \".value\" child ' +\n          path.toErrorString() +\n          ' in addition to actual children.'\n      );\n    }\n  }\n};\n\n/**\n * Pre-validate paths passed in the firebase function.\n *\n * @param {string} errorPrefix\n * @param {Array<!Path>} mergePaths\n */\nexport const validateFirebaseMergePaths = function(\n  errorPrefix: string,\n  mergePaths: Path[]\n) {\n  let i, curPath;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    const keys = curPath.slice();\n    for (let j = 0; j < keys.length; j++) {\n      if (keys[j] === '.priority' && j === keys.length - 1) {\n        // .priority is OK\n      } else if (!isValidKey(keys[j])) {\n        throw new Error(\n          errorPrefix +\n            'contains an invalid key (' +\n            keys[j] +\n            ') in path ' +\n            curPath.toString() +\n            '. Keys must be non-empty strings ' +\n            'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"'\n        );\n      }\n    }\n  }\n\n  // Check that update keys are not descendants of each other.\n  // We rely on the property that sorting guarantees that ancestors come\n  // right before descendants.\n  mergePaths.sort(Path.comparePaths);\n  let prevPath: Path | null = null;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    if (prevPath !== null && prevPath.contains(curPath)) {\n      throw new Error(\n        errorPrefix +\n          'contains a path ' +\n          prevPath.toString() +\n          ' that is ancestor of another path ' +\n          curPath.toString()\n      );\n    }\n    prevPath = curPath;\n  }\n};\n\n/**\n * pre-validate an object passed as an argument to firebase function (\n * must be an object - e.g. for firebase.update()).\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexport const validateFirebaseMergeDataArg = function(\n  fnName: string,\n  argumentNumber: number,\n  data: any,\n  path: Path,\n  optional: boolean\n) {\n  if (optional && data === undefined) return;\n\n  const errorPrefix = errorPrefixFxn(fnName, argumentNumber, optional);\n\n  if (!(data && typeof data === 'object') || Array.isArray(data)) {\n    throw new Error(\n      errorPrefix + ' must be an object containing the children to replace.'\n    );\n  }\n\n  const mergePaths: Path[] = [];\n  forEach(data, function(key: string, value: any) {\n    const curPath = new Path(key);\n    validateFirebaseData(errorPrefix, value, path.child(curPath));\n    if (curPath.getBack() === '.priority') {\n      if (!isValidPriority(value)) {\n        throw new Error(\n          errorPrefix +\n            \"contains an invalid value for '\" +\n            curPath.toString() +\n            \"', which must be a valid \" +\n            'Firebase priority (a string, finite number, server value, or null).'\n        );\n      }\n    }\n    mergePaths.push(curPath);\n  });\n  validateFirebaseMergePaths(errorPrefix, mergePaths);\n};\n\nexport const validatePriority = function(\n  fnName: string,\n  argumentNumber: number,\n  priority: any,\n  optional: boolean\n) {\n  if (optional && priority === undefined) return;\n  if (isInvalidJSONNumber(priority))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'is ' +\n        priority.toString() +\n        ', but must be a valid Firebase priority (a string, finite number, ' +\n        'server value, or null).'\n    );\n  // Special case to allow importing data with a .sv.\n  if (!isValidPriority(priority))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid Firebase priority ' +\n        '(a string, finite number, server value, or null).'\n    );\n};\n\nexport const validateEventType = function(\n  fnName: string,\n  argumentNumber: number,\n  eventType: string,\n  optional: boolean\n) {\n  if (optional && eventType === undefined) return;\n\n  switch (eventType) {\n    case 'value':\n    case 'child_added':\n    case 'child_removed':\n    case 'child_changed':\n    case 'child_moved':\n      break;\n    default:\n      throw new Error(\n        errorPrefixFxn(fnName, argumentNumber, optional) +\n          'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' +\n          '\"child_changed\", or \"child_moved\".'\n      );\n  }\n};\n\nexport const validateKey = function(\n  fnName: string,\n  argumentNumber: number,\n  key: string,\n  optional: boolean\n) {\n  if (optional && key === undefined) return;\n  if (!isValidKey(key))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'was an invalid key = \"' +\n        key +\n        '\".  Firebase keys must be non-empty strings and ' +\n        'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").'\n    );\n};\n\nexport const validatePathString = function(\n  fnName: string,\n  argumentNumber: number,\n  pathString: string,\n  optional: boolean\n) {\n  if (optional && pathString === undefined) return;\n\n  if (!isValidPathString(pathString))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'was an invalid path = \"' +\n        pathString +\n        '\". Paths must be non-empty strings and ' +\n        'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"'\n    );\n};\n\nexport const validateRootPathString = function(\n  fnName: string,\n  argumentNumber: number,\n  pathString: string,\n  optional: boolean\n) {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  validatePathString(fnName, argumentNumber, pathString, optional);\n};\n\nexport const validateWritablePath = function(fnName: string, path: Path) {\n  if (path.getFront() === '.info') {\n    throw new Error(fnName + \" failed = Can't modify data under /.info/\");\n  }\n};\n\nexport const validateUrl = function(\n  fnName: string,\n  argumentNumber: number,\n  parsedUrl: { repoInfo: RepoInfo; path: Path }\n) {\n  // TODO = Validate server better.\n  const pathString = parsedUrl.path.toString();\n  if (\n    !(typeof parsedUrl.repoInfo.host === 'string') ||\n    parsedUrl.repoInfo.host.length === 0 ||\n    !isValidKey(parsedUrl.repoInfo.namespace) ||\n    (pathString.length !== 0 && !isValidRootPathString(pathString))\n  ) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, false) +\n        'must be a valid firebase URL and ' +\n        'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".'\n    );\n  }\n};\n\nexport const validateCredential = function(\n  fnName: string,\n  argumentNumber: number,\n  cred: any,\n  optional: boolean\n) {\n  if (optional && cred === undefined) return;\n  if (!(typeof cred === 'string'))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid credential (a string).'\n    );\n};\n\nexport const validateBoolean = function(\n  fnName: string,\n  argumentNumber: number,\n  bool: any,\n  optional: boolean\n) {\n  if (optional && bool === undefined) return;\n  if (typeof bool !== 'boolean')\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) + 'must be a boolean.'\n    );\n};\n\nexport const validateString = function(\n  fnName: string,\n  argumentNumber: number,\n  string: any,\n  optional: boolean\n) {\n  if (optional && string === undefined) return;\n  if (!(typeof string === 'string')) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid string.'\n    );\n  }\n};\n\nexport const validateObject = function(\n  fnName: string,\n  argumentNumber: number,\n  obj: any,\n  optional: boolean\n) {\n  if (optional && obj === undefined) return;\n  if (!(obj && typeof obj === 'object') || obj === null) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid object.'\n    );\n  }\n};\n\nexport const validateObjectContainsKey = function(\n  fnName: string,\n  argumentNumber: number,\n  obj: any,\n  key: string,\n  optional: boolean,\n  opt_type?: string\n) {\n  const objectContainsKey =\n    obj && typeof obj === 'object' && contains(obj, key);\n\n  if (!objectContainsKey) {\n    if (optional) {\n      return;\n    } else {\n      throw new Error(\n        errorPrefixFxn(fnName, argumentNumber, optional) +\n          'must contain the key \"' +\n          key +\n          '\"'\n      );\n    }\n  }\n\n  if (opt_type) {\n    const val = safeGet(obj, key);\n    if (\n      (opt_type === 'number' && !(typeof val === 'number')) ||\n      (opt_type === 'string' && !(typeof val === 'string')) ||\n      (opt_type === 'boolean' && !(typeof val === 'boolean')) ||\n      (opt_type === 'function' && !(typeof val === 'function')) ||\n      (opt_type === 'object' && !(typeof val === 'object') && val)\n    ) {\n      if (optional) {\n        throw new Error(\n          errorPrefixFxn(fnName, argumentNumber, optional) +\n            'contains invalid value for key \"' +\n            key +\n            '\" (must be of type \"' +\n            opt_type +\n            '\")'\n        );\n      } else {\n        throw new Error(\n          errorPrefixFxn(fnName, argumentNumber, optional) +\n            'must contain the key \"' +\n            key +\n            '\" with type \"' +\n            opt_type +\n            '\"'\n        );\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}