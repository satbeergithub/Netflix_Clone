{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar KeyIndex_1 = require(\"../core/snap/indexes/KeyIndex\");\nvar PriorityIndex_1 = require(\"../core/snap/indexes/PriorityIndex\");\nvar ValueIndex_1 = require(\"../core/snap/indexes/ValueIndex\");\nvar PathIndex_1 = require(\"../core/snap/indexes/PathIndex\");\nvar util_2 = require(\"../core/util/util\");\nvar Path_1 = require(\"../core/util/Path\");\nvar validation_1 = require(\"../core/util/validation\");\nvar util_3 = require(\"@firebase/util\");\nvar EventRegistration_1 = require(\"../core/view/EventRegistration\");\nvar util_4 = require(\"@firebase/util\");\nvar __referenceConstructor;\n/**\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\n *\n * Since every Firebase reference is a query, Firebase inherits from this object.\n */\nvar Query = /** @class */function () {\n  function Query(repo, path, queryParams_, orderByCalled_) {\n    this.repo = repo;\n    this.path = path;\n    this.queryParams_ = queryParams_;\n    this.orderByCalled_ = orderByCalled_;\n  }\n  Object.defineProperty(Query, \"__referenceConstructor\", {\n    get: function get() {\n      util_1.assert(__referenceConstructor, 'Reference.ts has not been loaded');\n      return __referenceConstructor;\n    },\n    set: function set(val) {\n      __referenceConstructor = val;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Validates start/end values for queries.\n   * @param {!QueryParams} params\n   * @private\n   */\n  Query.validateQueryEndpoints_ = function (params) {\n    var startNode = null;\n    var endNode = null;\n    if (params.hasStart()) {\n      startNode = params.getIndexStartValue();\n    }\n    if (params.hasEnd()) {\n      endNode = params.getIndexEndValue();\n    }\n    if (params.getIndex() === KeyIndex_1.KEY_INDEX) {\n      var tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' + 'startAt(), endAt(), or equalTo().';\n      var wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), endAt(),' + 'or equalTo() must be a string.';\n      if (params.hasStart()) {\n        var startName = params.getIndexStartName();\n        if (startName != util_2.MIN_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof startNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n      if (params.hasEnd()) {\n        var endName = params.getIndexEndName();\n        if (endName != util_2.MAX_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof endNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n    } else if (params.getIndex() === PriorityIndex_1.PRIORITY_INDEX) {\n      if (startNode != null && !validation_1.isValidPriority(startNode) || endNode != null && !validation_1.isValidPriority(endNode)) {\n        throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' + 'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');\n      }\n    } else {\n      util_1.assert(params.getIndex() instanceof PathIndex_1.PathIndex || params.getIndex() === ValueIndex_1.VALUE_INDEX, 'unknown index type.');\n      if (startNode != null && typeof startNode === 'object' || endNode != null && typeof endNode === 'object') {\n        throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' + 'an object.');\n      }\n    }\n  };\n  /**\n   * Validates that limit* has been called with the correct combination of parameters\n   * @param {!QueryParams} params\n   * @private\n   */\n  Query.validateLimit_ = function (params) {\n    if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {\n      throw new Error(\"Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.\");\n    }\n  };\n  /**\n   * Validates that no other order by call has been made\n   * @param {!string} fnName\n   * @private\n   */\n  Query.prototype.validateNoPreviousOrderByCall_ = function (fnName) {\n    if (this.orderByCalled_ === true) {\n      throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n    }\n  };\n  /**\n   * @return {!QueryParams}\n   */\n  Query.prototype.getQueryParams = function () {\n    return this.queryParams_;\n  };\n  /**\n   * @return {!Reference}\n   */\n  Query.prototype.getRef = function () {\n    util_3.validateArgCount('Query.ref', 0, 0, arguments.length);\n    // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\n    // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\n    // method gets called.\n    return new Query.__referenceConstructor(this.repo, this.path);\n  };\n  /**\n   * @param {!string} eventType\n   * @param {!function(DataSnapshot, string=)} callback\n   * @param {(function(Error)|Object)=} cancelCallbackOrContext\n   * @param {Object=} context\n   * @return {!function(DataSnapshot, string=)}\n   */\n  Query.prototype.on = function (eventType, callback, cancelCallbackOrContext, context) {\n    util_3.validateArgCount('Query.on', 2, 4, arguments.length);\n    validation_1.validateEventType('Query.on', 1, eventType, false);\n    util_3.validateCallback('Query.on', 2, callback, false);\n    var ret = Query.getCancelAndContextArgs_('Query.on', cancelCallbackOrContext, context);\n    if (eventType === 'value') {\n      this.onValueEvent(callback, ret.cancel, ret.context);\n    } else {\n      var callbacks = {};\n      callbacks[eventType] = callback;\n      this.onChildEvent(callbacks, ret.cancel, ret.context);\n    }\n    return callback;\n  };\n  /**\n   * @param {!function(!DataSnapshot)} callback\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  Query.prototype.onValueEvent = function (callback, cancelCallback, context) {\n    var container = new EventRegistration_1.ValueEventRegistration(callback, cancelCallback || null, context || null);\n    this.repo.addEventCallbackForQuery(this, container);\n  };\n  /**\n   * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  Query.prototype.onChildEvent = function (callbacks, cancelCallback, context) {\n    var container = new EventRegistration_1.ChildEventRegistration(callbacks, cancelCallback, context);\n    this.repo.addEventCallbackForQuery(this, container);\n  };\n  /**\n   * @param {string=} eventType\n   * @param {(function(!DataSnapshot, ?string=))=} callback\n   * @param {Object=} context\n   */\n  Query.prototype.off = function (eventType, callback, context) {\n    util_3.validateArgCount('Query.off', 0, 3, arguments.length);\n    validation_1.validateEventType('Query.off', 1, eventType, true);\n    util_3.validateCallback('Query.off', 2, callback, true);\n    util_3.validateContextObject('Query.off', 3, context, true);\n    var container = null;\n    var callbacks = null;\n    if (eventType === 'value') {\n      var valueCallback = callback || null;\n      container = new EventRegistration_1.ValueEventRegistration(valueCallback, null, context || null);\n    } else if (eventType) {\n      if (callback) {\n        callbacks = {};\n        callbacks[eventType] = callback;\n      }\n      container = new EventRegistration_1.ChildEventRegistration(callbacks, null, context || null);\n    }\n    this.repo.removeEventCallbackForQuery(this, container);\n  };\n  /**\n   * Attaches a listener, waits for the first event, and then removes the listener\n   * @param {!string} eventType\n   * @param {!function(!DataSnapshot, string=)} userCallback\n   * @param cancelOrContext\n   * @param context\n   * @return {!firebase.Promise}\n   */\n  Query.prototype.once = function (eventType, userCallback, cancelOrContext, context) {\n    var _this = this;\n    util_3.validateArgCount('Query.once', 1, 4, arguments.length);\n    validation_1.validateEventType('Query.once', 1, eventType, false);\n    util_3.validateCallback('Query.once', 2, userCallback, true);\n    var ret = Query.getCancelAndContextArgs_('Query.once', cancelOrContext, context);\n    // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\n    // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\n    // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\n    // against the Promise specification.\n    var firstCall = true;\n    var deferred = new util_4.Deferred();\n    // A dummy error handler in case a user wasn't expecting promises\n    deferred.promise.catch(function () {});\n    var onceCallback = function onceCallback(snapshot) {\n      // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\n      // triggers multiple events (e.g. child_added or child_changed).\n      if (firstCall) {\n        firstCall = false;\n        _this.off(eventType, onceCallback);\n        if (userCallback) {\n          userCallback.bind(ret.context)(snapshot);\n        }\n        deferred.resolve(snapshot);\n      }\n    };\n    this.on(eventType, onceCallback, /*cancel=*/function (err) {\n      _this.off(eventType, onceCallback);\n      if (ret.cancel) ret.cancel.bind(ret.context)(err);\n      deferred.reject(err);\n    });\n    return deferred.promise;\n  };\n  /**\n   * Set a limit and anchor it to the start of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  Query.prototype.limitToFirst = function (limit) {\n    util_3.validateArgCount('Query.limitToFirst', 1, 1, arguments.length);\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\n      throw new Error('Query.limitToFirst: First argument must be a positive integer.');\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, ' + 'limitToFirst, or limitToLast).');\n    }\n    return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);\n  };\n  /**\n   * Set a limit and anchor it to the end of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  Query.prototype.limitToLast = function (limit) {\n    util_3.validateArgCount('Query.limitToLast', 1, 1, arguments.length);\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\n      throw new Error('Query.limitToLast: First argument must be a positive integer.');\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error('Query.limitToLast: Limit was already set (by another call to limit, ' + 'limitToFirst, or limitToLast).');\n    }\n    return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit), this.orderByCalled_);\n  };\n  /**\n   * Given a child path, return a new query ordered by the specified grandchild path.\n   * @param {!string} path\n   * @return {!Query}\n   */\n  Query.prototype.orderByChild = function (path) {\n    util_3.validateArgCount('Query.orderByChild', 1, 1, arguments.length);\n    if (path === '$key') {\n      throw new Error('Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.');\n    } else if (path === '$priority') {\n      throw new Error('Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.');\n    } else if (path === '$value') {\n      throw new Error('Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.');\n    }\n    validation_1.validatePathString('Query.orderByChild', 1, path, false);\n    this.validateNoPreviousOrderByCall_('Query.orderByChild');\n    var parsedPath = new Path_1.Path(path);\n    if (parsedPath.isEmpty()) {\n      throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');\n    }\n    var index = new PathIndex_1.PathIndex(parsedPath);\n    var newParams = this.queryParams_.orderBy(index);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/true);\n  };\n  /**\n   * Return a new query ordered by the KeyIndex\n   * @return {!Query}\n   */\n  Query.prototype.orderByKey = function () {\n    util_3.validateArgCount('Query.orderByKey', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByKey');\n    var newParams = this.queryParams_.orderBy(KeyIndex_1.KEY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/true);\n  };\n  /**\n   * Return a new query ordered by the PriorityIndex\n   * @return {!Query}\n   */\n  Query.prototype.orderByPriority = function () {\n    util_3.validateArgCount('Query.orderByPriority', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByPriority');\n    var newParams = this.queryParams_.orderBy(PriorityIndex_1.PRIORITY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/true);\n  };\n  /**\n   * Return a new query ordered by the ValueIndex\n   * @return {!Query}\n   */\n  Query.prototype.orderByValue = function () {\n    util_3.validateArgCount('Query.orderByValue', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByValue');\n    var newParams = this.queryParams_.orderBy(ValueIndex_1.VALUE_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/true);\n  };\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  Query.prototype.startAt = function (value, name) {\n    if (value === void 0) {\n      value = null;\n    }\n    util_3.validateArgCount('Query.startAt', 0, 2, arguments.length);\n    validation_1.validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\n    validation_1.validateKey('Query.startAt', 2, name, true);\n    var newParams = this.queryParams_.startAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasStart()) {\n      throw new Error('Query.startAt: Starting point was already set (by another call to startAt ' + 'or equalTo).');\n    }\n    // Calling with no params tells us to start at the beginning.\n    if (value === undefined) {\n      value = null;\n      name = null;\n    }\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  };\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  Query.prototype.endAt = function (value, name) {\n    if (value === void 0) {\n      value = null;\n    }\n    util_3.validateArgCount('Query.endAt', 0, 2, arguments.length);\n    validation_1.validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\n    validation_1.validateKey('Query.endAt', 2, name, true);\n    var newParams = this.queryParams_.endAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasEnd()) {\n      throw new Error('Query.endAt: Ending point was already set (by another call to endAt or ' + 'equalTo).');\n    }\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  };\n  /**\n   * Load the selection of children with exactly the specified value, and, optionally,\n   * the specified name.\n   * @param {number|string|boolean|null} value\n   * @param {string=} name\n   * @return {!Query}\n   */\n  Query.prototype.equalTo = function (value, name) {\n    util_3.validateArgCount('Query.equalTo', 1, 2, arguments.length);\n    validation_1.validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\n    validation_1.validateKey('Query.equalTo', 2, name, true);\n    if (this.queryParams_.hasStart()) {\n      throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or ' + 'equalTo).');\n    }\n    if (this.queryParams_.hasEnd()) {\n      throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or ' + 'equalTo).');\n    }\n    return this.startAt(value, name).endAt(value, name);\n  };\n  /**\n   * @return {!string} URL for this location.\n   */\n  Query.prototype.toString = function () {\n    util_3.validateArgCount('Query.toString', 0, 0, arguments.length);\n    return this.repo.toString() + this.path.toUrlEncodedString();\n  };\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users.\n  Query.prototype.toJSON = function () {\n    // An optional spacer argument is unnecessary for a string.\n    util_3.validateArgCount('Query.toJSON', 0, 1, arguments.length);\n    return this.toString();\n  };\n  /**\n   * An object representation of the query parameters used by this Query.\n   * @return {!Object}\n   */\n  Query.prototype.queryObject = function () {\n    return this.queryParams_.getQueryObject();\n  };\n  /**\n   * @return {!string}\n   */\n  Query.prototype.queryIdentifier = function () {\n    var obj = this.queryObject();\n    var id = util_2.ObjectToUniqueKey(obj);\n    return id === '{}' ? 'default' : id;\n  };\n  /**\n   * Return true if this query and the provided query are equivalent; otherwise, return false.\n   * @param {Query} other\n   * @return {boolean}\n   */\n  Query.prototype.isEqual = function (other) {\n    util_3.validateArgCount('Query.isEqual', 1, 1, arguments.length);\n    if (!(other instanceof Query)) {\n      var error = 'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\n      throw new Error(error);\n    }\n    var sameRepo = this.repo === other.repo;\n    var samePath = this.path.equals(other.path);\n    var sameQueryIdentifier = this.queryIdentifier() === other.queryIdentifier();\n    return sameRepo && samePath && sameQueryIdentifier;\n  };\n  /**\n   * Helper used by .on and .once to extract the context and or cancel arguments.\n   * @param {!string} fnName The function name (on or once)\n   * @param {(function(Error)|Object)=} cancelOrContext\n   * @param {Object=} context\n   * @return {{cancel: ?function(Error), context: ?Object}}\n   * @private\n   */\n  Query.getCancelAndContextArgs_ = function (fnName, cancelOrContext, context) {\n    var ret = {\n      cancel: null,\n      context: null\n    };\n    if (cancelOrContext && context) {\n      ret.cancel = cancelOrContext;\n      util_3.validateCallback(fnName, 3, ret.cancel, true);\n      ret.context = context;\n      util_3.validateContextObject(fnName, 4, ret.context, true);\n    } else if (cancelOrContext) {\n      // we have either a cancel callback or a context.\n      if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {\n        // it's a context!\n        ret.context = cancelOrContext;\n      } else if (typeof cancelOrContext === 'function') {\n        ret.cancel = cancelOrContext;\n      } else {\n        throw new Error(util_3.errorPrefix(fnName, 3, true) + ' must either be a cancel callback or a context object.');\n      }\n    }\n    return ret;\n  };\n  Object.defineProperty(Query.prototype, \"ref\", {\n    get: function get() {\n      return this.getRef();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Query;\n}();\nexports.Query = Query;","map":{"version":3,"mappings":"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","names":["__referenceConstructor","repo","path","queryParams_","orderByCalled_","Object","Query","util_1","val","params","startNode","endNode","hasStart","getIndexStartValue","hasEnd","getIndexEndValue","getIndex","KeyIndex_1","tooManyArgsError","wrongArgTypeError","startName","getIndexStartName","util_2","Error","endName","getIndexEndName","PriorityIndex_1","validation_1","PathIndex_1","ValueIndex_1","hasLimit","hasAnchoredLimit","fnName","util_3","arguments","length","eventType","callback","cancelCallbackOrContext","context","ret","getCancelAndContextArgs_","onValueEvent","cancel","callbacks","onChildEvent","cancelCallback","container","EventRegistration_1","addEventCallbackForQuery","valueCallback","removeEventCallbackForQuery","userCallback","cancelOrContext","firstCall","deferred","util_4","promise","catch","onceCallback","snapshot","_this","off","bind","resolve","on","err","reject","limit","Math","floor","limitToFirst","limitToLast","validateNoPreviousOrderByCall_","parsedPath","Path_1","isEmpty","index","newParams","orderBy","validateQueryEndpoints_","value","name","startAt","validateLimit_","undefined","endAt","toString","toUrlEncodedString","getQueryObject","obj","queryObject","id","other","error","sameRepo","samePath","equals","sameQueryIdentifier","queryIdentifier","getRef","exports"],"sources":["../src/api/Query.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { KEY_INDEX } from '../core/snap/indexes/KeyIndex';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { VALUE_INDEX } from '../core/snap/indexes/ValueIndex';\nimport { PathIndex } from '../core/snap/indexes/PathIndex';\nimport { MIN_NAME, MAX_NAME, ObjectToUniqueKey } from '../core/util/util';\nimport { Path } from '../core/util/Path';\nimport {\n  isValidPriority,\n  validateEventType,\n  validatePathString,\n  validateFirebaseDataArg,\n  validateKey\n} from '../core/util/validation';\nimport {\n  errorPrefix,\n  validateArgCount,\n  validateCallback,\n  validateContextObject\n} from '@firebase/util';\nimport {\n  ValueEventRegistration,\n  ChildEventRegistration,\n  EventRegistration\n} from '../core/view/EventRegistration';\nimport { Deferred } from '@firebase/util';\nimport { Repo } from '../core/Repo';\nimport { QueryParams } from '../core/view/QueryParams';\nimport { Reference } from './Reference';\nimport { DataSnapshot } from './DataSnapshot';\n\nlet __referenceConstructor: new (repo: Repo, path: Path) => Query;\n\nexport interface SnapshotCallback {\n  (a: DataSnapshot, b?: string): any;\n}\n\n/**\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\n *\n * Since every Firebase reference is a query, Firebase inherits from this object.\n */\nexport class Query {\n  static set __referenceConstructor(val) {\n    __referenceConstructor = val;\n  }\n\n  static get __referenceConstructor() {\n    assert(__referenceConstructor, 'Reference.ts has not been loaded');\n    return __referenceConstructor;\n  }\n\n  constructor(\n    public repo: Repo,\n    public path: Path,\n    private queryParams_: QueryParams,\n    private orderByCalled_: boolean\n  ) {}\n\n  /**\n   * Validates start/end values for queries.\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateQueryEndpoints_(params: QueryParams) {\n    let startNode = null;\n    let endNode = null;\n    if (params.hasStart()) {\n      startNode = params.getIndexStartValue();\n    }\n    if (params.hasEnd()) {\n      endNode = params.getIndexEndValue();\n    }\n\n    if (params.getIndex() === KEY_INDEX) {\n      const tooManyArgsError =\n        'Query: When ordering by key, you may only pass one argument to ' +\n        'startAt(), endAt(), or equalTo().';\n      const wrongArgTypeError =\n        'Query: When ordering by key, the argument passed to startAt(), endAt(),' +\n        'or equalTo() must be a string.';\n      if (params.hasStart()) {\n        const startName = params.getIndexStartName();\n        if (startName != MIN_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof startNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n      if (params.hasEnd()) {\n        const endName = params.getIndexEndName();\n        if (endName != MAX_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof endNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n    } else if (params.getIndex() === PRIORITY_INDEX) {\n      if (\n        (startNode != null && !isValidPriority(startNode)) ||\n        (endNode != null && !isValidPriority(endNode))\n      ) {\n        throw new Error(\n          'Query: When ordering by priority, the first argument passed to startAt(), ' +\n            'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).'\n        );\n      }\n    } else {\n      assert(\n        params.getIndex() instanceof PathIndex ||\n          params.getIndex() === VALUE_INDEX,\n        'unknown index type.'\n      );\n      if (\n        (startNode != null && typeof startNode === 'object') ||\n        (endNode != null && typeof endNode === 'object')\n      ) {\n        throw new Error(\n          'Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +\n            'an object.'\n        );\n      }\n    }\n  }\n\n  /**\n   * Validates that limit* has been called with the correct combination of parameters\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateLimit_(params: QueryParams) {\n    if (\n      params.hasStart() &&\n      params.hasEnd() &&\n      params.hasLimit() &&\n      !params.hasAnchoredLimit()\n    ) {\n      throw new Error(\n        \"Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.\"\n      );\n    }\n  }\n\n  /**\n   * Validates that no other order by call has been made\n   * @param {!string} fnName\n   * @private\n   */\n  private validateNoPreviousOrderByCall_(fnName: string) {\n    if (this.orderByCalled_ === true) {\n      throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n    }\n  }\n\n  /**\n   * @return {!QueryParams}\n   */\n  getQueryParams(): QueryParams {\n    return this.queryParams_;\n  }\n\n  /**\n   * @return {!Reference}\n   */\n  getRef(): Reference {\n    validateArgCount('Query.ref', 0, 0, arguments.length);\n    // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\n    // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\n    // method gets called.\n    return new Query.__referenceConstructor(this.repo, this.path) as Reference;\n  }\n\n  /**\n   * @param {!string} eventType\n   * @param {!function(DataSnapshot, string=)} callback\n   * @param {(function(Error)|Object)=} cancelCallbackOrContext\n   * @param {Object=} context\n   * @return {!function(DataSnapshot, string=)}\n   */\n  on(\n    eventType: string,\n    callback: SnapshotCallback,\n    cancelCallbackOrContext?: ((a: Error) => any) | Object,\n    context?: Object\n  ): SnapshotCallback {\n    validateArgCount('Query.on', 2, 4, arguments.length);\n    validateEventType('Query.on', 1, eventType, false);\n    validateCallback('Query.on', 2, callback, false);\n\n    const ret = Query.getCancelAndContextArgs_(\n      'Query.on',\n      cancelCallbackOrContext,\n      context\n    );\n\n    if (eventType === 'value') {\n      this.onValueEvent(callback, ret.cancel, ret.context);\n    } else {\n      const callbacks: { [k: string]: typeof callback } = {};\n      callbacks[eventType] = callback;\n      this.onChildEvent(callbacks, ret.cancel, ret.context);\n    }\n    return callback;\n  }\n\n  /**\n   * @param {!function(!DataSnapshot)} callback\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  protected onValueEvent(\n    callback: (a: DataSnapshot) => void,\n    cancelCallback: ((a: Error) => void) | null,\n    context: Object | null\n  ) {\n    const container = new ValueEventRegistration(\n      callback,\n      cancelCallback || null,\n      context || null\n    );\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  onChildEvent(\n    callbacks: { [k: string]: SnapshotCallback },\n    cancelCallback: ((a: Error) => any) | null,\n    context: Object | null\n  ) {\n    const container = new ChildEventRegistration(\n      callbacks,\n      cancelCallback,\n      context\n    );\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {string=} eventType\n   * @param {(function(!DataSnapshot, ?string=))=} callback\n   * @param {Object=} context\n   */\n  off(eventType?: string, callback?: SnapshotCallback, context?: Object) {\n    validateArgCount('Query.off', 0, 3, arguments.length);\n    validateEventType('Query.off', 1, eventType, true);\n    validateCallback('Query.off', 2, callback, true);\n    validateContextObject('Query.off', 3, context, true);\n\n    let container: EventRegistration | null = null;\n    let callbacks: { [k: string]: typeof callback } | null = null;\n    if (eventType === 'value') {\n      const valueCallback = callback || null;\n      container = new ValueEventRegistration(\n        valueCallback,\n        null,\n        context || null\n      );\n    } else if (eventType) {\n      if (callback) {\n        callbacks = {};\n        callbacks[eventType] = callback;\n      }\n      container = new ChildEventRegistration(callbacks, null, context || null);\n    }\n    this.repo.removeEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * Attaches a listener, waits for the first event, and then removes the listener\n   * @param {!string} eventType\n   * @param {!function(!DataSnapshot, string=)} userCallback\n   * @param cancelOrContext\n   * @param context\n   * @return {!firebase.Promise}\n   */\n  once(\n    eventType: string,\n    userCallback?: SnapshotCallback,\n    cancelOrContext?: ((a: Error) => void) | Object,\n    context?: Object\n  ): Promise<DataSnapshot> {\n    validateArgCount('Query.once', 1, 4, arguments.length);\n    validateEventType('Query.once', 1, eventType, false);\n    validateCallback('Query.once', 2, userCallback, true);\n\n    const ret = Query.getCancelAndContextArgs_(\n      'Query.once',\n      cancelOrContext,\n      context\n    );\n\n    // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\n    // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\n    // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\n    // against the Promise specification.\n    let firstCall = true;\n    const deferred = new Deferred<DataSnapshot>();\n\n    // A dummy error handler in case a user wasn't expecting promises\n    deferred.promise.catch(() => {});\n\n    const onceCallback = (snapshot: DataSnapshot) => {\n      // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\n      // triggers multiple events (e.g. child_added or child_changed).\n      if (firstCall) {\n        firstCall = false;\n        this.off(eventType, onceCallback);\n\n        if (userCallback) {\n          userCallback.bind(ret.context)(snapshot);\n        }\n        deferred.resolve(snapshot);\n      }\n    };\n\n    this.on(\n      eventType,\n      onceCallback,\n      /*cancel=*/ err => {\n        this.off(eventType, onceCallback);\n\n        if (ret.cancel) ret.cancel.bind(ret.context)(err);\n        deferred.reject(err);\n      }\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * Set a limit and anchor it to the start of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToFirst(limit: number): Query {\n    validateArgCount('Query.limitToFirst', 1, 1, arguments.length);\n    if (\n      typeof limit !== 'number' ||\n      Math.floor(limit) !== limit ||\n      limit <= 0\n    ) {\n      throw new Error(\n        'Query.limitToFirst: First argument must be a positive integer.'\n      );\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error(\n        'Query.limitToFirst: Limit was already set (by another call to limit, ' +\n          'limitToFirst, or limitToLast).'\n      );\n    }\n\n    return new Query(\n      this.repo,\n      this.path,\n      this.queryParams_.limitToFirst(limit),\n      this.orderByCalled_\n    );\n  }\n\n  /**\n   * Set a limit and anchor it to the end of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToLast(limit: number): Query {\n    validateArgCount('Query.limitToLast', 1, 1, arguments.length);\n    if (\n      typeof limit !== 'number' ||\n      Math.floor(limit) !== limit ||\n      limit <= 0\n    ) {\n      throw new Error(\n        'Query.limitToLast: First argument must be a positive integer.'\n      );\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error(\n        'Query.limitToLast: Limit was already set (by another call to limit, ' +\n          'limitToFirst, or limitToLast).'\n      );\n    }\n\n    return new Query(\n      this.repo,\n      this.path,\n      this.queryParams_.limitToLast(limit),\n      this.orderByCalled_\n    );\n  }\n\n  /**\n   * Given a child path, return a new query ordered by the specified grandchild path.\n   * @param {!string} path\n   * @return {!Query}\n   */\n  orderByChild(path: string): Query {\n    validateArgCount('Query.orderByChild', 1, 1, arguments.length);\n    if (path === '$key') {\n      throw new Error(\n        'Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.'\n      );\n    } else if (path === '$priority') {\n      throw new Error(\n        'Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.'\n      );\n    } else if (path === '$value') {\n      throw new Error(\n        'Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.'\n      );\n    }\n    validatePathString('Query.orderByChild', 1, path, false);\n    this.validateNoPreviousOrderByCall_('Query.orderByChild');\n    const parsedPath = new Path(path);\n    if (parsedPath.isEmpty()) {\n      throw new Error(\n        'Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.'\n      );\n    }\n    const index = new PathIndex(parsedPath);\n    const newParams = this.queryParams_.orderBy(index);\n    Query.validateQueryEndpoints_(newParams);\n\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the KeyIndex\n   * @return {!Query}\n   */\n  orderByKey(): Query {\n    validateArgCount('Query.orderByKey', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByKey');\n    const newParams = this.queryParams_.orderBy(KEY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the PriorityIndex\n   * @return {!Query}\n   */\n  orderByPriority(): Query {\n    validateArgCount('Query.orderByPriority', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByPriority');\n    const newParams = this.queryParams_.orderBy(PRIORITY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the ValueIndex\n   * @return {!Query}\n   */\n  orderByValue(): Query {\n    validateArgCount('Query.orderByValue', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByValue');\n    const newParams = this.queryParams_.orderBy(VALUE_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  startAt(\n    value: number | string | boolean | null = null,\n    name?: string | null\n  ): Query {\n    validateArgCount('Query.startAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\n    validateKey('Query.startAt', 2, name, true);\n\n    const newParams = this.queryParams_.startAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasStart()) {\n      throw new Error(\n        'Query.startAt: Starting point was already set (by another call to startAt ' +\n          'or equalTo).'\n      );\n    }\n\n    // Calling with no params tells us to start at the beginning.\n    if (value === undefined) {\n      value = null;\n      name = null;\n    }\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  endAt(\n    value: number | string | boolean | null = null,\n    name?: string | null\n  ): Query {\n    validateArgCount('Query.endAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\n    validateKey('Query.endAt', 2, name, true);\n\n    const newParams = this.queryParams_.endAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasEnd()) {\n      throw new Error(\n        'Query.endAt: Ending point was already set (by another call to endAt or ' +\n          'equalTo).'\n      );\n    }\n\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * Load the selection of children with exactly the specified value, and, optionally,\n   * the specified name.\n   * @param {number|string|boolean|null} value\n   * @param {string=} name\n   * @return {!Query}\n   */\n  equalTo(value: number | string | boolean | null, name?: string) {\n    validateArgCount('Query.equalTo', 1, 2, arguments.length);\n    validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\n    validateKey('Query.equalTo', 2, name, true);\n    if (this.queryParams_.hasStart()) {\n      throw new Error(\n        'Query.equalTo: Starting point was already set (by another call to startAt or ' +\n          'equalTo).'\n      );\n    }\n    if (this.queryParams_.hasEnd()) {\n      throw new Error(\n        'Query.equalTo: Ending point was already set (by another call to endAt or ' +\n          'equalTo).'\n      );\n    }\n    return this.startAt(value, name).endAt(value, name);\n  }\n\n  /**\n   * @return {!string} URL for this location.\n   */\n  toString(): string {\n    validateArgCount('Query.toString', 0, 0, arguments.length);\n\n    return this.repo.toString() + this.path.toUrlEncodedString();\n  }\n\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users.\n  toJSON() {\n    // An optional spacer argument is unnecessary for a string.\n    validateArgCount('Query.toJSON', 0, 1, arguments.length);\n    return this.toString();\n  }\n\n  /**\n   * An object representation of the query parameters used by this Query.\n   * @return {!Object}\n   */\n  queryObject(): Object {\n    return this.queryParams_.getQueryObject();\n  }\n\n  /**\n   * @return {!string}\n   */\n  queryIdentifier(): string {\n    const obj = this.queryObject();\n    const id = ObjectToUniqueKey(obj);\n    return id === '{}' ? 'default' : id;\n  }\n\n  /**\n   * Return true if this query and the provided query are equivalent; otherwise, return false.\n   * @param {Query} other\n   * @return {boolean}\n   */\n  isEqual(other: Query): boolean {\n    validateArgCount('Query.isEqual', 1, 1, arguments.length);\n    if (!(other instanceof Query)) {\n      const error =\n        'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\n      throw new Error(error);\n    }\n\n    const sameRepo = this.repo === other.repo;\n    const samePath = this.path.equals(other.path);\n    const sameQueryIdentifier =\n      this.queryIdentifier() === other.queryIdentifier();\n\n    return sameRepo && samePath && sameQueryIdentifier;\n  }\n\n  /**\n   * Helper used by .on and .once to extract the context and or cancel arguments.\n   * @param {!string} fnName The function name (on or once)\n   * @param {(function(Error)|Object)=} cancelOrContext\n   * @param {Object=} context\n   * @return {{cancel: ?function(Error), context: ?Object}}\n   * @private\n   */\n  private static getCancelAndContextArgs_(\n    fnName: string,\n    cancelOrContext?: ((a: Error) => void) | Object,\n    context?: Object\n  ): { cancel: ((a: Error) => void) | null; context: Object | null } {\n    const ret: {\n      cancel: ((a: Error) => void) | null;\n      context: Object | null;\n    } = { cancel: null, context: null };\n    if (cancelOrContext && context) {\n      ret.cancel = cancelOrContext as (a: Error) => void;\n      validateCallback(fnName, 3, ret.cancel, true);\n\n      ret.context = context;\n      validateContextObject(fnName, 4, ret.context, true);\n    } else if (cancelOrContext) {\n      // we have either a cancel callback or a context.\n      if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {\n        // it's a context!\n        ret.context = cancelOrContext;\n      } else if (typeof cancelOrContext === 'function') {\n        ret.cancel = cancelOrContext;\n      } else {\n        throw new Error(\n          errorPrefix(fnName, 3, true) +\n            ' must either be a cancel callback or a context object.'\n        );\n      }\n    }\n    return ret;\n  }\n\n  get ref(): Reference {\n    return this.getRef();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}