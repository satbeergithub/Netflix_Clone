{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as errorsExports from './error';\nexport var StringFormat = {\n  RAW: 'raw',\n  BASE64: 'base64',\n  BASE64URL: 'base64url',\n  DATA_URL: 'data_url'\n};\nexport function formatValidator(stringFormat) {\n  switch (stringFormat) {\n    case StringFormat.RAW:\n    case StringFormat.BASE64:\n    case StringFormat.BASE64URL:\n    case StringFormat.DATA_URL:\n      return;\n    default:\n      throw 'Expected one of the event types: [' + StringFormat.RAW + ', ' + StringFormat.BASE64 + ', ' + StringFormat.BASE64URL + ', ' + StringFormat.DATA_URL + '].';\n  }\n}\n/**\n * @struct\n */\nvar StringData = /** @class */function () {\n  function StringData(data, opt_contentType) {\n    this.data = data;\n    this.contentType = opt_contentType || null;\n  }\n  return StringData;\n}();\nexport { StringData };\nexport function dataFromString(format, string) {\n  switch (format) {\n    case StringFormat.RAW:\n      return new StringData(utf8Bytes_(string));\n    case StringFormat.BASE64:\n    case StringFormat.BASE64URL:\n      return new StringData(base64Bytes_(format, string));\n    case StringFormat.DATA_URL:\n      return new StringData(dataURLBytes_(string), dataURLContentType_(string));\n  }\n  // assert(false);\n  throw errorsExports.unknown();\n}\nexport function utf8Bytes_(string) {\n  var b = [];\n  for (var i = 0; i < string.length; i++) {\n    var c = string.charCodeAt(i);\n    if (c <= 127) {\n      b.push(c);\n    } else {\n      if (c <= 2047) {\n        b.push(192 | c >> 6, 128 | c & 63);\n      } else {\n        if ((c & 64512) == 55296) {\n          // The start of a surrogate pair.\n          var valid = i < string.length - 1 && (string.charCodeAt(i + 1) & 64512) == 56320;\n          if (!valid) {\n            // The second surrogate wasn't there.\n            b.push(239, 191, 189);\n          } else {\n            var hi = c;\n            var lo = string.charCodeAt(++i);\n            c = 65536 | (hi & 1023) << 10 | lo & 1023;\n            b.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | c & 63);\n          }\n        } else {\n          if ((c & 64512) == 56320) {\n            // Invalid low surrogate.\n            b.push(239, 191, 189);\n          } else {\n            b.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);\n          }\n        }\n      }\n    }\n  }\n  return new Uint8Array(b);\n}\nexport function percentEncodedBytes_(string) {\n  var decoded;\n  try {\n    decoded = decodeURIComponent(string);\n  } catch (e) {\n    throw errorsExports.invalidFormat(StringFormat.DATA_URL, 'Malformed data URL.');\n  }\n  return utf8Bytes_(decoded);\n}\nexport function base64Bytes_(format, string) {\n  switch (format) {\n    case StringFormat.BASE64:\n      {\n        var hasMinus = string.indexOf('-') !== -1;\n        var hasUnder = string.indexOf('_') !== -1;\n        if (hasMinus || hasUnder) {\n          var invalidChar = hasMinus ? '-' : '_';\n          throw errorsExports.invalidFormat(format, \"Invalid character '\" + invalidChar + \"' found: is it base64url encoded?\");\n        }\n        break;\n      }\n    case StringFormat.BASE64URL:\n      {\n        var hasPlus = string.indexOf('+') !== -1;\n        var hasSlash = string.indexOf('/') !== -1;\n        if (hasPlus || hasSlash) {\n          var invalidChar = hasPlus ? '+' : '/';\n          throw errorsExports.invalidFormat(format, \"Invalid character '\" + invalidChar + \"' found: is it base64 encoded?\");\n        }\n        string = string.replace(/-/g, '+').replace(/_/g, '/');\n        break;\n      }\n  }\n  var bytes;\n  try {\n    bytes = atob(string);\n  } catch (e) {\n    throw errorsExports.invalidFormat(format, 'Invalid character found');\n  }\n  var array = new Uint8Array(bytes.length);\n  for (var i = 0; i < bytes.length; i++) {\n    array[i] = bytes.charCodeAt(i);\n  }\n  return array;\n}\n/**\n * @struct\n */\nvar DataURLParts = /** @class */function () {\n  function DataURLParts(dataURL) {\n    this.base64 = false;\n    this.contentType = null;\n    var matches = dataURL.match(/^data:([^,]+)?,/);\n    if (matches === null) {\n      throw errorsExports.invalidFormat(StringFormat.DATA_URL, \"Must be formatted 'data:[<mediatype>][;base64],<data>\");\n    }\n    var middle = matches[1] || null;\n    if (middle != null) {\n      this.base64 = endsWith(middle, ';base64');\n      this.contentType = this.base64 ? middle.substring(0, middle.length - ';base64'.length) : middle;\n    }\n    this.rest = dataURL.substring(dataURL.indexOf(',') + 1);\n  }\n  return DataURLParts;\n}();\nexport function dataURLBytes_(string) {\n  var parts = new DataURLParts(string);\n  if (parts.base64) {\n    return base64Bytes_(StringFormat.BASE64, parts.rest);\n  } else {\n    return percentEncodedBytes_(parts.rest);\n  }\n}\nexport function dataURLContentType_(string) {\n  var parts = new DataURLParts(string);\n  return parts.contentType;\n}\nfunction endsWith(s, end) {\n  var longEnough = s.length >= end.length;\n  if (!longEnough) {\n    return false;\n  }\n  return s.substring(s.length - end.length) === end;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;AAeA,OAAO,KAAKA,aAAa,MAAM,SAAS;AAOxC,OAAO,IAAMC,YAAY,GAAG;EAC1BC,GAAG,EAAE,KAAK;EACVC,MAAM,EAAE,QAAQ;EAChBC,SAAS,EAAE,WAAW;EACtBC,QAAQ,EAAE;CACX;AAED,OAAM,yBAA0BC,YAAoB;EAClD,QAAQA,YAAY;IAClB,KAAKL,YAAY,CAACC,GAAG;IACrB,KAAKD,YAAY,CAACE,MAAM;IACxB,KAAKF,YAAY,CAACG,SAAS;IAC3B,KAAKH,YAAY,CAACI,QAAQ;MACxB;IACF;MACE,MAAM,oCAAoC,GACxCJ,YAAY,CAACC,GAAG,GAChB,IAAI,GACJD,YAAY,CAACE,MAAM,GACnB,IAAI,GACJF,YAAY,CAACG,SAAS,GACtB,IAAI,GACJH,YAAY,CAACI,QAAQ,GACrB,IAAI;EAAC;AAEb;AAEA;;;AAGA;EAGE,oBAAmBE,IAAgB,EAAEC,eAA+B;IAAjD,SAAI,GAAJD,IAAI;IACrB,IAAI,CAACE,WAAW,GAAGD,eAAe,IAAI,IAAI;EAC5C;EACF,iBAAC;AAAD,CANA,EAMC;;AAED,OAAM,wBACJE,MAAoB,EACpBC,MAAc;EAEd,QAAQD,MAAM;IACZ,KAAKT,YAAY,CAACC,GAAG;MACnB,OAAO,IAAIU,UAAU,CAACC,UAAU,CAACF,MAAM,CAAC,CAAC;IAC3C,KAAKV,YAAY,CAACE,MAAM;IACxB,KAAKF,YAAY,CAACG,SAAS;MACzB,OAAO,IAAIQ,UAAU,CAACE,YAAY,CAACJ,MAAM,EAAEC,MAAM,CAAC,CAAC;IACrD,KAAKV,YAAY,CAACI,QAAQ;MACxB,OAAO,IAAIO,UAAU,CAACG,aAAa,CAACJ,MAAM,CAAC,EAAEK,mBAAmB,CAACL,MAAM,CAAC,CAAC;EAAC;EAG9E;EACA,MAAMX,aAAa,CAACiB,OAAO,EAAE;AAC/B;AAEA,OAAM,oBAAqBN,MAAc;EACvC,IAAIO,CAAC,GAAG,EAAE;EACV,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,MAAM,CAACS,MAAM,EAAED,CAAC,EAAE,EAAE;IACtC,IAAIE,CAAC,GAAGV,MAAM,CAACW,UAAU,CAACH,CAAC,CAAC;IAC5B,IAAIE,CAAC,IAAI,GAAG,EAAE;MACZH,CAAC,CAACK,IAAI,CAACF,CAAC,CAAC;IACX,CAAC,MAAM;MACL,IAAIA,CAAC,IAAI,IAAI,EAAE;QACbH,CAAC,CAACK,IAAI,CAAC,GAAG,GAAIF,CAAC,IAAI,CAAE,EAAE,GAAG,GAAIA,CAAC,GAAG,EAAG,CAAC;MACxC,CAAC,MAAM;QACL,IAAI,CAACA,CAAC,GAAG,KAAK,KAAK,KAAK,EAAE;UACxB;UACA,IAAIG,KAAK,GACPL,CAAC,GAAGR,MAAM,CAACS,MAAM,GAAG,CAAC,IACrB,CAACT,MAAM,CAACW,UAAU,CAACH,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,KAAK,KAAK;UAC7C,IAAI,CAACK,KAAK,EAAE;YACV;YACAN,CAAC,CAACK,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;UACvB,CAAC,MAAM;YACL,IAAIE,EAAE,GAAGJ,CAAC;YACV,IAAIK,EAAE,GAAGf,MAAM,CAACW,UAAU,CAAC,EAAEH,CAAC,CAAC;YAC/BE,CAAC,GAAG,KAAK,GAAI,CAACI,EAAE,GAAG,IAAI,KAAK,EAAG,GAAIC,EAAE,GAAG,IAAK;YAC7CR,CAAC,CAACK,IAAI,CACJ,GAAG,GAAIF,CAAC,IAAI,EAAG,EACf,GAAG,GAAKA,CAAC,IAAI,EAAE,GAAI,EAAG,EACtB,GAAG,GAAKA,CAAC,IAAI,CAAC,GAAI,EAAG,EACrB,GAAG,GAAIA,CAAC,GAAG,EAAG,CACf;UACH;QACF,CAAC,MAAM;UACL,IAAI,CAACA,CAAC,GAAG,KAAK,KAAK,KAAK,EAAE;YACxB;YACAH,CAAC,CAACK,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;UACvB,CAAC,MAAM;YACLL,CAAC,CAACK,IAAI,CAAC,GAAG,GAAIF,CAAC,IAAI,EAAG,EAAE,GAAG,GAAKA,CAAC,IAAI,CAAC,GAAI,EAAG,EAAE,GAAG,GAAIA,CAAC,GAAG,EAAG,CAAC;UAChE;QACF;MACF;IACF;EACF;EACA,OAAO,IAAIM,UAAU,CAACT,CAAC,CAAC;AAC1B;AAEA,OAAM,8BAA+BP,MAAc;EACjD,IAAIiB,OAAO;EACX,IAAI;IACFA,OAAO,GAAGC,kBAAkB,CAAClB,MAAM,CAAC;EACtC,CAAC,CAAC,OAAOmB,CAAC,EAAE;IACV,MAAM9B,aAAa,CAAC+B,aAAa,CAC/B9B,YAAY,CAACI,QAAQ,EACrB,qBAAqB,CACtB;EACH;EACA,OAAOQ,UAAU,CAACe,OAAO,CAAC;AAC5B;AAEA,OAAM,sBAAuBlB,MAAoB,EAAEC,MAAc;EAC/D,QAAQD,MAAM;IACZ,KAAKT,YAAY,CAACE,MAAM;MAAE;QACxB,IAAI6B,QAAQ,GAAGrB,MAAM,CAACsB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACzC,IAAIC,QAAQ,GAAGvB,MAAM,CAACsB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACzC,IAAID,QAAQ,IAAIE,QAAQ,EAAE;UACxB,IAAIC,WAAW,GAAGH,QAAQ,GAAG,GAAG,GAAG,GAAG;UACtC,MAAMhC,aAAa,CAAC+B,aAAa,CAC/BrB,MAAM,EACN,qBAAqB,GACnByB,WAAW,GACX,mCAAmC,CACtC;QACH;QACA;MACF;IACA,KAAKlC,YAAY,CAACG,SAAS;MAAE;QAC3B,IAAIgC,OAAO,GAAGzB,MAAM,CAACsB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACxC,IAAII,QAAQ,GAAG1B,MAAM,CAACsB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACzC,IAAIG,OAAO,IAAIC,QAAQ,EAAE;UACvB,IAAIF,WAAW,GAAGC,OAAO,GAAG,GAAG,GAAG,GAAG;UACrC,MAAMpC,aAAa,CAAC+B,aAAa,CAC/BrB,MAAM,EACN,qBAAqB,GAAGyB,WAAW,GAAG,gCAAgC,CACvE;QACH;QACAxB,MAAM,GAAGA,MAAM,CAAC2B,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;QACrD;MACF;EAAC;EAEH,IAAIC,KAAK;EACT,IAAI;IACFA,KAAK,GAAGC,IAAI,CAAC7B,MAAM,CAAC;EACtB,CAAC,CAAC,OAAOmB,CAAC,EAAE;IACV,MAAM9B,aAAa,CAAC+B,aAAa,CAACrB,MAAM,EAAE,yBAAyB,CAAC;EACtE;EACA,IAAI+B,KAAK,GAAG,IAAId,UAAU,CAACY,KAAK,CAACnB,MAAM,CAAC;EACxC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,KAAK,CAACnB,MAAM,EAAED,CAAC,EAAE,EAAE;IACrCsB,KAAK,CAACtB,CAAC,CAAC,GAAGoB,KAAK,CAACjB,UAAU,CAACH,CAAC,CAAC;EAChC;EACA,OAAOsB,KAAK;AACd;AAEA;;;AAGA;EAKE,sBAAYC,OAAe;IAJ3B,WAAM,GAAY,KAAK;IACvB,gBAAW,GAAkB,IAAI;IAI/B,IAAIC,OAAO,GAAGD,OAAO,CAACE,KAAK,CAAC,iBAAiB,CAAC;IAC9C,IAAID,OAAO,KAAK,IAAI,EAAE;MACpB,MAAM3C,aAAa,CAAC+B,aAAa,CAC/B9B,YAAY,CAACI,QAAQ,EACrB,uDAAuD,CACxD;IACH;IACA,IAAIwC,MAAM,GAAGF,OAAO,CAAC,CAAC,CAAC,IAAI,IAAI;IAC/B,IAAIE,MAAM,IAAI,IAAI,EAAE;MAClB,IAAI,CAACC,MAAM,GAAGC,QAAQ,CAACF,MAAM,EAAE,SAAS,CAAC;MACzC,IAAI,CAACpC,WAAW,GAAG,IAAI,CAACqC,MAAM,GAC1BD,MAAM,CAACG,SAAS,CAAC,CAAC,EAAEH,MAAM,CAACzB,MAAM,GAAG,SAAS,CAACA,MAAM,CAAC,GACrDyB,MAAM;IACZ;IACA,IAAI,CAACI,IAAI,GAAGP,OAAO,CAACM,SAAS,CAACN,OAAO,CAACT,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EACzD;EACF,mBAAC;AAAD,CAtBA,EAsBC;AAED,OAAM,uBAAwBtB,MAAc;EAC1C,IAAIuC,KAAK,GAAG,IAAIC,YAAY,CAACxC,MAAM,CAAC;EACpC,IAAIuC,KAAK,CAACJ,MAAM,EAAE;IAChB,OAAOhC,YAAY,CAACb,YAAY,CAACE,MAAM,EAAE+C,KAAK,CAACD,IAAI,CAAC;EACtD,CAAC,MAAM;IACL,OAAOG,oBAAoB,CAACF,KAAK,CAACD,IAAI,CAAC;EACzC;AACF;AAEA,OAAM,6BAA8BtC,MAAc;EAChD,IAAIuC,KAAK,GAAG,IAAIC,YAAY,CAACxC,MAAM,CAAC;EACpC,OAAOuC,KAAK,CAACzC,WAAW;AAC1B;AAEA,kBAAkB4C,CAAS,EAAEC,GAAW;EACtC,IAAMC,UAAU,GAAGF,CAAC,CAACjC,MAAM,IAAIkC,GAAG,CAAClC,MAAM;EACzC,IAAI,CAACmC,UAAU,EAAE;IACf,OAAO,KAAK;EACd;EAEA,OAAOF,CAAC,CAACL,SAAS,CAACK,CAAC,CAACjC,MAAM,GAAGkC,GAAG,CAAClC,MAAM,CAAC,KAAKkC,GAAG;AACnD","names":["errorsExports","StringFormat","RAW","BASE64","BASE64URL","DATA_URL","stringFormat","data","opt_contentType","contentType","format","string","StringData","utf8Bytes_","base64Bytes_","dataURLBytes_","dataURLContentType_","unknown","b","i","length","c","charCodeAt","push","valid","hi","lo","Uint8Array","decoded","decodeURIComponent","e","invalidFormat","hasMinus","indexOf","hasUnder","invalidChar","hasPlus","hasSlash","replace","bytes","atob","array","dataURL","matches","match","middle","base64","endsWith","substring","rest","parts","DataURLParts","percentEncodedBytes_","s","end","longEnough"],"sources":["../src/implementation/string.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as errorsExports from './error';\nimport { errors } from './error';\n\n/**\n * @enum {string}\n */\nexport type StringFormat = string;\nexport const StringFormat = {\n  RAW: 'raw',\n  BASE64: 'base64',\n  BASE64URL: 'base64url',\n  DATA_URL: 'data_url'\n};\n\nexport function formatValidator(stringFormat: string) {\n  switch (stringFormat) {\n    case StringFormat.RAW:\n    case StringFormat.BASE64:\n    case StringFormat.BASE64URL:\n    case StringFormat.DATA_URL:\n      return;\n    default:\n      throw 'Expected one of the event types: [' +\n        StringFormat.RAW +\n        ', ' +\n        StringFormat.BASE64 +\n        ', ' +\n        StringFormat.BASE64URL +\n        ', ' +\n        StringFormat.DATA_URL +\n        '].';\n  }\n}\n\n/**\n * @struct\n */\nexport class StringData {\n  contentType: string | null;\n\n  constructor(public data: Uint8Array, opt_contentType?: string | null) {\n    this.contentType = opt_contentType || null;\n  }\n}\n\nexport function dataFromString(\n  format: StringFormat,\n  string: string\n): StringData {\n  switch (format) {\n    case StringFormat.RAW:\n      return new StringData(utf8Bytes_(string));\n    case StringFormat.BASE64:\n    case StringFormat.BASE64URL:\n      return new StringData(base64Bytes_(format, string));\n    case StringFormat.DATA_URL:\n      return new StringData(dataURLBytes_(string), dataURLContentType_(string));\n  }\n\n  // assert(false);\n  throw errorsExports.unknown();\n}\n\nexport function utf8Bytes_(string: string): Uint8Array {\n  let b = [];\n  for (let i = 0; i < string.length; i++) {\n    let c = string.charCodeAt(i);\n    if (c <= 127) {\n      b.push(c);\n    } else {\n      if (c <= 2047) {\n        b.push(192 | (c >> 6), 128 | (c & 63));\n      } else {\n        if ((c & 64512) == 55296) {\n          // The start of a surrogate pair.\n          let valid =\n            i < string.length - 1 &&\n            (string.charCodeAt(i + 1) & 64512) == 56320;\n          if (!valid) {\n            // The second surrogate wasn't there.\n            b.push(239, 191, 189);\n          } else {\n            let hi = c;\n            let lo = string.charCodeAt(++i);\n            c = 65536 | ((hi & 1023) << 10) | (lo & 1023);\n            b.push(\n              240 | (c >> 18),\n              128 | ((c >> 12) & 63),\n              128 | ((c >> 6) & 63),\n              128 | (c & 63)\n            );\n          }\n        } else {\n          if ((c & 64512) == 56320) {\n            // Invalid low surrogate.\n            b.push(239, 191, 189);\n          } else {\n            b.push(224 | (c >> 12), 128 | ((c >> 6) & 63), 128 | (c & 63));\n          }\n        }\n      }\n    }\n  }\n  return new Uint8Array(b);\n}\n\nexport function percentEncodedBytes_(string: string): Uint8Array {\n  let decoded;\n  try {\n    decoded = decodeURIComponent(string);\n  } catch (e) {\n    throw errorsExports.invalidFormat(\n      StringFormat.DATA_URL,\n      'Malformed data URL.'\n    );\n  }\n  return utf8Bytes_(decoded);\n}\n\nexport function base64Bytes_(format: StringFormat, string: string): Uint8Array {\n  switch (format) {\n    case StringFormat.BASE64: {\n      let hasMinus = string.indexOf('-') !== -1;\n      let hasUnder = string.indexOf('_') !== -1;\n      if (hasMinus || hasUnder) {\n        let invalidChar = hasMinus ? '-' : '_';\n        throw errorsExports.invalidFormat(\n          format,\n          \"Invalid character '\" +\n            invalidChar +\n            \"' found: is it base64url encoded?\"\n        );\n      }\n      break;\n    }\n    case StringFormat.BASE64URL: {\n      let hasPlus = string.indexOf('+') !== -1;\n      let hasSlash = string.indexOf('/') !== -1;\n      if (hasPlus || hasSlash) {\n        let invalidChar = hasPlus ? '+' : '/';\n        throw errorsExports.invalidFormat(\n          format,\n          \"Invalid character '\" + invalidChar + \"' found: is it base64 encoded?\"\n        );\n      }\n      string = string.replace(/-/g, '+').replace(/_/g, '/');\n      break;\n    }\n  }\n  let bytes;\n  try {\n    bytes = atob(string);\n  } catch (e) {\n    throw errorsExports.invalidFormat(format, 'Invalid character found');\n  }\n  let array = new Uint8Array(bytes.length);\n  for (let i = 0; i < bytes.length; i++) {\n    array[i] = bytes.charCodeAt(i);\n  }\n  return array;\n}\n\n/**\n * @struct\n */\nclass DataURLParts {\n  base64: boolean = false;\n  contentType: string | null = null;\n  rest: string;\n\n  constructor(dataURL: string) {\n    let matches = dataURL.match(/^data:([^,]+)?,/);\n    if (matches === null) {\n      throw errorsExports.invalidFormat(\n        StringFormat.DATA_URL,\n        \"Must be formatted 'data:[<mediatype>][;base64],<data>\"\n      );\n    }\n    let middle = matches[1] || null;\n    if (middle != null) {\n      this.base64 = endsWith(middle, ';base64');\n      this.contentType = this.base64\n        ? middle.substring(0, middle.length - ';base64'.length)\n        : middle;\n    }\n    this.rest = dataURL.substring(dataURL.indexOf(',') + 1);\n  }\n}\n\nexport function dataURLBytes_(string: string): Uint8Array {\n  let parts = new DataURLParts(string);\n  if (parts.base64) {\n    return base64Bytes_(StringFormat.BASE64, parts.rest);\n  } else {\n    return percentEncodedBytes_(parts.rest);\n  }\n}\n\nexport function dataURLContentType_(string: string): string | null {\n  let parts = new DataURLParts(string);\n  return parts.contentType;\n}\n\nfunction endsWith(s: string, end: string): boolean {\n  const longEnough = s.length >= end.length;\n  if (!longEnough) {\n    return false;\n  }\n\n  return s.substring(s.length - end.length) === end;\n}\n"]},"metadata":{},"sourceType":"module"}