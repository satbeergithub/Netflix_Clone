{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nfunction createSubscribe(executor, onNoObservers) {\n  var proxy = new ObserverProxy(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\nexports.createSubscribe = createSubscribe;\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nvar ObserverProxy = /** @class */function () {\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  function ObserverProxy(executor, onNoObservers) {\n    var _this = this;\n    this.observers = [];\n    this.unsubscribes = [];\n    this.observerCount = 0;\n    // Micro-task scheduling by calling task.then().\n    this.task = Promise.resolve();\n    this.finalized = false;\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task.then(function () {\n      executor(_this);\n    }).catch(function (e) {\n      _this.error(e);\n    });\n  }\n  ObserverProxy.prototype.next = function (value) {\n    this.forEachObserver(function (observer) {\n      observer.next(value);\n    });\n  };\n  ObserverProxy.prototype.error = function (error) {\n    this.forEachObserver(function (observer) {\n      observer.error(error);\n    });\n    this.close(error);\n  };\n  ObserverProxy.prototype.complete = function () {\n    this.forEachObserver(function (observer) {\n      observer.complete();\n    });\n    this.close();\n  };\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {\n    var _this = this;\n    var observer;\n    if (nextOrObserver === undefined && error === undefined && complete === undefined) {\n      throw new Error('Missing Observer.');\n    }\n    // Assemble an Observer object when passed as callback functions.\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver;\n    } else {\n      observer = {\n        next: nextOrObserver,\n        error: error,\n        complete: complete\n      };\n    }\n    if (observer.next === undefined) {\n      observer.next = noop;\n    }\n    if (observer.error === undefined) {\n      observer.error = noop;\n    }\n    if (observer.complete === undefined) {\n      observer.complete = noop;\n    }\n    var unsub = this.unsubscribeOne.bind(this, this.observers.length);\n    // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n    if (this.finalized) {\n      this.task.then(function () {\n        try {\n          if (_this.finalError) {\n            observer.error(_this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n          // nothing\n        }\n        return;\n      });\n    }\n    this.observers.push(observer);\n    return unsub;\n  };\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  ObserverProxy.prototype.unsubscribeOne = function (i) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n    delete this.observers[i];\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  };\n  ObserverProxy.prototype.forEachObserver = function (fn) {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    }\n    // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n    for (var i = 0; i < this.observers.length; i++) {\n      this.sendOne(i, fn);\n    }\n  };\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  ObserverProxy.prototype.sendOne = function (i, fn) {\n    var _this = this;\n    // Execute the callback asynchronously\n    this.task.then(function () {\n      if (_this.observers !== undefined && _this.observers[i] !== undefined) {\n        try {\n          fn(_this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  };\n  ObserverProxy.prototype.close = function (err) {\n    var _this = this;\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== undefined) {\n      this.finalError = err;\n    }\n    // Proxy is no longer needed - garbage collect references\n    this.task.then(function () {\n      _this.observers = undefined;\n      _this.onNoObservers = undefined;\n    });\n  };\n  return ObserverProxy;\n}();\n/** Turn synchronous function into one called asynchronously. */\nfunction async(fn, onError) {\n  return function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    Promise.resolve(true).then(function () {\n      fn.apply(void 0, args);\n    }).catch(function (error) {\n      if (onError) {\n        onError(error);\n      }\n    });\n  };\n}\nexports.async = async;\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n  for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {\n    var method = methods_1[_i];\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n  return false;\n}\nfunction noop() {\n  // do nothing\n}","map":{"version":3,"mappings":"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","names":["executor","onNoObservers","proxy","ObserverProxy","subscribe","bind","exports","Promise","resolve","task","then","_this","catch","error","e","value","forEachObserver","observer","next","close","complete","nextOrObserver","undefined","Error","implementsAnyMethods","noop","unsub","unsubscribeOne","observers","length","finalized","finalError","push","i","observerCount","fn","sendOne","console","err","onError","_i","args","obj","methods","methods_1","method"],"sources":["../src/subscribe.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: Error) => void;\nexport type CompleteFn = () => void;\n\nexport interface Observer<T> {\n  // Called once for each value in a stream of values.\n  next: NextFn<T>;\n\n  // A stream terminates by a single call to EITHER error() or complete().\n  error: ErrorFn;\n\n  // No events will be sent to next() once complete() is called.\n  complete: CompleteFn;\n}\n\n// Allow for any of the Observer methods to be undefined.\nexport interface PartialObserver<T> {\n  next?: NextFn<T>;\n  error?: ErrorFn;\n  complete?: CompleteFn;\n}\n\n// TODO: Support also Unsubscribe.unsubscribe?\nexport type Unsubscribe = () => void;\n\n/**\n * The Subscribe interface has two forms - passing the inline function\n * callbacks, or a object interface with callback properties.\n */\nexport interface Subscribe<T> {\n  (next?: NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;\n  (observer: PartialObserver<T>): Unsubscribe;\n}\n\nexport interface Observable<T> {\n  // Subscribe method\n  subscribe: Subscribe<T>;\n}\n\nexport type Executor<T> = (observer: Observer<T>) => void;\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nexport function createSubscribe<T>(\n  executor: Executor<T>,\n  onNoObservers?: Executor<T>\n): Subscribe<T> {\n  let proxy = new ObserverProxy<T>(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy<T> implements Observer<T> {\n  private observers: Array<Observer<T>> | undefined = [];\n  private unsubscribes: Unsubscribe[] = [];\n  private onNoObservers: Executor<T> | undefined;\n  private observerCount = 0;\n  // Micro-task scheduling by calling task.then().\n  private task = Promise.resolve();\n  private finalized = false;\n  private finalError: Error;\n\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor: Executor<T>, onNoObservers?: Executor<T>) {\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task\n      .then(() => {\n        executor(this);\n      })\n      .catch(e => {\n        this.error(e);\n      });\n  }\n\n  next(value: T) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.next(value);\n    });\n  }\n\n  error(error: Error) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n\n  complete() {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.complete();\n    });\n    this.close();\n  }\n\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(\n    nextOrObserver: PartialObserver<T> | Function,\n    error?: ErrorFn,\n    complete?: CompleteFn\n  ): Unsubscribe {\n    let observer: Observer<T>;\n\n    if (\n      nextOrObserver === undefined &&\n      error === undefined &&\n      complete === undefined\n    ) {\n      throw new Error('Missing Observer.');\n    }\n\n    // Assemble an Observer object when passed as callback functions.\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver as Observer<T>;\n    } else {\n      observer = {\n        next: (nextOrObserver as any) as NextFn<T>,\n        error: error,\n        complete: complete\n      } as Observer<T>;\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop as NextFn<T>;\n    }\n    if (observer.error === undefined) {\n      observer.error = noop as ErrorFn;\n    }\n    if (observer.complete === undefined) {\n      observer.complete = noop as CompleteFn;\n    }\n\n    let unsub = this.unsubscribeOne.bind(this, this.observers!.length);\n\n    // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n    if (this.finalized) {\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n          // nothing\n        }\n        return;\n      });\n    }\n\n    this.observers!.push(observer as Observer<T>);\n\n    return unsub;\n  }\n\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  private unsubscribeOne(i: number) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n\n    delete this.observers[i];\n\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  }\n\n  private forEachObserver(fn: (observer: Observer<T>) => void): void {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    }\n\n    // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n    for (let i = 0; i < this.observers!.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  private sendOne(i: number, fn: (observer: Observer<T>) => void): void {\n    // Execute the callback asynchronously\n    this.task.then(() => {\n      if (this.observers !== undefined && this.observers[i] !== undefined) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n\n  private close(err?: Error): void {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== undefined) {\n      this.finalError = err;\n    }\n    // Proxy is no longer needed - garbage collect references\n    this.task.then(() => {\n      this.observers = undefined;\n      this.onNoObservers = undefined;\n    });\n  }\n}\n\n/** Turn synchronous function into one called asynchronously. */\nexport function async(fn: Function, onError?: ErrorFn): Function {\n  return (...args: any[]) => {\n    Promise.resolve(true)\n      .then(() => {\n        fn(...args);\n      })\n      .catch((error: Error) => {\n        if (onError) {\n          onError(error);\n        }\n      });\n  };\n}\n\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj: any, methods: string[]): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (let method of methods) {\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop(): void {\n  // do nothing\n}\n"]},"metadata":{},"sourceType":"script"}