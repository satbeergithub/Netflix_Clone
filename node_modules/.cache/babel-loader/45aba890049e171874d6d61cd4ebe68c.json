{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar crypt_1 = require(\"./crypt\");\nvar json_1 = require(\"./json\");\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {{header: *, claims: *, data: *, signature: string}}\n */\nexports.decode = function (token) {\n  var header = {},\n    claims = {},\n    data = {},\n    signature = '';\n  try {\n    var parts = token.split('.');\n    header = json_1.jsonEval(crypt_1.base64Decode(parts[0]) || '');\n    claims = json_1.jsonEval(crypt_1.base64Decode(parts[1]) || '');\n    signature = parts[2];\n    data = claims['d'] || {};\n    delete claims['d'];\n  } catch (e) {}\n  return {\n    header: header,\n    claims: claims,\n    data: data,\n    signature: signature\n  };\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexports.isValidTimestamp = function (token) {\n  var claims = exports.decode(token).claims,\n    now = Math.floor(new Date().getTime() / 1000),\n    validSince,\n    validUntil;\n  if (typeof claims === 'object') {\n    if (claims.hasOwnProperty('nbf')) {\n      validSince = claims['nbf'];\n    } else if (claims.hasOwnProperty('iat')) {\n      validSince = claims['iat'];\n    }\n    if (claims.hasOwnProperty('exp')) {\n      validUntil = claims['exp'];\n    } else {\n      // token will expire after 24h by default\n      validUntil = validSince + 86400;\n    }\n  }\n  return now && validSince && validUntil && now >= validSince && now <= validUntil;\n};\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {?number}\n */\nexports.issuedAtTime = function (token) {\n  var claims = exports.decode(token).claims;\n  if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n    return claims['iat'];\n  }\n  return null;\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time and non-empty\n * signature.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexports.isValidFormat = function (token) {\n  var decoded = exports.decode(token),\n    claims = decoded.claims;\n  return !!decoded.signature && !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\n};\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexports.isAdmin = function (token) {\n  var claims = exports.decode(token).claims;\n  return typeof claims === 'object' && claims['admin'] === true;\n};","map":{"version":3,"mappings":"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","names":["exports","token","header","claims","data","signature","parts","split","json_1","crypt_1","e","now","Math","floor","Date","getTime","validSince","validUntil","hasOwnProperty","decoded"],"sources":["../src/jwt.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { base64Decode } from './crypt';\nimport { jsonEval } from './json';\n\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {{header: *, claims: *, data: *, signature: string}}\n */\nexport const decode = function(token) {\n  var header = {},\n    claims = {},\n    data = {},\n    signature = '';\n\n  try {\n    var parts = token.split('.');\n    header = jsonEval(base64Decode(parts[0]) || '');\n    claims = jsonEval(base64Decode(parts[1]) || '');\n    signature = parts[2];\n    data = claims['d'] || {};\n    delete claims['d'];\n  } catch (e) {}\n\n  return {\n    header: header,\n    claims: claims,\n    data: data,\n    signature: signature\n  };\n};\n\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexport const isValidTimestamp = function(token) {\n  var claims = decode(token).claims,\n    now = Math.floor(new Date().getTime() / 1000),\n    validSince,\n    validUntil;\n\n  if (typeof claims === 'object') {\n    if (claims.hasOwnProperty('nbf')) {\n      validSince = claims['nbf'];\n    } else if (claims.hasOwnProperty('iat')) {\n      validSince = claims['iat'];\n    }\n\n    if (claims.hasOwnProperty('exp')) {\n      validUntil = claims['exp'];\n    } else {\n      // token will expire after 24h by default\n      validUntil = validSince + 86400;\n    }\n  }\n\n  return (\n    now && validSince && validUntil && now >= validSince && now <= validUntil\n  );\n};\n\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {?number}\n */\nexport const issuedAtTime = function(token) {\n  var claims = decode(token).claims;\n  if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n    return claims['iat'];\n  }\n  return null;\n};\n\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time and non-empty\n * signature.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexport const isValidFormat = function(token) {\n  var decoded = decode(token),\n    claims = decoded.claims;\n\n  return (\n    !!decoded.signature &&\n    !!claims &&\n    typeof claims === 'object' &&\n    claims.hasOwnProperty('iat')\n  );\n};\n\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexport const isAdmin = function(token) {\n  var claims = decode(token).claims;\n  return typeof claims === 'object' && claims['admin'] === true;\n};\n"]},"metadata":{},"sourceType":"script"}