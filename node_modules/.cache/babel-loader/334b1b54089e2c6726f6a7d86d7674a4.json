{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ImmutableTree_1 = require(\"./util/ImmutableTree\");\nvar Path_1 = require(\"./util/Path\");\nvar util_1 = require(\"@firebase/util\");\nvar Node_1 = require(\"./snap/Node\");\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\nvar util_2 = require(\"@firebase/util\");\n/**\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\n * to reflect the write added.\n *\n * @constructor\n * @param {!ImmutableTree.<!Node>} writeTree\n */\nvar CompoundWrite = /** @class */function () {\n  function CompoundWrite(writeTree_) {\n    this.writeTree_ = writeTree_;\n  }\n  /**\n   * @param {!Path} path\n   * @param {!Node} node\n   * @return {!CompoundWrite}\n   */\n  CompoundWrite.prototype.addWrite = function (path, node) {\n    if (path.isEmpty()) {\n      return new CompoundWrite(new ImmutableTree_1.ImmutableTree(node));\n    } else {\n      var rootmost = this.writeTree_.findRootMostValueAndPath(path);\n      if (rootmost != null) {\n        var rootMostPath = rootmost.path;\n        var value = rootmost.value;\n        var relativePath = Path_1.Path.relativePath(rootMostPath, path);\n        value = value.updateChild(relativePath, node);\n        return new CompoundWrite(this.writeTree_.set(rootMostPath, value));\n      } else {\n        var subtree = new ImmutableTree_1.ImmutableTree(node);\n        var newWriteTree = this.writeTree_.setTree(path, subtree);\n        return new CompoundWrite(newWriteTree);\n      }\n    }\n  };\n  /**\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} updates\n   * @return {!CompoundWrite}\n   */\n  CompoundWrite.prototype.addWrites = function (path, updates) {\n    var newWrite = this;\n    util_1.forEach(updates, function (childKey, node) {\n      newWrite = newWrite.addWrite(path.child(childKey), node);\n    });\n    return newWrite;\n  };\n  /**\n   * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\n   * location, which must be removed by calling this method with that path.\n   *\n   * @param {!Path} path The path at which a write and all deeper writes should be removed\n   * @return {!CompoundWrite} The new CompoundWrite with the removed path\n   */\n  CompoundWrite.prototype.removeWrite = function (path) {\n    if (path.isEmpty()) {\n      return CompoundWrite.Empty;\n    } else {\n      var newWriteTree = this.writeTree_.setTree(path, ImmutableTree_1.ImmutableTree.Empty);\n      return new CompoundWrite(newWriteTree);\n    }\n  };\n  /**\n   * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\n   * considered \"complete\".\n   *\n   * @param {!Path} path The path to check for\n   * @return {boolean} Whether there is a complete write at that path\n   */\n  CompoundWrite.prototype.hasCompleteWrite = function (path) {\n    return this.getCompleteNode(path) != null;\n  };\n  /**\n   * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\n   * writes from deeper paths, but will return child nodes from a more shallow path.\n   *\n   * @param {!Path} path The path to get a complete write\n   * @return {?Node} The node if complete at that path, or null otherwise.\n   */\n  CompoundWrite.prototype.getCompleteNode = function (path) {\n    var rootmost = this.writeTree_.findRootMostValueAndPath(path);\n    if (rootmost != null) {\n      return this.writeTree_.get(rootmost.path).getChild(Path_1.Path.relativePath(rootmost.path, path));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Returns all children that are guaranteed to be a complete overwrite.\n   *\n   * @return {!Array.<NamedNode>} A list of all complete children.\n   */\n  CompoundWrite.prototype.getCompleteChildren = function () {\n    var children = [];\n    var node = this.writeTree_.value;\n    if (node != null) {\n      // If it's a leaf node, it has no children; so nothing to do.\n      if (!node.isLeafNode()) {\n        node.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {\n          children.push(new Node_1.NamedNode(childName, childNode));\n        });\n      }\n    } else {\n      this.writeTree_.children.inorderTraversal(function (childName, childTree) {\n        if (childTree.value != null) {\n          children.push(new Node_1.NamedNode(childName, childTree.value));\n        }\n      });\n    }\n    return children;\n  };\n  /**\n   * @param {!Path} path\n   * @return {!CompoundWrite}\n   */\n  CompoundWrite.prototype.childCompoundWrite = function (path) {\n    if (path.isEmpty()) {\n      return this;\n    } else {\n      var shadowingNode = this.getCompleteNode(path);\n      if (shadowingNode != null) {\n        return new CompoundWrite(new ImmutableTree_1.ImmutableTree(shadowingNode));\n      } else {\n        return new CompoundWrite(this.writeTree_.subtree(path));\n      }\n    }\n  };\n  /**\n   * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\n   * @return {boolean} Whether this CompoundWrite is empty\n   */\n  CompoundWrite.prototype.isEmpty = function () {\n    return this.writeTree_.isEmpty();\n  };\n  /**\n   * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\n   * node\n   * @param {!Node} node The node to apply this CompoundWrite to\n   * @return {!Node} The node with all writes applied\n   */\n  CompoundWrite.prototype.apply = function (node) {\n    return CompoundWrite.applySubtreeWrite_(Path_1.Path.Empty, this.writeTree_, node);\n  };\n  /**\n   * @type {!CompoundWrite}\n   */\n  CompoundWrite.Empty = new CompoundWrite(new ImmutableTree_1.ImmutableTree(null));\n  /**\n   * @param {!Path} relativePath\n   * @param {!ImmutableTree.<!Node>} writeTree\n   * @param {!Node} node\n   * @return {!Node}\n   * @private\n   */\n  CompoundWrite.applySubtreeWrite_ = function (relativePath, writeTree, node) {\n    if (writeTree.value != null) {\n      // Since there a write is always a leaf, we're done here\n      return node.updateChild(relativePath, writeTree.value);\n    } else {\n      var priorityWrite_1 = null;\n      writeTree.children.inorderTraversal(function (childKey, childTree) {\n        if (childKey === '.priority') {\n          // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n          // to apply priorities to empty nodes that are later filled\n          util_2.assert(childTree.value !== null, 'Priority writes must always be leaf nodes');\n          priorityWrite_1 = childTree.value;\n        } else {\n          node = CompoundWrite.applySubtreeWrite_(relativePath.child(childKey), childTree, node);\n        }\n      });\n      // If there was a priority write, we only apply it if the node is not empty\n      if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {\n        node = node.updateChild(relativePath.child('.priority'), priorityWrite_1);\n      }\n      return node;\n    }\n  };\n  return CompoundWrite;\n}();\nexports.CompoundWrite = CompoundWrite;","map":{"version":3,"mappings":"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","names":["writeTree_","CompoundWrite","path","node","isEmpty","ImmutableTree_1","rootmost","findRootMostValueAndPath","rootMostPath","value","relativePath","Path_1","updateChild","set","subtree","newWriteTree","setTree","updates","newWrite","util_1","childKey","addWrite","child","Empty","getCompleteNode","get","getChild","children","isLeafNode","forEachChild","PriorityIndex_1","childName","childNode","push","Node_1","inorderTraversal","childTree","shadowingNode","applySubtreeWrite_","writeTree","priorityWrite_1","util_2","exports"],"sources":["../src/core/CompoundWrite.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ImmutableTree } from './util/ImmutableTree';\nimport { Path } from './util/Path';\nimport { forEach } from '@firebase/util';\nimport { Node, NamedNode } from './snap/Node';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { assert } from '@firebase/util';\nimport { ChildrenNode } from './snap/ChildrenNode';\n\n/**\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\n * to reflect the write added.\n *\n * @constructor\n * @param {!ImmutableTree.<!Node>} writeTree\n */\nexport class CompoundWrite {\n  constructor(private writeTree_: ImmutableTree<Node>) {}\n  /**\n   * @type {!CompoundWrite}\n   */\n  static Empty = new CompoundWrite(new ImmutableTree(null));\n\n  /**\n   * @param {!Path} path\n   * @param {!Node} node\n   * @return {!CompoundWrite}\n   */\n  addWrite(path: Path, node: Node): CompoundWrite {\n    if (path.isEmpty()) {\n      return new CompoundWrite(new ImmutableTree(node));\n    } else {\n      const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n      if (rootmost != null) {\n        const rootMostPath = rootmost.path;\n        let value = rootmost.value;\n        const relativePath = Path.relativePath(rootMostPath, path);\n        value = value.updateChild(relativePath, node);\n        return new CompoundWrite(this.writeTree_.set(rootMostPath, value));\n      } else {\n        const subtree = new ImmutableTree(node);\n        const newWriteTree = this.writeTree_.setTree(path, subtree);\n        return new CompoundWrite(newWriteTree);\n      }\n    }\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} updates\n   * @return {!CompoundWrite}\n   */\n  addWrites(path: Path, updates: { [name: string]: Node }): CompoundWrite {\n    let newWrite = this as CompoundWrite;\n    forEach(updates, function(childKey: string, node: Node) {\n      newWrite = newWrite.addWrite(path.child(childKey), node);\n    });\n    return newWrite;\n  }\n\n  /**\n   * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\n   * location, which must be removed by calling this method with that path.\n   *\n   * @param {!Path} path The path at which a write and all deeper writes should be removed\n   * @return {!CompoundWrite} The new CompoundWrite with the removed path\n   */\n  removeWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return CompoundWrite.Empty;\n    } else {\n      const newWriteTree = this.writeTree_.setTree(path, ImmutableTree.Empty);\n      return new CompoundWrite(newWriteTree);\n    }\n  }\n\n  /**\n   * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\n   * considered \"complete\".\n   *\n   * @param {!Path} path The path to check for\n   * @return {boolean} Whether there is a complete write at that path\n   */\n  hasCompleteWrite(path: Path): boolean {\n    return this.getCompleteNode(path) != null;\n  }\n\n  /**\n   * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\n   * writes from deeper paths, but will return child nodes from a more shallow path.\n   *\n   * @param {!Path} path The path to get a complete write\n   * @return {?Node} The node if complete at that path, or null otherwise.\n   */\n  getCompleteNode(path: Path): Node | null {\n    const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n    if (rootmost != null) {\n      return this.writeTree_\n        .get(rootmost.path)\n        .getChild(Path.relativePath(rootmost.path, path));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns all children that are guaranteed to be a complete overwrite.\n   *\n   * @return {!Array.<NamedNode>} A list of all complete children.\n   */\n  getCompleteChildren(): Array<NamedNode> {\n    const children: NamedNode[] = [];\n    let node = this.writeTree_.value;\n    if (node != null) {\n      // If it's a leaf node, it has no children; so nothing to do.\n      if (!node.isLeafNode()) {\n        (node as ChildrenNode).forEachChild(PRIORITY_INDEX, function(\n          childName,\n          childNode\n        ) {\n          children.push(new NamedNode(childName, childNode));\n        });\n      }\n    } else {\n      this.writeTree_.children.inorderTraversal(function(childName, childTree) {\n        if (childTree.value != null) {\n          children.push(new NamedNode(childName, childTree.value));\n        }\n      });\n    }\n    return children;\n  }\n\n  /**\n   * @param {!Path} path\n   * @return {!CompoundWrite}\n   */\n  childCompoundWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return this;\n    } else {\n      const shadowingNode = this.getCompleteNode(path);\n      if (shadowingNode != null) {\n        return new CompoundWrite(new ImmutableTree(shadowingNode));\n      } else {\n        return new CompoundWrite(this.writeTree_.subtree(path));\n      }\n    }\n  }\n\n  /**\n   * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\n   * @return {boolean} Whether this CompoundWrite is empty\n   */\n  isEmpty(): boolean {\n    return this.writeTree_.isEmpty();\n  }\n\n  /**\n   * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\n   * node\n   * @param {!Node} node The node to apply this CompoundWrite to\n   * @return {!Node} The node with all writes applied\n   */\n  apply(node: Node): Node {\n    return CompoundWrite.applySubtreeWrite_(Path.Empty, this.writeTree_, node);\n  }\n\n  /**\n   * @param {!Path} relativePath\n   * @param {!ImmutableTree.<!Node>} writeTree\n   * @param {!Node} node\n   * @return {!Node}\n   * @private\n   */\n  private static applySubtreeWrite_ = function(\n    relativePath: Path,\n    writeTree: ImmutableTree<Node>,\n    node: Node\n  ): Node {\n    if (writeTree.value != null) {\n      // Since there a write is always a leaf, we're done here\n      return node.updateChild(relativePath, writeTree.value);\n    } else {\n      let priorityWrite = null;\n      writeTree.children.inorderTraversal(function(childKey, childTree) {\n        if (childKey === '.priority') {\n          // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n          // to apply priorities to empty nodes that are later filled\n          assert(\n            childTree.value !== null,\n            'Priority writes must always be leaf nodes'\n          );\n          priorityWrite = childTree.value;\n        } else {\n          node = CompoundWrite.applySubtreeWrite_(\n            relativePath.child(childKey),\n            childTree,\n            node\n          );\n        }\n      });\n      // If there was a priority write, we only apply it if the node is not empty\n      if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {\n        node = node.updateChild(relativePath.child('.priority'), priorityWrite);\n      }\n      return node;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script"}