{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar Path_1 = require(\"./Path\");\nvar util_2 = require(\"@firebase/util\");\n/**\n * Node in a Tree.\n */\nvar TreeNode = /** @class */function () {\n  function TreeNode() {\n    // TODO: Consider making accessors that create children and value lazily or\n    // separate Internal / Leaf 'types'.\n    this.children = {};\n    this.childCount = 0;\n    this.value = null;\n  }\n  return TreeNode;\n}();\nexports.TreeNode = TreeNode;\n/**\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\n * children.\n */\nvar Tree = /** @class */function () {\n  /**\n   * @template T\n   * @param {string=} name_ Optional name of the node.\n   * @param {Tree=} parent_ Optional parent node.\n   * @param {TreeNode=} node_ Optional node to wrap.\n   */\n  function Tree(name_, parent_, node_) {\n    if (name_ === void 0) {\n      name_ = '';\n    }\n    if (parent_ === void 0) {\n      parent_ = null;\n    }\n    if (node_ === void 0) {\n      node_ = new TreeNode();\n    }\n    this.name_ = name_;\n    this.parent_ = parent_;\n    this.node_ = node_;\n  }\n  /**\n   * Returns a sub-Tree for the given path.\n   *\n   * @param {!(string|Path)} pathObj Path to look up.\n   * @return {!Tree.<T>} Tree for path.\n   */\n  Tree.prototype.subTree = function (pathObj) {\n    // TODO: Require pathObj to be Path?\n    var path = pathObj instanceof Path_1.Path ? pathObj : new Path_1.Path(pathObj);\n    var child = this,\n      next;\n    while ((next = path.getFront()) !== null) {\n      var childNode = util_2.safeGet(child.node_.children, next) || new TreeNode();\n      child = new Tree(next, child, childNode);\n      path = path.popFront();\n    }\n    return child;\n  };\n  /**\n   * Returns the data associated with this tree node.\n   *\n   * @return {?T} The data or null if no data exists.\n   */\n  Tree.prototype.getValue = function () {\n    return this.node_.value;\n  };\n  /**\n   * Sets data to this tree node.\n   *\n   * @param {!T} value Value to set.\n   */\n  Tree.prototype.setValue = function (value) {\n    util_1.assert(typeof value !== 'undefined', 'Cannot set value to undefined');\n    this.node_.value = value;\n    this.updateParents_();\n  };\n  /**\n   * Clears the contents of the tree node (its value and all children).\n   */\n  Tree.prototype.clear = function () {\n    this.node_.value = null;\n    this.node_.children = {};\n    this.node_.childCount = 0;\n    this.updateParents_();\n  };\n  /**\n   * @return {boolean} Whether the tree has any children.\n   */\n  Tree.prototype.hasChildren = function () {\n    return this.node_.childCount > 0;\n  };\n  /**\n   * @return {boolean} Whether the tree is empty (no value or children).\n   */\n  Tree.prototype.isEmpty = function () {\n    return this.getValue() === null && !this.hasChildren();\n  };\n  /**\n   * Calls action for each child of this tree node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  Tree.prototype.forEachChild = function (action) {\n    var _this = this;\n    util_2.forEach(this.node_.children, function (child, childTree) {\n      action(new Tree(child, _this, childTree));\n    });\n  };\n  /**\n   * Does a depth-first traversal of this node's descendants, calling action for each one.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to\n   *   false.\n   * @param {boolean=} childrenFirst Whether to call action on children before calling it on\n   *   parent.\n   */\n  Tree.prototype.forEachDescendant = function (action, includeSelf, childrenFirst) {\n    if (includeSelf && !childrenFirst) action(this);\n    this.forEachChild(function (child) {\n      child.forEachDescendant(action, /*includeSelf=*/true, childrenFirst);\n    });\n    if (includeSelf && childrenFirst) action(this);\n  };\n  /**\n   * Calls action on each ancestor node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called on each parent; return\n   *   true to abort.\n   * @param {boolean=} includeSelf Whether to call action on this node as well.\n   * @return {boolean} true if the action callback returned true.\n   */\n  Tree.prototype.forEachAncestor = function (action, includeSelf) {\n    var node = includeSelf ? this : this.parent();\n    while (node !== null) {\n      if (action(node)) {\n        return true;\n      }\n      node = node.parent();\n    }\n    return false;\n  };\n  /**\n   * Does a depth-first traversal of this node's descendants.  When a descendant with a value\n   * is found, action is called on it and traversal does not continue inside the node.\n   * Action is *not* called on this node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  Tree.prototype.forEachImmediateDescendantWithValue = function (action) {\n    this.forEachChild(function (child) {\n      if (child.getValue() !== null) action(child);else child.forEachImmediateDescendantWithValue(action);\n    });\n  };\n  /**\n   * @return {!Path} The path of this tree node, as a Path.\n   */\n  Tree.prototype.path = function () {\n    return new Path_1.Path(this.parent_ === null ? this.name_ : this.parent_.path() + '/' + this.name_);\n  };\n  /**\n   * @return {string} The name of the tree node.\n   */\n  Tree.prototype.name = function () {\n    return this.name_;\n  };\n  /**\n   * @return {?Tree} The parent tree node, or null if this is the root of the tree.\n   */\n  Tree.prototype.parent = function () {\n    return this.parent_;\n  };\n  /**\n   * Adds or removes this child from its parent based on whether it's empty or not.\n   *\n   * @private\n   */\n  Tree.prototype.updateParents_ = function () {\n    if (this.parent_ !== null) this.parent_.updateChild_(this.name_, this);\n  };\n  /**\n   * Adds or removes the passed child to this tree node, depending on whether it's empty.\n   *\n   * @param {string} childName The name of the child to update.\n   * @param {!Tree.<T>} child The child to update.\n   * @private\n   */\n  Tree.prototype.updateChild_ = function (childName, child) {\n    var childEmpty = child.isEmpty();\n    var childExists = util_2.contains(this.node_.children, childName);\n    if (childEmpty && childExists) {\n      delete this.node_.children[childName];\n      this.node_.childCount--;\n      this.updateParents_();\n    } else if (!childEmpty && !childExists) {\n      this.node_.children[childName] = child.node_;\n      this.node_.childCount++;\n      this.updateParents_();\n    }\n  };\n  return Tree;\n}();\nexports.Tree = Tree;","map":{"version":3,"mappings":"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","names":["exports","name_","parent_","node_","TreeNode","Tree","pathObj","path","Path_1","child","next","getFront","childNode","util_2","children","popFront","value","util_1","updateParents_","childCount","getValue","hasChildren","action","childTree","_this","includeSelf","childrenFirst","forEachChild","forEachDescendant","node","parent","forEachImmediateDescendantWithValue","updateChild_","childName","childEmpty","isEmpty","childExists"],"sources":["../src/core/util/Tree.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Path } from './Path';\nimport { forEach, contains, safeGet } from '@firebase/util';\n\n/**\n * Node in a Tree.\n */\nexport class TreeNode<T> {\n  // TODO: Consider making accessors that create children and value lazily or\n  // separate Internal / Leaf 'types'.\n  children: { [name: string]: TreeNode<T> } = {};\n  childCount = 0;\n  value: T | null = null;\n}\n\n/**\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\n * children.\n */\nexport class Tree<T> {\n  /**\n   * @template T\n   * @param {string=} name_ Optional name of the node.\n   * @param {Tree=} parent_ Optional parent node.\n   * @param {TreeNode=} node_ Optional node to wrap.\n   */\n  constructor(\n    private name_: string = '',\n    private parent_: Tree<T> | null = null,\n    private node_: TreeNode<T> = new TreeNode<T>()\n  ) {}\n\n  /**\n   * Returns a sub-Tree for the given path.\n   *\n   * @param {!(string|Path)} pathObj Path to look up.\n   * @return {!Tree.<T>} Tree for path.\n   */\n  subTree(pathObj: string | Path): Tree<T> {\n    // TODO: Require pathObj to be Path?\n    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);\n    let child = this as any,\n      next;\n    while ((next = path.getFront()) !== null) {\n      const childNode = safeGet(child.node_.children, next) || new TreeNode();\n      child = new Tree(next, child, childNode);\n      path = path.popFront();\n    }\n\n    return child;\n  }\n\n  /**\n   * Returns the data associated with this tree node.\n   *\n   * @return {?T} The data or null if no data exists.\n   */\n  getValue(): T | null {\n    return this.node_.value;\n  }\n\n  /**\n   * Sets data to this tree node.\n   *\n   * @param {!T} value Value to set.\n   */\n  setValue(value: T) {\n    assert(typeof value !== 'undefined', 'Cannot set value to undefined');\n    this.node_.value = value;\n    this.updateParents_();\n  }\n\n  /**\n   * Clears the contents of the tree node (its value and all children).\n   */\n  clear() {\n    this.node_.value = null;\n    this.node_.children = {};\n    this.node_.childCount = 0;\n    this.updateParents_();\n  }\n\n  /**\n   * @return {boolean} Whether the tree has any children.\n   */\n  hasChildren(): boolean {\n    return this.node_.childCount > 0;\n  }\n\n  /**\n   * @return {boolean} Whether the tree is empty (no value or children).\n   */\n  isEmpty(): boolean {\n    return this.getValue() === null && !this.hasChildren();\n  }\n\n  /**\n   * Calls action for each child of this tree node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  forEachChild(action: (tree: Tree<T>) => void) {\n    forEach(this.node_.children, (child: string, childTree: TreeNode<T>) => {\n      action(new Tree<T>(child, this, childTree));\n    });\n  }\n\n  /**\n   * Does a depth-first traversal of this node's descendants, calling action for each one.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to\n   *   false.\n   * @param {boolean=} childrenFirst Whether to call action on children before calling it on\n   *   parent.\n   */\n  forEachDescendant(\n    action: (tree: Tree<T>) => void,\n    includeSelf?: boolean,\n    childrenFirst?: boolean\n  ) {\n    if (includeSelf && !childrenFirst) action(this);\n\n    this.forEachChild(function(child) {\n      child.forEachDescendant(action, /*includeSelf=*/ true, childrenFirst);\n    });\n\n    if (includeSelf && childrenFirst) action(this);\n  }\n\n  /**\n   * Calls action on each ancestor node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called on each parent; return\n   *   true to abort.\n   * @param {boolean=} includeSelf Whether to call action on this node as well.\n   * @return {boolean} true if the action callback returned true.\n   */\n  forEachAncestor(\n    action: (tree: Tree<T>) => void,\n    includeSelf?: boolean\n  ): boolean {\n    let node = includeSelf ? this : this.parent();\n    while (node !== null) {\n      if (action(node)) {\n        return true;\n      }\n      node = node.parent();\n    }\n    return false;\n  }\n\n  /**\n   * Does a depth-first traversal of this node's descendants.  When a descendant with a value\n   * is found, action is called on it and traversal does not continue inside the node.\n   * Action is *not* called on this node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  forEachImmediateDescendantWithValue(action: (tree: Tree<T>) => void) {\n    this.forEachChild(function(child) {\n      if (child.getValue() !== null) action(child);\n      else child.forEachImmediateDescendantWithValue(action);\n    });\n  }\n\n  /**\n   * @return {!Path} The path of this tree node, as a Path.\n   */\n  path(): Path {\n    return new Path(\n      this.parent_ === null\n        ? this.name_\n        : this.parent_.path() + '/' + this.name_\n    );\n  }\n\n  /**\n   * @return {string} The name of the tree node.\n   */\n  name(): string {\n    return this.name_;\n  }\n\n  /**\n   * @return {?Tree} The parent tree node, or null if this is the root of the tree.\n   */\n  parent(): Tree<T> | null {\n    return this.parent_;\n  }\n\n  /**\n   * Adds or removes this child from its parent based on whether it's empty or not.\n   *\n   * @private\n   */\n  private updateParents_() {\n    if (this.parent_ !== null) this.parent_.updateChild_(this.name_, this);\n  }\n\n  /**\n   * Adds or removes the passed child to this tree node, depending on whether it's empty.\n   *\n   * @param {string} childName The name of the child to update.\n   * @param {!Tree.<T>} child The child to update.\n   * @private\n   */\n  private updateChild_(childName: string, child: Tree<T>) {\n    const childEmpty = child.isEmpty();\n    const childExists = contains(this.node_.children, childName);\n    if (childEmpty && childExists) {\n      delete this.node_.children[childName];\n      this.node_.childCount--;\n      this.updateParents_();\n    } else if (!childEmpty && !childExists) {\n      this.node_.children[childName] = child.node_;\n      this.node_.childCount++;\n      this.updateParents_();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}