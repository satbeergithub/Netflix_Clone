{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar RepoInfo_1 = require(\"../core/RepoInfo\");\nvar PersistentConnection_1 = require(\"../core/PersistentConnection\");\nvar RepoManager_1 = require(\"../core/RepoManager\");\nvar Connection_1 = require(\"../realtime/Connection\");\nexports.DataConnection = PersistentConnection_1.PersistentConnection;\n/**\n * @param {!string} pathString\n * @param {function(*)} onComplete\n */\nPersistentConnection_1.PersistentConnection.prototype.simpleListen = function (pathString, onComplete) {\n  this.sendRequest('q', {\n    p: pathString\n  }, onComplete);\n};\n/**\n * @param {*} data\n * @param {function(*)} onEcho\n */\nPersistentConnection_1.PersistentConnection.prototype.echo = function (data, onEcho) {\n  this.sendRequest('echo', {\n    d: data\n  }, onEcho);\n};\n// RealTimeConnection properties that we use in tests.\nexports.RealTimeConnection = Connection_1.Connection;\n/**\n * @param {function(): string} newHash\n * @return {function()}\n */\nexports.hijackHash = function (newHash) {\n  var oldPut = PersistentConnection_1.PersistentConnection.prototype.put;\n  PersistentConnection_1.PersistentConnection.prototype.put = function (pathString, data, opt_onComplete, opt_hash) {\n    if (opt_hash !== undefined) {\n      opt_hash = newHash();\n    }\n    oldPut.call(this, pathString, data, opt_onComplete, opt_hash);\n  };\n  return function () {\n    PersistentConnection_1.PersistentConnection.prototype.put = oldPut;\n  };\n};\n/**\n * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}\n */\nexports.ConnectionTarget = RepoInfo_1.RepoInfo;\n/**\n * @param {!Query} query\n * @return {!string}\n */\nexports.queryIdentifier = function (query) {\n  return query.queryIdentifier();\n};\n/**\n * @param {!Query} firebaseRef\n * @return {!Object}\n */\nexports.listens = function (firebaseRef) {\n  return firebaseRef.repo.persistentConnection_.listens_;\n};\n/**\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\n *\n * @param {boolean} forceRestClient\n */\nexports.forceRestClient = function (forceRestClient) {\n  RepoManager_1.RepoManager.getInstance().forceRestClient(forceRestClient);\n};","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AAGaA,sBAAc,GAAGC,2CAAoB;AAElD;;;;AAICA,2CAAoB,CAACC,SAAiB,CAACC,YAAY,GAAG,UACrDC,UAAkB,EAClBC,UAA4B;EAE5B,IAAI,CAACC,WAAW,CAAC,GAAG,EAAE;IAAEC,CAAC,EAAEH;EAAU,CAAE,EAAEC,UAAU,CAAC;AACtD,CAAC;AAED;;;;AAICJ,2CAAoB,CAACC,SAAiB,CAACM,IAAI,GAAG,UAC7CC,IAAS,EACTC,MAAwB;EAExB,IAAI,CAACJ,WAAW,CAAC,MAAM,EAAE;IAAEK,CAAC,EAAEF;EAAI,CAAE,EAAEC,MAAM,CAAC;AAC/C,CAAC;AAED;AACaV,0BAAkB,GAAGY,uBAAU;AAE5C;;;;AAIaZ,kBAAU,GAAG,UAASa,OAAqB;EACtD,IAAMC,MAAM,GAAGb,2CAAoB,CAACC,SAAS,CAACa,GAAG;EACjDd,2CAAoB,CAACC,SAAS,CAACa,GAAG,GAAG,UACnCX,UAAU,EACVK,IAAI,EACJO,cAAc,EACdC,QAAQ;IAER,IAAIA,QAAQ,KAAKC,SAAS,EAAE;MAC1BD,QAAQ,GAAGJ,OAAO,EAAE;IACtB;IACAC,MAAM,CAACK,IAAI,CAAC,IAAI,EAAEf,UAAU,EAAEK,IAAI,EAAEO,cAAc,EAAEC,QAAQ,CAAC;EAC/D,CAAC;EACD,OAAO;IACLhB,2CAAoB,CAACC,SAAS,CAACa,GAAG,GAAGD,MAAM;EAC7C,CAAC;AACH,CAAC;AAED;;;AAGad,wBAAgB,GAAGoB,mBAAQ;AAExC;;;;AAIapB,uBAAe,GAAG,UAASqB,KAAY;EAClD,OAAOA,KAAK,CAACC,eAAe,EAAE;AAChC,CAAC;AAED;;;;AAIatB,eAAO,GAAG,UAASuB,WAAkB;EAChD,OAAQA,WAAW,CAACC,IAAI,CAACC,qBAA6B,CAACC,QAAQ;AACjE,CAAC;AAED;;;;;AAKa1B,uBAAe,GAAG,UAAS2B,eAAwB;EAC9DC,yBAAW,CAACC,WAAW,EAAE,CAACF,eAAe,CAACA,eAAe,CAAC;AAC5D,CAAC","names":["exports","PersistentConnection_1","prototype","simpleListen","pathString","onComplete","sendRequest","p","echo","data","onEcho","d","Connection_1","newHash","oldPut","put","opt_onComplete","opt_hash","undefined","call","RepoInfo_1","query","queryIdentifier","firebaseRef","repo","persistentConnection_","listens_","forceRestClient","RepoManager_1","getInstance"],"sources":["../src/api/test_access.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RepoInfo } from '../core/RepoInfo';\nimport { PersistentConnection } from '../core/PersistentConnection';\nimport { RepoManager } from '../core/RepoManager';\nimport { Connection } from '../realtime/Connection';\nimport { Query } from './Query';\n\nexport const DataConnection = PersistentConnection;\n\n/**\n * @param {!string} pathString\n * @param {function(*)} onComplete\n */\n(PersistentConnection.prototype as any).simpleListen = function(\n  pathString: string,\n  onComplete: (a: any) => void\n) {\n  this.sendRequest('q', { p: pathString }, onComplete);\n};\n\n/**\n * @param {*} data\n * @param {function(*)} onEcho\n */\n(PersistentConnection.prototype as any).echo = function(\n  data: any,\n  onEcho: (a: any) => void\n) {\n  this.sendRequest('echo', { d: data }, onEcho);\n};\n\n// RealTimeConnection properties that we use in tests.\nexport const RealTimeConnection = Connection;\n\n/**\n * @param {function(): string} newHash\n * @return {function()}\n */\nexport const hijackHash = function(newHash: () => string) {\n  const oldPut = PersistentConnection.prototype.put;\n  PersistentConnection.prototype.put = function(\n    pathString,\n    data,\n    opt_onComplete,\n    opt_hash\n  ) {\n    if (opt_hash !== undefined) {\n      opt_hash = newHash();\n    }\n    oldPut.call(this, pathString, data, opt_onComplete, opt_hash);\n  };\n  return function() {\n    PersistentConnection.prototype.put = oldPut;\n  };\n};\n\n/**\n * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}\n */\nexport const ConnectionTarget = RepoInfo;\n\n/**\n * @param {!Query} query\n * @return {!string}\n */\nexport const queryIdentifier = function(query: Query) {\n  return query.queryIdentifier();\n};\n\n/**\n * @param {!Query} firebaseRef\n * @return {!Object}\n */\nexport const listens = function(firebaseRef: Query) {\n  return (firebaseRef.repo.persistentConnection_ as any).listens_;\n};\n\n/**\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\n *\n * @param {boolean} forceRestClient\n */\nexport const forceRestClient = function(forceRestClient: boolean) {\n  RepoManager.getInstance().forceRestClient(forceRestClient);\n};\n"]},"metadata":{},"sourceType":"script"}