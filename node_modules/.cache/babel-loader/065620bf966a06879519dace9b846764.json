{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar validation_1 = require(\"../core/util/validation\");\nvar Path_1 = require(\"../core/util/Path\");\nvar PriorityIndex_1 = require(\"../core/snap/indexes/PriorityIndex\");\n/**\n * Class representing a firebase data snapshot.  It wraps a SnapshotNode and\n * surfaces the public methods (val, forEach, etc.) we want to expose.\n */\nvar DataSnapshot = /** @class */function () {\n  /**\n   * @param {!Node} node_ A SnapshotNode to wrap.\n   * @param {!Reference} ref_ The ref of the location this snapshot came from.\n   * @param {!Index} index_ The iteration order for this snapshot\n   */\n  function DataSnapshot(node_, ref_, index_) {\n    this.node_ = node_;\n    this.ref_ = ref_;\n    this.index_ = index_;\n  }\n  /**\n   * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is\n   * empty.\n   *\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n  DataSnapshot.prototype.val = function () {\n    util_1.validateArgCount('DataSnapshot.val', 0, 0, arguments.length);\n    return this.node_.val();\n  };\n  /**\n   * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting\n   * the entire node contents.\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n  DataSnapshot.prototype.exportVal = function () {\n    util_1.validateArgCount('DataSnapshot.exportVal', 0, 0, arguments.length);\n    return this.node_.val(true);\n  };\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users\n  DataSnapshot.prototype.toJSON = function () {\n    // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content\n    util_1.validateArgCount('DataSnapshot.toJSON', 0, 1, arguments.length);\n    return this.exportVal();\n  };\n  /**\n   * Returns whether the snapshot contains a non-null value.\n   *\n   * @return {boolean} Whether the snapshot contains a non-null value, or is empty.\n   */\n  DataSnapshot.prototype.exists = function () {\n    util_1.validateArgCount('DataSnapshot.exists', 0, 0, arguments.length);\n    return !this.node_.isEmpty();\n  };\n  /**\n   * Returns a DataSnapshot of the specified child node's contents.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {!DataSnapshot} DataSnapshot for child node.\n   */\n  DataSnapshot.prototype.child = function (childPathString) {\n    util_1.validateArgCount('DataSnapshot.child', 0, 1, arguments.length);\n    // Ensure the childPath is a string (can be a number)\n    childPathString = String(childPathString);\n    validation_1.validatePathString('DataSnapshot.child', 1, childPathString, false);\n    var childPath = new Path_1.Path(childPathString);\n    var childRef = this.ref_.child(childPath);\n    return new DataSnapshot(this.node_.getChild(childPath), childRef, PriorityIndex_1.PRIORITY_INDEX);\n  };\n  /**\n   * Returns whether the snapshot contains a child at the specified path.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {boolean} Whether the child exists.\n   */\n  DataSnapshot.prototype.hasChild = function (childPathString) {\n    util_1.validateArgCount('DataSnapshot.hasChild', 1, 1, arguments.length);\n    validation_1.validatePathString('DataSnapshot.hasChild', 1, childPathString, false);\n    var childPath = new Path_1.Path(childPathString);\n    return !this.node_.getChild(childPath).isEmpty();\n  };\n  /**\n   * Returns the priority of the object, or null if no priority was set.\n   *\n   * @return {string|number|null} The priority.\n   */\n  DataSnapshot.prototype.getPriority = function () {\n    util_1.validateArgCount('DataSnapshot.getPriority', 0, 0, arguments.length);\n    // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\n    return this.node_.getPriority().val();\n  };\n  /**\n   * Iterates through child nodes and calls the specified action for each one.\n   *\n   * @param {function(!DataSnapshot)} action Callback function to be called\n   * for each child.\n   * @return {boolean} True if forEach was canceled by action returning true for\n   * one of the child nodes.\n   */\n  DataSnapshot.prototype.forEach = function (action) {\n    var _this = this;\n    util_1.validateArgCount('DataSnapshot.forEach', 1, 1, arguments.length);\n    util_1.validateCallback('DataSnapshot.forEach', 1, action, false);\n    if (this.node_.isLeafNode()) return false;\n    var childrenNode = this.node_;\n    // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\n    return !!childrenNode.forEachChild(this.index_, function (key, node) {\n      return action(new DataSnapshot(node, _this.ref_.child(key), PriorityIndex_1.PRIORITY_INDEX));\n    });\n  };\n  /**\n   * Returns whether this DataSnapshot has children.\n   * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.\n   */\n  DataSnapshot.prototype.hasChildren = function () {\n    util_1.validateArgCount('DataSnapshot.hasChildren', 0, 0, arguments.length);\n    if (this.node_.isLeafNode()) return false;else return !this.node_.isEmpty();\n  };\n  Object.defineProperty(DataSnapshot.prototype, \"key\", {\n    get: function () {\n      return this.ref_.getKey();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns the number of children for this DataSnapshot.\n   * @return {number} The number of children that this DataSnapshot contains.\n   */\n  DataSnapshot.prototype.numChildren = function () {\n    util_1.validateArgCount('DataSnapshot.numChildren', 0, 0, arguments.length);\n    return this.node_.numChildren();\n  };\n  /**\n   * @return {Reference} The Firebase reference for the location this snapshot's data came from.\n   */\n  DataSnapshot.prototype.getRef = function () {\n    util_1.validateArgCount('DataSnapshot.ref', 0, 0, arguments.length);\n    return this.ref_;\n  };\n  Object.defineProperty(DataSnapshot.prototype, \"ref\", {\n    get: function () {\n      return this.getRef();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DataSnapshot;\n}();\nexports.DataSnapshot = DataSnapshot;","map":{"version":3,"mappings":"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","names":["node_","ref_","index_","DataSnapshot","util_1","arguments","length","val","exportVal","isEmpty","childPathString","String","validation_1","childPath","Path_1","childRef","child","getChild","PriorityIndex_1","getPriority","action","isLeafNode","childrenNode","forEachChild","key","node","_this","Object","getKey","numChildren","getRef","exports"],"sources":["../src/api/DataSnapshot.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { validateArgCount, validateCallback } from '@firebase/util';\nimport { validatePathString } from '../core/util/validation';\nimport { Path } from '../core/util/Path';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { Node } from '../core/snap/Node';\nimport { Reference } from './Reference';\nimport { Index } from '../core/snap/indexes/Index';\nimport { ChildrenNode } from '../core/snap/ChildrenNode';\n\n/**\n * Class representing a firebase data snapshot.  It wraps a SnapshotNode and\n * surfaces the public methods (val, forEach, etc.) we want to expose.\n */\nexport class DataSnapshot {\n  /**\n   * @param {!Node} node_ A SnapshotNode to wrap.\n   * @param {!Reference} ref_ The ref of the location this snapshot came from.\n   * @param {!Index} index_ The iteration order for this snapshot\n   */\n  constructor(\n    private readonly node_: Node,\n    private readonly ref_: Reference,\n    private readonly index_: Index\n  ) {}\n\n  /**\n   * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is\n   * empty.\n   *\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n  val(): any {\n    validateArgCount('DataSnapshot.val', 0, 0, arguments.length);\n    return this.node_.val();\n  }\n\n  /**\n   * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting\n   * the entire node contents.\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n  exportVal(): any {\n    validateArgCount('DataSnapshot.exportVal', 0, 0, arguments.length);\n    return this.node_.val(true);\n  }\n\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users\n  toJSON(): any {\n    // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content\n    validateArgCount('DataSnapshot.toJSON', 0, 1, arguments.length);\n    return this.exportVal();\n  }\n\n  /**\n   * Returns whether the snapshot contains a non-null value.\n   *\n   * @return {boolean} Whether the snapshot contains a non-null value, or is empty.\n   */\n  exists(): boolean {\n    validateArgCount('DataSnapshot.exists', 0, 0, arguments.length);\n    return !this.node_.isEmpty();\n  }\n\n  /**\n   * Returns a DataSnapshot of the specified child node's contents.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {!DataSnapshot} DataSnapshot for child node.\n   */\n  child(childPathString: string): DataSnapshot {\n    validateArgCount('DataSnapshot.child', 0, 1, arguments.length);\n    // Ensure the childPath is a string (can be a number)\n    childPathString = String(childPathString);\n    validatePathString('DataSnapshot.child', 1, childPathString, false);\n\n    const childPath = new Path(childPathString);\n    const childRef = this.ref_.child(childPath);\n    return new DataSnapshot(\n      this.node_.getChild(childPath),\n      childRef,\n      PRIORITY_INDEX\n    );\n  }\n\n  /**\n   * Returns whether the snapshot contains a child at the specified path.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {boolean} Whether the child exists.\n   */\n  hasChild(childPathString: string): boolean {\n    validateArgCount('DataSnapshot.hasChild', 1, 1, arguments.length);\n    validatePathString('DataSnapshot.hasChild', 1, childPathString, false);\n\n    const childPath = new Path(childPathString);\n    return !this.node_.getChild(childPath).isEmpty();\n  }\n\n  /**\n   * Returns the priority of the object, or null if no priority was set.\n   *\n   * @return {string|number|null} The priority.\n   */\n  getPriority(): string | number | null {\n    validateArgCount('DataSnapshot.getPriority', 0, 0, arguments.length);\n\n    // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\n    return this.node_.getPriority().val() as string | number | null;\n  }\n\n  /**\n   * Iterates through child nodes and calls the specified action for each one.\n   *\n   * @param {function(!DataSnapshot)} action Callback function to be called\n   * for each child.\n   * @return {boolean} True if forEach was canceled by action returning true for\n   * one of the child nodes.\n   */\n  forEach(action: (d: DataSnapshot) => void): boolean {\n    validateArgCount('DataSnapshot.forEach', 1, 1, arguments.length);\n    validateCallback('DataSnapshot.forEach', 1, action, false);\n\n    if (this.node_.isLeafNode()) return false;\n\n    const childrenNode = this.node_ as ChildrenNode;\n    // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\n    return !!childrenNode.forEachChild(this.index_, (key, node) => {\n      return action(\n        new DataSnapshot(node, this.ref_.child(key), PRIORITY_INDEX)\n      );\n    });\n  }\n\n  /**\n   * Returns whether this DataSnapshot has children.\n   * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.\n   */\n  hasChildren(): boolean {\n    validateArgCount('DataSnapshot.hasChildren', 0, 0, arguments.length);\n\n    if (this.node_.isLeafNode()) return false;\n    else return !this.node_.isEmpty();\n  }\n\n  get key() {\n    return this.ref_.getKey();\n  }\n\n  /**\n   * Returns the number of children for this DataSnapshot.\n   * @return {number} The number of children that this DataSnapshot contains.\n   */\n  numChildren(): number {\n    validateArgCount('DataSnapshot.numChildren', 0, 0, arguments.length);\n\n    return this.node_.numChildren();\n  }\n\n  /**\n   * @return {Reference} The Firebase reference for the location this snapshot's data came from.\n   */\n  getRef(): Reference {\n    validateArgCount('DataSnapshot.ref', 0, 0, arguments.length);\n\n    return this.ref_;\n  }\n\n  get ref() {\n    return this.getRef();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}