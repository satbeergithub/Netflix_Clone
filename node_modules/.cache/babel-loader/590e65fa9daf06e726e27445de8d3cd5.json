{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar Repo_1 = require(\"./Repo\");\nvar util_2 = require(\"./util/util\");\nvar parser_1 = require(\"./util/libs/parser\");\nvar validation_1 = require(\"./util/validation\");\nrequire(\"./Repo_transaction\");\n/** @const {string} */\nvar DATABASE_URL_OPTION = 'databaseURL';\nvar _staticInstance;\n/**\n * Creates and caches Repo instances.\n */\nvar RepoManager = /** @class */function () {\n  function RepoManager() {\n    /**\n     * @private {!Object.<string, Object<string, !fb.core.Repo>>}\n     */\n    this.repos_ = {};\n    /**\n     * If true, new Repos will be created to use ReadonlyRestClient (for testing purposes).\n     * @private {boolean}\n     */\n    this.useRestClient_ = false;\n  }\n  RepoManager.getInstance = function () {\n    if (!_staticInstance) {\n      _staticInstance = new RepoManager();\n    }\n    return _staticInstance;\n  };\n  // TODO(koss): Remove these functions unless used in tests?\n  RepoManager.prototype.interrupt = function () {\n    for (var appName in this.repos_) {\n      for (var dbUrl in this.repos_[appName]) {\n        this.repos_[appName][dbUrl].interrupt();\n      }\n    }\n  };\n  RepoManager.prototype.resume = function () {\n    for (var appName in this.repos_) {\n      for (var dbUrl in this.repos_[appName]) {\n        this.repos_[appName][dbUrl].resume();\n      }\n    }\n  };\n  /**\n   * This function should only ever be called to CREATE a new database instance.\n   *\n   * @param {!FirebaseApp} app\n   * @return {!Database}\n   */\n  RepoManager.prototype.databaseFromApp = function (app, url) {\n    var dbUrl = url || app.options[DATABASE_URL_OPTION];\n    if (dbUrl === undefined) {\n      util_2.fatal(\"Can't determine Firebase Database URL.  Be sure to include \" + DATABASE_URL_OPTION + ' option when calling firebase.intializeApp().');\n    }\n    var parsedUrl = parser_1.parseRepoInfo(dbUrl);\n    var repoInfo = parsedUrl.repoInfo;\n    validation_1.validateUrl('Invalid Firebase Database URL', 1, parsedUrl);\n    if (!parsedUrl.path.isEmpty()) {\n      util_2.fatal('Database URL must point to the root of a Firebase Database ' + '(not including a child path).');\n    }\n    var repo = this.createRepo(repoInfo, app);\n    return repo.database;\n  };\n  /**\n   * Remove the repo and make sure it is disconnected.\n   *\n   * @param {!Repo} repo\n   */\n  RepoManager.prototype.deleteRepo = function (repo) {\n    var appRepos = util_1.safeGet(this.repos_, repo.app.name);\n    // This should never happen...\n    if (!appRepos || util_1.safeGet(appRepos, repo.repoInfo_.toURLString()) !== repo) {\n      util_2.fatal(\"Database \" + repo.app.name + \"(\" + repo.repoInfo_ + \") has already been deleted.\");\n    }\n    repo.interrupt();\n    delete appRepos[repo.repoInfo_.toURLString()];\n  };\n  /**\n   * Ensures a repo doesn't already exist and then creates one using the\n   * provided app.\n   *\n   * @param {!RepoInfo} repoInfo The metadata about the Repo\n   * @param {!FirebaseApp} app\n   * @return {!Repo} The Repo object for the specified server / repoName.\n   */\n  RepoManager.prototype.createRepo = function (repoInfo, app) {\n    var appRepos = util_1.safeGet(this.repos_, app.name);\n    if (!appRepos) {\n      appRepos = {};\n      this.repos_[app.name] = appRepos;\n    }\n    var repo = util_1.safeGet(appRepos, repoInfo.toURLString());\n    if (repo) {\n      util_2.fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');\n    }\n    repo = new Repo_1.Repo(repoInfo, this.useRestClient_, app);\n    appRepos[repoInfo.toURLString()] = repo;\n    return repo;\n  };\n  /**\n   * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.\n   * @param {boolean} forceRestClient\n   */\n  RepoManager.prototype.forceRestClient = function (forceRestClient) {\n    this.useRestClient_ = forceRestClient;\n  };\n  return RepoManager;\n}();\nexports.RepoManager = RepoManager;","map":{"version":3,"mappings":"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","names":["require","DATABASE_URL_OPTION","_staticInstance","RepoManager","appName","repos_","dbUrl","interrupt","resume","app","url","options","undefined","util_2","parsedUrl","parser_1","repoInfo","validation_1","path","isEmpty","repo","createRepo","database","appRepos","util_1","name","repoInfo_","toURLString","Repo_1","useRestClient_","forceRestClient","exports"],"sources":["../src/core/RepoManager.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app';\nimport { safeGet } from '@firebase/util';\nimport { Repo } from './Repo';\nimport { fatal } from './util/util';\nimport { parseRepoInfo } from './util/libs/parser';\nimport { validateUrl } from './util/validation';\nimport './Repo_transaction';\nimport { Database } from '../api/Database';\nimport { RepoInfo } from './RepoInfo';\n\n/** @const {string} */\nconst DATABASE_URL_OPTION = 'databaseURL';\n\nlet _staticInstance: RepoManager;\n\n/**\n * Creates and caches Repo instances.\n */\nexport class RepoManager {\n  /**\n   * @private {!Object.<string, Object<string, !fb.core.Repo>>}\n   */\n  private repos_: {\n    [appName: string]: {\n      [dbUrl: string]: Repo;\n    };\n  } = {};\n\n  /**\n   * If true, new Repos will be created to use ReadonlyRestClient (for testing purposes).\n   * @private {boolean}\n   */\n  private useRestClient_: boolean = false;\n\n  static getInstance(): RepoManager {\n    if (!_staticInstance) {\n      _staticInstance = new RepoManager();\n    }\n    return _staticInstance;\n  }\n\n  // TODO(koss): Remove these functions unless used in tests?\n  interrupt() {\n    for (const appName in this.repos_) {\n      for (const dbUrl in this.repos_[appName]) {\n        this.repos_[appName][dbUrl].interrupt();\n      }\n    }\n  }\n\n  resume() {\n    for (const appName in this.repos_) {\n      for (const dbUrl in this.repos_[appName]) {\n        this.repos_[appName][dbUrl].resume();\n      }\n    }\n  }\n\n  /**\n   * This function should only ever be called to CREATE a new database instance.\n   *\n   * @param {!FirebaseApp} app\n   * @return {!Database}\n   */\n  databaseFromApp(app: FirebaseApp, url?: string): Database {\n    const dbUrl: string = url || app.options[DATABASE_URL_OPTION];\n    if (dbUrl === undefined) {\n      fatal(\n        \"Can't determine Firebase Database URL.  Be sure to include \" +\n          DATABASE_URL_OPTION +\n          ' option when calling firebase.intializeApp().'\n      );\n    }\n\n    const parsedUrl = parseRepoInfo(dbUrl);\n    const repoInfo = parsedUrl.repoInfo;\n\n    validateUrl('Invalid Firebase Database URL', 1, parsedUrl);\n    if (!parsedUrl.path.isEmpty()) {\n      fatal(\n        'Database URL must point to the root of a Firebase Database ' +\n          '(not including a child path).'\n      );\n    }\n\n    const repo = this.createRepo(repoInfo, app);\n\n    return repo.database;\n  }\n\n  /**\n   * Remove the repo and make sure it is disconnected.\n   *\n   * @param {!Repo} repo\n   */\n  deleteRepo(repo: Repo) {\n    const appRepos = safeGet(this.repos_, repo.app.name);\n    // This should never happen...\n    if (!appRepos || safeGet(appRepos, repo.repoInfo_.toURLString()) !== repo) {\n      fatal(\n        `Database ${repo.app.name}(${repo.repoInfo_}) has already been deleted.`\n      );\n    }\n    repo.interrupt();\n    delete appRepos[repo.repoInfo_.toURLString()];\n  }\n\n  /**\n   * Ensures a repo doesn't already exist and then creates one using the\n   * provided app.\n   *\n   * @param {!RepoInfo} repoInfo The metadata about the Repo\n   * @param {!FirebaseApp} app\n   * @return {!Repo} The Repo object for the specified server / repoName.\n   */\n  createRepo(repoInfo: RepoInfo, app: FirebaseApp): Repo {\n    let appRepos = safeGet(this.repos_, app.name);\n\n    if (!appRepos) {\n      appRepos = {};\n      this.repos_[app.name] = appRepos;\n    }\n\n    let repo = safeGet(appRepos, repoInfo.toURLString());\n    if (repo) {\n      fatal(\n        'Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.'\n      );\n    }\n    repo = new Repo(repoInfo, this.useRestClient_, app);\n    appRepos[repoInfo.toURLString()] = repo;\n\n    return repo;\n  }\n\n  /**\n   * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.\n   * @param {boolean} forceRestClient\n   */\n  forceRestClient(forceRestClient: boolean) {\n    this.useRestClient_ = forceRestClient;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}