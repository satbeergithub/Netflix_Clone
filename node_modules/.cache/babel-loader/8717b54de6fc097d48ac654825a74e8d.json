{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar RangedFilter_1 = require(\"./RangedFilter\");\nvar ChildrenNode_1 = require(\"../../snap/ChildrenNode\");\nvar Node_1 = require(\"../../snap/Node\");\nvar util_1 = require(\"@firebase/util\");\nvar Change_1 = require(\"../Change\");\n/**\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\n *\n * @constructor\n * @implements {NodeFilter}\n */\nvar LimitedFilter = /** @class */function () {\n  /**\n   * @param {!QueryParams} params\n   */\n  function LimitedFilter(params) {\n    this.rangedFilter_ = new RangedFilter_1.RangedFilter(params);\n    this.index_ = params.getIndex();\n    this.limit_ = params.getLimit();\n    this.reverse_ = !params.isViewFromLeft();\n  }\n  /**\n   * @inheritDoc\n   */\n  LimitedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n    if (!this.rangedFilter_.matches(new Node_1.NamedNode(key, newChild))) {\n      newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    }\n    if (snap.getImmediateChild(key).equals(newChild)) {\n      // No change\n      return snap;\n    } else if (snap.numChildren() < this.limit_) {\n      return this.rangedFilter_.getIndexedFilter().updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n    } else {\n      return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  LimitedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n    var filtered;\n    if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      filtered = ChildrenNode_1.ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n    } else {\n      if (this.limit_ * 2 < newSnap.numChildren() && newSnap.isIndexed(this.index_)) {\n        // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n        filtered = ChildrenNode_1.ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n        // anchor to the startPost, endPost, or last element as appropriate\n        var iterator = void 0;\n        if (this.reverse_) {\n          iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);\n        } else {\n          iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);\n        }\n        var count = 0;\n        while (iterator.hasNext() && count < this.limit_) {\n          var next = iterator.getNext();\n          var inRange = void 0;\n          if (this.reverse_) {\n            inRange = this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;\n          } else {\n            inRange = this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;\n          }\n          if (inRange) {\n            filtered = filtered.updateImmediateChild(next.name, next.node);\n            count++;\n          } else {\n            // if we have reached the end post, we cannot keep adding elemments\n            break;\n          }\n        }\n      } else {\n        // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n        filtered = newSnap.withIndex(this.index_);\n        // Don't support priorities on queries\n        filtered = filtered.updatePriority(ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n        var startPost = void 0;\n        var endPost = void 0;\n        var cmp = void 0;\n        var iterator = void 0;\n        if (this.reverse_) {\n          iterator = filtered.getReverseIterator(this.index_);\n          startPost = this.rangedFilter_.getEndPost();\n          endPost = this.rangedFilter_.getStartPost();\n          var indexCompare_1 = this.index_.getCompare();\n          cmp = function cmp(a, b) {\n            return indexCompare_1(b, a);\n          };\n        } else {\n          iterator = filtered.getIterator(this.index_);\n          startPost = this.rangedFilter_.getStartPost();\n          endPost = this.rangedFilter_.getEndPost();\n          cmp = this.index_.getCompare();\n        }\n        var count = 0;\n        var foundStartPost = false;\n        while (iterator.hasNext()) {\n          var next = iterator.getNext();\n          if (!foundStartPost && cmp(startPost, next) <= 0) {\n            // start adding\n            foundStartPost = true;\n          }\n          var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;\n          if (inRange) {\n            count++;\n          } else {\n            filtered = filtered.updateImmediateChild(next.name, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n          }\n        }\n      }\n    }\n    return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap, filtered, optChangeAccumulator);\n  };\n  /**\n   * @inheritDoc\n   */\n  LimitedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n    // Don't support priorities on queries\n    return oldSnap;\n  };\n  /**\n   * @inheritDoc\n   */\n  LimitedFilter.prototype.filtersNodes = function () {\n    return true;\n  };\n  /**\n   * @inheritDoc\n   */\n  LimitedFilter.prototype.getIndexedFilter = function () {\n    return this.rangedFilter_.getIndexedFilter();\n  };\n  /**\n   * @inheritDoc\n   */\n  LimitedFilter.prototype.getIndex = function () {\n    return this.index_;\n  };\n  /**\n   * @param {!Node} snap\n   * @param {string} childKey\n   * @param {!Node} childSnap\n   * @param {!CompleteChildSource} source\n   * @param {?ChildChangeAccumulator} changeAccumulator\n   * @return {!Node}\n   * @private\n   */\n  LimitedFilter.prototype.fullLimitUpdateChild_ = function (snap, childKey, childSnap, source, changeAccumulator) {\n    // TODO: rename all cache stuff etc to general snap terminology\n    var cmp;\n    if (this.reverse_) {\n      var indexCmp_1 = this.index_.getCompare();\n      cmp = function cmp(a, b) {\n        return indexCmp_1(b, a);\n      };\n    } else {\n      cmp = this.index_.getCompare();\n    }\n    var oldEventCache = snap;\n    util_1.assert(oldEventCache.numChildren() == this.limit_, '');\n    var newChildNamedNode = new Node_1.NamedNode(childKey, childSnap);\n    var windowBoundary = this.reverse_ ? oldEventCache.getFirstChild(this.index_) : oldEventCache.getLastChild(this.index_);\n    var inRange = this.rangedFilter_.matches(newChildNamedNode);\n    if (oldEventCache.hasChild(childKey)) {\n      var oldChildSnap = oldEventCache.getImmediateChild(childKey);\n      var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);\n      while (nextChild != null && (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))) {\n        // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n        // been applied to the limited filter yet. Ignore this next child which will be updated later in\n        // the limited filter...\n        nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);\n      }\n      var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n      var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;\n      if (remainsInWindow) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(Change_1.Change.childChangedChange(childKey, childSnap, oldChildSnap));\n        }\n        return oldEventCache.updateImmediateChild(childKey, childSnap);\n      } else {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(childKey, oldChildSnap));\n        }\n        var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n        var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);\n        if (nextChildInRange) {\n          if (changeAccumulator != null) {\n            changeAccumulator.trackChildChange(Change_1.Change.childAddedChange(nextChild.name, nextChild.node));\n          }\n          return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);\n        } else {\n          return newEventCache;\n        }\n      }\n    } else if (childSnap.isEmpty()) {\n      // we're deleting a node, but it was not in the window, so ignore it\n      return snap;\n    } else if (inRange) {\n      if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(windowBoundary.name, windowBoundary.node));\n          changeAccumulator.trackChildChange(Change_1.Change.childAddedChange(childKey, childSnap));\n        }\n        return oldEventCache.updateImmediateChild(childKey, childSnap).updateImmediateChild(windowBoundary.name, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n      } else {\n        return snap;\n      }\n    } else {\n      return snap;\n    }\n  };\n  return LimitedFilter;\n}();\nexports.LimitedFilter = LimitedFilter;","map":{"version":3,"mappings":"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","names":["params","rangedFilter_","RangedFilter_1","index_","getIndex","limit_","getLimit","reverse_","isViewFromLeft","LimitedFilter","snap","key","newChild","affectedPath","source","optChangeAccumulator","matches","Node_1","ChildrenNode_1","EMPTY_NODE","getImmediateChild","equals","numChildren","getIndexedFilter","updateChild","fullLimitUpdateChild_","oldSnap","newSnap","filtered","isLeafNode","isEmpty","withIndex","isIndexed","iterator","getReverseIteratorFrom","getEndPost","getIteratorFrom","getStartPost","count","hasNext","next","getNext","inRange","compare","updateImmediateChild","name","node","updatePriority","startPost","endPost","cmp","getReverseIterator","indexCompare_1","getCompare","a","b","getIterator","foundStartPost","updateFullNode","newPriority","childKey","childSnap","changeAccumulator","indexCmp_1","oldEventCache","util_1","newChildNamedNode","windowBoundary","getFirstChild","getLastChild","hasChild","oldChildSnap","nextChild","getChildAfterChild","compareNext","remainsInWindow","trackChildChange","Change_1","childChangedChange","childRemovedChange","newEventCache","nextChildInRange","childAddedChange","exports"],"sources":["../src/core/view/filter/LimitedFilter.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RangedFilter } from './RangedFilter';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { Node, NamedNode } from '../../snap/Node';\nimport { assert } from '@firebase/util';\nimport { Change } from '../Change';\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { IndexedFilter } from './IndexedFilter';\nimport { QueryParams } from '../QueryParams';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\n\n/**\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\n *\n * @constructor\n * @implements {NodeFilter}\n */\nexport class LimitedFilter implements NodeFilter {\n  /**\n   * @const\n   * @type {RangedFilter}\n   * @private\n   */\n  private readonly rangedFilter_: RangedFilter;\n\n  /**\n   * @const\n   * @type {!Index}\n   * @private\n   */\n  private readonly index_: Index;\n\n  /**\n   * @const\n   * @type {number}\n   * @private\n   */\n  private readonly limit_: number;\n\n  /**\n   * @const\n   * @type {boolean}\n   * @private\n   */\n  private readonly reverse_: boolean;\n\n  /**\n   * @param {!QueryParams} params\n   */\n  constructor(params: QueryParams) {\n    this.rangedFilter_ = new RangedFilter(params);\n    this.index_ = params.getIndex();\n    this.limit_ = params.getLimit();\n    this.reverse_ = !params.isViewFromLeft();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\n      newChild = ChildrenNode.EMPTY_NODE;\n    }\n    if (snap.getImmediateChild(key).equals(newChild)) {\n      // No change\n      return snap;\n    } else if (snap.numChildren() < this.limit_) {\n      return this.rangedFilter_\n        .getIndexedFilter()\n        .updateChild(\n          snap,\n          key,\n          newChild,\n          affectedPath,\n          source,\n          optChangeAccumulator\n        );\n    } else {\n      return this.fullLimitUpdateChild_(\n        snap,\n        key,\n        newChild,\n        source,\n        optChangeAccumulator\n      );\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    let filtered;\n    if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n    } else {\n      if (\n        this.limit_ * 2 < newSnap.numChildren() &&\n        newSnap.isIndexed(this.index_)\n      ) {\n        // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n        filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n        // anchor to the startPost, endPost, or last element as appropriate\n        let iterator;\n        if (this.reverse_) {\n          iterator = (newSnap as ChildrenNode).getReverseIteratorFrom(\n            this.rangedFilter_.getEndPost(),\n            this.index_\n          );\n        } else {\n          iterator = (newSnap as ChildrenNode).getIteratorFrom(\n            this.rangedFilter_.getStartPost(),\n            this.index_\n          );\n        }\n        let count = 0;\n        while (iterator.hasNext() && count < this.limit_) {\n          const next = iterator.getNext();\n          let inRange;\n          if (this.reverse_) {\n            inRange =\n              this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;\n          } else {\n            inRange =\n              this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;\n          }\n          if (inRange) {\n            filtered = filtered.updateImmediateChild(next.name, next.node);\n            count++;\n          } else {\n            // if we have reached the end post, we cannot keep adding elemments\n            break;\n          }\n        }\n      } else {\n        // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n        filtered = newSnap.withIndex(this.index_);\n        // Don't support priorities on queries\n        filtered = filtered.updatePriority(\n          ChildrenNode.EMPTY_NODE\n        ) as ChildrenNode;\n        let startPost;\n        let endPost;\n        let cmp;\n        let iterator;\n        if (this.reverse_) {\n          iterator = filtered.getReverseIterator(this.index_);\n          startPost = this.rangedFilter_.getEndPost();\n          endPost = this.rangedFilter_.getStartPost();\n          const indexCompare = this.index_.getCompare();\n          cmp = (a: NamedNode, b: NamedNode) => indexCompare(b, a);\n        } else {\n          iterator = filtered.getIterator(this.index_);\n          startPost = this.rangedFilter_.getStartPost();\n          endPost = this.rangedFilter_.getEndPost();\n          cmp = this.index_.getCompare();\n        }\n\n        let count = 0;\n        let foundStartPost = false;\n        while (iterator.hasNext()) {\n          let next = iterator.getNext();\n          if (!foundStartPost && cmp(startPost, next) <= 0) {\n            // start adding\n            foundStartPost = true;\n          }\n          let inRange =\n            foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;\n          if (inRange) {\n            count++;\n          } else {\n            filtered = filtered.updateImmediateChild(\n              next.name,\n              ChildrenNode.EMPTY_NODE\n            );\n          }\n        }\n      }\n    }\n    return this.rangedFilter_\n      .getIndexedFilter()\n      .updateFullNode(oldSnap, filtered, optChangeAccumulator);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    // Don't support priorities on queries\n    return oldSnap;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this.rangedFilter_.getIndexedFilter();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n\n  /**\n   * @param {!Node} snap\n   * @param {string} childKey\n   * @param {!Node} childSnap\n   * @param {!CompleteChildSource} source\n   * @param {?ChildChangeAccumulator} changeAccumulator\n   * @return {!Node}\n   * @private\n   */\n  private fullLimitUpdateChild_(\n    snap: Node,\n    childKey: string,\n    childSnap: Node,\n    source: CompleteChildSource,\n    changeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    // TODO: rename all cache stuff etc to general snap terminology\n    let cmp;\n    if (this.reverse_) {\n      const indexCmp = this.index_.getCompare();\n      cmp = (a: NamedNode, b: NamedNode) => indexCmp(b, a);\n    } else {\n      cmp = this.index_.getCompare();\n    }\n    const oldEventCache = snap as ChildrenNode;\n    assert(oldEventCache.numChildren() == this.limit_, '');\n    const newChildNamedNode = new NamedNode(childKey, childSnap);\n    const windowBoundary = this.reverse_\n      ? oldEventCache.getFirstChild(this.index_)\n      : (oldEventCache.getLastChild(this.index_) as NamedNode);\n    const inRange = this.rangedFilter_.matches(newChildNamedNode);\n    if (oldEventCache.hasChild(childKey)) {\n      const oldChildSnap = oldEventCache.getImmediateChild(childKey);\n      let nextChild = source.getChildAfterChild(\n        this.index_,\n        windowBoundary,\n        this.reverse_\n      );\n      while (\n        nextChild != null &&\n        (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))\n      ) {\n        // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n        // been applied to the limited filter yet. Ignore this next child which will be updated later in\n        // the limited filter...\n        nextChild = source.getChildAfterChild(\n          this.index_,\n          nextChild,\n          this.reverse_\n        );\n      }\n      const compareNext =\n        nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n      const remainsInWindow =\n        inRange && !childSnap.isEmpty() && compareNext >= 0;\n      if (remainsInWindow) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childChangedChange(childKey, childSnap, oldChildSnap)\n          );\n        }\n        return oldEventCache.updateImmediateChild(childKey, childSnap);\n      } else {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childRemovedChange(childKey, oldChildSnap)\n          );\n        }\n        const newEventCache = oldEventCache.updateImmediateChild(\n          childKey,\n          ChildrenNode.EMPTY_NODE\n        );\n        const nextChildInRange =\n          nextChild != null && this.rangedFilter_.matches(nextChild);\n        if (nextChildInRange) {\n          if (changeAccumulator != null) {\n            changeAccumulator.trackChildChange(\n              Change.childAddedChange(nextChild.name, nextChild.node)\n            );\n          }\n          return newEventCache.updateImmediateChild(\n            nextChild.name,\n            nextChild.node\n          );\n        } else {\n          return newEventCache;\n        }\n      }\n    } else if (childSnap.isEmpty()) {\n      // we're deleting a node, but it was not in the window, so ignore it\n      return snap;\n    } else if (inRange) {\n      if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n        if (changeAccumulator != null) {\n          changeAccumulator.trackChildChange(\n            Change.childRemovedChange(windowBoundary.name, windowBoundary.node)\n          );\n          changeAccumulator.trackChildChange(\n            Change.childAddedChange(childKey, childSnap)\n          );\n        }\n        return oldEventCache\n          .updateImmediateChild(childKey, childSnap)\n          .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\n      } else {\n        return snap;\n      }\n    } else {\n      return snap;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}