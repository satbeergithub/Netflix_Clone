{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar app_1 = require(\"@firebase/app\");\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"@firebase/util\");\nvar util_3 = require(\"@firebase/util\");\nvar util_4 = require(\"./util/util\");\nvar Path_1 = require(\"./util/Path\");\nvar VisibilityMonitor_1 = require(\"./util/VisibilityMonitor\");\nvar OnlineMonitor_1 = require(\"./util/OnlineMonitor\");\nvar util_5 = require(\"@firebase/util\");\nvar Connection_1 = require(\"../realtime/Connection\");\nvar util_6 = require(\"@firebase/util\");\nvar util_7 = require(\"@firebase/util\");\nvar ServerActions_1 = require(\"./ServerActions\");\nvar RECONNECT_MIN_DELAY = 1000;\nvar RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\nvar RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\nvar RECONNECT_DELAY_MULTIPLIER = 1.3;\nvar RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\nvar SERVER_KILL_INTERRUPT_REASON = 'server_kill';\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nvar INVALID_AUTH_TOKEN_THRESHOLD = 3;\n/**\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\n *\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\n * in quotes to make sure the closure compiler does not minify them.\n */\nvar PersistentConnection = /** @class */function (_super) {\n  __extends(PersistentConnection, _super);\n  /**\n   * @implements {ServerActions}\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param onConnectStatus_\n   * @param onServerInfoUpdate_\n   * @param authTokenProvider_\n   * @param authOverride_\n   */\n  function PersistentConnection(repoInfo_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, authOverride_) {\n    var _this = _super.call(this) || this;\n    _this.repoInfo_ = repoInfo_;\n    _this.onDataUpdate_ = onDataUpdate_;\n    _this.onConnectStatus_ = onConnectStatus_;\n    _this.onServerInfoUpdate_ = onServerInfoUpdate_;\n    _this.authTokenProvider_ = authTokenProvider_;\n    _this.authOverride_ = authOverride_;\n    // Used for diagnostic logging.\n    _this.id = PersistentConnection.nextPersistentConnectionId_++;\n    _this.log_ = util_4.logWrapper('p:' + _this.id + ':');\n    /** @private {Object} */\n    _this.interruptReasons_ = {};\n    _this.listens_ = {};\n    _this.outstandingPuts_ = [];\n    _this.outstandingPutCount_ = 0;\n    _this.onDisconnectRequestQueue_ = [];\n    _this.connected_ = false;\n    _this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n    _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n    _this.securityDebugCallback_ = null;\n    _this.lastSessionId = null;\n    /** @private {number|null} */\n    _this.establishConnectionTimer_ = null;\n    /** @private {boolean} */\n    _this.visible_ = false;\n    // Before we get connected, we keep a queue of pending messages to send.\n    _this.requestCBHash_ = {};\n    _this.requestNumber_ = 0;\n    /** @private {?{\n     *   sendRequest(Object),\n     *   close()\n     * }} */\n    _this.realtime_ = null;\n    /** @private {string|null} */\n    _this.authToken_ = null;\n    _this.forceTokenRefresh_ = false;\n    _this.invalidAuthTokenCount_ = 0;\n    _this.firstConnection_ = true;\n    _this.lastConnectionAttemptTime_ = null;\n    _this.lastConnectionEstablishedTime_ = null;\n    if (authOverride_ && !util_7.isNodeSdk()) {\n      throw new Error('Auth override specified in options, but not supported on non Node.js platforms');\n    }\n    _this.scheduleConnect_(0);\n    VisibilityMonitor_1.VisibilityMonitor.getInstance().on('visible', _this.onVisible_, _this);\n    if (repoInfo_.host.indexOf('fblocal') === -1) {\n      OnlineMonitor_1.OnlineMonitor.getInstance().on('online', _this.onOnline_, _this);\n    }\n    return _this;\n  }\n  /**\n   * @param {!string} action\n   * @param {*} body\n   * @param {function(*)=} onResponse\n   * @protected\n   */\n  PersistentConnection.prototype.sendRequest = function (action, body, onResponse) {\n    var curReqNum = ++this.requestNumber_;\n    var msg = {\n      r: curReqNum,\n      a: action,\n      b: body\n    };\n    this.log_(util_2.stringify(msg));\n    util_3.assert(this.connected_, \"sendRequest call when we're not connected not allowed.\");\n    this.realtime_.sendRequest(msg);\n    if (onResponse) {\n      this.requestCBHash_[curReqNum] = onResponse;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  PersistentConnection.prototype.listen = function (query, currentHashFn, tag, onComplete) {\n    var queryId = query.queryIdentifier();\n    var pathString = query.path.toString();\n    this.log_('Listen called for ' + pathString + ' ' + queryId);\n    this.listens_[pathString] = this.listens_[pathString] || {};\n    util_3.assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(), 'listen() called for non-default but complete query');\n    util_3.assert(!this.listens_[pathString][queryId], 'listen() called twice for same path/queryId.');\n    var listenSpec = {\n      onComplete: onComplete,\n      hashFn: currentHashFn,\n      query: query,\n      tag: tag\n    };\n    this.listens_[pathString][queryId] = listenSpec;\n    if (this.connected_) {\n      this.sendListen_(listenSpec);\n    }\n  };\n  /**\n   * @param {!{onComplete(),\n   *           hashFn():!string,\n   *           query: !Query,\n   *           tag: ?number}} listenSpec\n   * @private\n   */\n  PersistentConnection.prototype.sendListen_ = function (listenSpec) {\n    var _this = this;\n    var query = listenSpec.query;\n    var pathString = query.path.toString();\n    var queryId = query.queryIdentifier();\n    this.log_('Listen on ' + pathString + ' for ' + queryId);\n    var req = {\n      /*path*/p: pathString\n    };\n    var action = 'q';\n    // Only bother to send query if it's non-default.\n    if (listenSpec.tag) {\n      req['q'] = query.queryObject();\n      req['t'] = listenSpec.tag;\n    }\n    req['h'] = listenSpec.hashFn();\n    this.sendRequest(action, req, function (message) {\n      var payload = message['d'];\n      var status = message['s'];\n      // print warnings in any case...\n      PersistentConnection.warnOnListenWarnings_(payload, query);\n      var currentListenSpec = _this.listens_[pathString] && _this.listens_[pathString][queryId];\n      // only trigger actions if the listen hasn't been removed and readded\n      if (currentListenSpec === listenSpec) {\n        _this.log_('listen response', message);\n        if (status !== 'ok') {\n          _this.removeListen_(pathString, queryId);\n        }\n        if (listenSpec.onComplete) {\n          listenSpec.onComplete(status, payload);\n        }\n      }\n    });\n  };\n  /**\n   * @param {*} payload\n   * @param {!Query} query\n   * @private\n   */\n  PersistentConnection.warnOnListenWarnings_ = function (payload, query) {\n    if (payload && typeof payload === 'object' && util_1.contains(payload, 'w')) {\n      var warnings = util_1.safeGet(payload, 'w');\n      if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\n        var indexSpec = '\".indexOn\": \"' + query.getQueryParams().getIndex().toString() + '\"';\n        var indexPath = query.path.toString();\n        util_4.warn(\"Using an unspecified index. Your data will be downloaded and \" + (\"filtered on the client. Consider adding \" + indexSpec + \" at \") + (indexPath + \" to your security rules for better performance.\"));\n      }\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  PersistentConnection.prototype.refreshAuthToken = function (token) {\n    this.authToken_ = token;\n    this.log_('Auth token refreshed');\n    if (this.authToken_) {\n      this.tryAuth();\n    } else {\n      //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n      //the credential so we dont become authenticated next time we connect.\n      if (this.connected_) {\n        this.sendRequest('unauth', {}, function () {});\n      }\n    }\n    this.reduceReconnectDelayIfAdminCredential_(token);\n  };\n  /**\n   * @param {!string} credential\n   * @private\n   */\n  PersistentConnection.prototype.reduceReconnectDelayIfAdminCredential_ = function (credential) {\n    // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n    // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n    var isFirebaseSecret = credential && credential.length === 40;\n    if (isFirebaseSecret || util_5.isAdmin(credential)) {\n      this.log_('Admin auth credential detected.  Reducing max reconnect time.');\n      this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n    }\n  };\n  /**\n   * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\n   * a auth revoked (the connection is closed).\n   */\n  PersistentConnection.prototype.tryAuth = function () {\n    var _this = this;\n    if (this.connected_ && this.authToken_) {\n      var token_1 = this.authToken_;\n      var authMethod = util_5.isValidFormat(token_1) ? 'auth' : 'gauth';\n      var requestData = {\n        cred: token_1\n      };\n      if (this.authOverride_ === null) {\n        requestData['noauth'] = true;\n      } else if (typeof this.authOverride_ === 'object') {\n        requestData['authvar'] = this.authOverride_;\n      }\n      this.sendRequest(authMethod, requestData, function (res) {\n        var status = res['s'];\n        var data = res['d'] || 'error';\n        if (_this.authToken_ === token_1) {\n          if (status === 'ok') {\n            _this.invalidAuthTokenCount_ = 0;\n          } else {\n            // Triggers reconnect and force refresh for auth token\n            _this.onAuthRevoked_(status, data);\n          }\n        }\n      });\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  PersistentConnection.prototype.unlisten = function (query, tag) {\n    var pathString = query.path.toString();\n    var queryId = query.queryIdentifier();\n    this.log_('Unlisten called for ' + pathString + ' ' + queryId);\n    util_3.assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(), 'unlisten() called for non-default but complete query');\n    var listen = this.removeListen_(pathString, queryId);\n    if (listen && this.connected_) {\n      this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);\n    }\n  };\n  PersistentConnection.prototype.sendUnlisten_ = function (pathString, queryId, queryObj, tag) {\n    this.log_('Unlisten on ' + pathString + ' for ' + queryId);\n    var req = {\n      /*path*/p: pathString\n    };\n    var action = 'n';\n    // Only bother sending queryId if it's non-default.\n    if (tag) {\n      req['q'] = queryObj;\n      req['t'] = tag;\n    }\n    this.sendRequest(action, req);\n  };\n  /**\n   * @inheritDoc\n   */\n  PersistentConnection.prototype.onDisconnectPut = function (pathString, data, onComplete) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('o', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString: pathString,\n        action: 'o',\n        data: data,\n        onComplete: onComplete\n      });\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  PersistentConnection.prototype.onDisconnectMerge = function (pathString, data, onComplete) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('om', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString: pathString,\n        action: 'om',\n        data: data,\n        onComplete: onComplete\n      });\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  PersistentConnection.prototype.onDisconnectCancel = function (pathString, onComplete) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('oc', pathString, null, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString: pathString,\n        action: 'oc',\n        data: null,\n        onComplete: onComplete\n      });\n    }\n  };\n  PersistentConnection.prototype.sendOnDisconnect_ = function (action, pathString, data, onComplete) {\n    var request = {\n      /*path*/p: pathString,\n      /*data*/d: data\n    };\n    this.log_('onDisconnect ' + action, request);\n    this.sendRequest(action, request, function (response) {\n      if (onComplete) {\n        setTimeout(function () {\n          onComplete(response['s'], response['d']);\n        }, Math.floor(0));\n      }\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n  PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {\n    this.putInternal('p', pathString, data, onComplete, hash);\n  };\n  /**\n   * @inheritDoc\n   */\n  PersistentConnection.prototype.merge = function (pathString, data, onComplete, hash) {\n    this.putInternal('m', pathString, data, onComplete, hash);\n  };\n  PersistentConnection.prototype.putInternal = function (action, pathString, data, onComplete, hash) {\n    var request = {\n      /*path*/p: pathString,\n      /*data*/d: data\n    };\n    if (hash !== undefined) request['h'] = hash;\n    // TODO: Only keep track of the most recent put for a given path?\n    this.outstandingPuts_.push({\n      action: action,\n      request: request,\n      onComplete: onComplete\n    });\n    this.outstandingPutCount_++;\n    var index = this.outstandingPuts_.length - 1;\n    if (this.connected_) {\n      this.sendPut_(index);\n    } else {\n      this.log_('Buffering put: ' + pathString);\n    }\n  };\n  PersistentConnection.prototype.sendPut_ = function (index) {\n    var _this = this;\n    var action = this.outstandingPuts_[index].action;\n    var request = this.outstandingPuts_[index].request;\n    var onComplete = this.outstandingPuts_[index].onComplete;\n    this.outstandingPuts_[index].queued = this.connected_;\n    this.sendRequest(action, request, function (message) {\n      _this.log_(action + ' response', message);\n      delete _this.outstandingPuts_[index];\n      _this.outstandingPutCount_--;\n      // Clean up array occasionally.\n      if (_this.outstandingPutCount_ === 0) {\n        _this.outstandingPuts_ = [];\n      }\n      if (onComplete) onComplete(message['s'], message['d']);\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n  PersistentConnection.prototype.reportStats = function (stats) {\n    var _this = this;\n    // If we're not connected, we just drop the stats.\n    if (this.connected_) {\n      var request = {\n        /*counters*/c: stats\n      };\n      this.log_('reportStats', request);\n      this.sendRequest( /*stats*/'s', request, function (result) {\n        var status = result['s'];\n        if (status !== 'ok') {\n          var errorReason = result['d'];\n          _this.log_('reportStats', 'Error sending stats: ' + errorReason);\n        }\n      });\n    }\n  };\n  /**\n   * @param {*} message\n   * @private\n   */\n  PersistentConnection.prototype.onDataMessage_ = function (message) {\n    if ('r' in message) {\n      // this is a response\n      this.log_('from server: ' + util_2.stringify(message));\n      var reqNum = message['r'];\n      var onResponse = this.requestCBHash_[reqNum];\n      if (onResponse) {\n        delete this.requestCBHash_[reqNum];\n        onResponse(message['b']);\n      }\n    } else if ('error' in message) {\n      throw 'A server-side error has occurred: ' + message['error'];\n    } else if ('a' in message) {\n      // a and b are action and body, respectively\n      this.onDataPush_(message['a'], message['b']);\n    }\n  };\n  PersistentConnection.prototype.onDataPush_ = function (action, body) {\n    this.log_('handleServerMessage', action, body);\n    if (action === 'd') this.onDataUpdate_(body['p'], body['d'], /*isMerge*/false, body['t']);else if (action === 'm') this.onDataUpdate_(body['p'], body['d'], /*isMerge=*/true, body['t']);else if (action === 'c') this.onListenRevoked_(body['p'], body['q']);else if (action === 'ac') this.onAuthRevoked_(body['s'], body['d']);else if (action === 'sd') this.onSecurityDebugPacket_(body);else util_4.error('Unrecognized action received from server: ' + util_2.stringify(action) + '\\nAre you using the latest client?');\n  };\n  PersistentConnection.prototype.onReady_ = function (timestamp, sessionId) {\n    this.log_('connection ready');\n    this.connected_ = true;\n    this.lastConnectionEstablishedTime_ = new Date().getTime();\n    this.handleTimestamp_(timestamp);\n    this.lastSessionId = sessionId;\n    if (this.firstConnection_) {\n      this.sendConnectStats_();\n    }\n    this.restoreState_();\n    this.firstConnection_ = false;\n    this.onConnectStatus_(true);\n  };\n  PersistentConnection.prototype.scheduleConnect_ = function (timeout) {\n    var _this = this;\n    util_3.assert(!this.realtime_, \"Scheduling a connect when we're already connected/ing?\");\n    if (this.establishConnectionTimer_) {\n      clearTimeout(this.establishConnectionTimer_);\n    }\n    // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n    // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n    this.establishConnectionTimer_ = setTimeout(function () {\n      _this.establishConnectionTimer_ = null;\n      _this.establishConnection_();\n    }, Math.floor(timeout));\n  };\n  /**\n   * @param {boolean} visible\n   * @private\n   */\n  PersistentConnection.prototype.onVisible_ = function (visible) {\n    // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n    if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {\n      this.log_('Window became visible.  Reducing delay.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n    this.visible_ = visible;\n  };\n  PersistentConnection.prototype.onOnline_ = function (online) {\n    if (online) {\n      this.log_('Browser went online.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    } else {\n      this.log_('Browser went offline.  Killing connection.');\n      if (this.realtime_) {\n        this.realtime_.close();\n      }\n    }\n  };\n  PersistentConnection.prototype.onRealtimeDisconnect_ = function () {\n    this.log_('data client disconnected');\n    this.connected_ = false;\n    this.realtime_ = null;\n    // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n    this.cancelSentTransactions_();\n    // Clear out the pending requests.\n    this.requestCBHash_ = {};\n    if (this.shouldReconnect_()) {\n      if (!this.visible_) {\n        this.log_(\"Window isn't visible.  Delaying reconnect.\");\n        this.reconnectDelay_ = this.maxReconnectDelay_;\n        this.lastConnectionAttemptTime_ = new Date().getTime();\n      } else if (this.lastConnectionEstablishedTime_) {\n        // If we've been connected long enough, reset reconnect delay to minimum.\n        var timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;\n        if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        this.lastConnectionEstablishedTime_ = null;\n      }\n      var timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;\n      var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);\n      reconnectDelay = Math.random() * reconnectDelay;\n      this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\n      this.scheduleConnect_(reconnectDelay);\n      // Adjust reconnect delay for next time.\n      this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);\n    }\n    this.onConnectStatus_(false);\n  };\n  PersistentConnection.prototype.establishConnection_ = function () {\n    if (this.shouldReconnect_()) {\n      this.log_('Making a connection attempt');\n      this.lastConnectionAttemptTime_ = new Date().getTime();\n      this.lastConnectionEstablishedTime_ = null;\n      var onDataMessage_1 = this.onDataMessage_.bind(this);\n      var onReady_1 = this.onReady_.bind(this);\n      var onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);\n      var connId_1 = this.id + ':' + PersistentConnection.nextConnectionId_++;\n      var self_1 = this;\n      var lastSessionId_1 = this.lastSessionId;\n      var canceled_1 = false;\n      var connection_1 = null;\n      var closeFn_1 = function () {\n        if (connection_1) {\n          connection_1.close();\n        } else {\n          canceled_1 = true;\n          onDisconnect_1();\n        }\n      };\n      var sendRequestFn = function (msg) {\n        util_3.assert(connection_1, \"sendRequest call when we're not connected not allowed.\");\n        connection_1.sendRequest(msg);\n      };\n      this.realtime_ = {\n        close: closeFn_1,\n        sendRequest: sendRequestFn\n      };\n      var forceRefresh = this.forceTokenRefresh_;\n      this.forceTokenRefresh_ = false;\n      // First fetch auth token, and establish connection after fetching the token was successful\n      this.authTokenProvider_.getToken(forceRefresh).then(function (result) {\n        if (!canceled_1) {\n          util_4.log('getToken() completed. Creating connection.');\n          self_1.authToken_ = result && result.accessToken;\n          connection_1 = new Connection_1.Connection(connId_1, self_1.repoInfo_, onDataMessage_1, onReady_1, onDisconnect_1, /* onKill= */function (reason) {\n            util_4.warn(reason + ' (' + self_1.repoInfo_.toString() + ')');\n            self_1.interrupt(SERVER_KILL_INTERRUPT_REASON);\n          }, lastSessionId_1);\n        } else {\n          util_4.log('getToken() completed but was canceled');\n        }\n      }).then(null, function (error) {\n        self_1.log_('Failed to get token: ' + error);\n        if (!canceled_1) {\n          if (util_6.CONSTANTS.NODE_ADMIN) {\n            // This may be a critical error for the Admin Node.js SDK, so log a warning.\n            // But getToken() may also just have temporarily failed, so we still want to\n            // continue retrying.\n            util_4.warn(error);\n          }\n          closeFn_1();\n        }\n      });\n    }\n  };\n  /**\n   * @param {string} reason\n   */\n  PersistentConnection.prototype.interrupt = function (reason) {\n    util_4.log('Interrupting connection for reason: ' + reason);\n    this.interruptReasons_[reason] = true;\n    if (this.realtime_) {\n      this.realtime_.close();\n    } else {\n      if (this.establishConnectionTimer_) {\n        clearTimeout(this.establishConnectionTimer_);\n        this.establishConnectionTimer_ = null;\n      }\n      if (this.connected_) {\n        this.onRealtimeDisconnect_();\n      }\n    }\n  };\n  /**\n   * @param {string} reason\n   */\n  PersistentConnection.prototype.resume = function (reason) {\n    util_4.log('Resuming connection for reason: ' + reason);\n    delete this.interruptReasons_[reason];\n    if (util_1.isEmpty(this.interruptReasons_)) {\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n  };\n  PersistentConnection.prototype.handleTimestamp_ = function (timestamp) {\n    var delta = timestamp - new Date().getTime();\n    this.onServerInfoUpdate_({\n      serverTimeOffset: delta\n    });\n  };\n  PersistentConnection.prototype.cancelSentTransactions_ = function () {\n    for (var i = 0; i < this.outstandingPuts_.length; i++) {\n      var put = this.outstandingPuts_[i];\n      if (put && /*hash*/'h' in put.request && put.queued) {\n        if (put.onComplete) put.onComplete('disconnect');\n        delete this.outstandingPuts_[i];\n        this.outstandingPutCount_--;\n      }\n    }\n    // Clean up array occasionally.\n    if (this.outstandingPutCount_ === 0) this.outstandingPuts_ = [];\n  };\n  /**\n   * @param {!string} pathString\n   * @param {Array.<*>=} query\n   * @private\n   */\n  PersistentConnection.prototype.onListenRevoked_ = function (pathString, query) {\n    // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n    var queryId;\n    if (!query) {\n      queryId = 'default';\n    } else {\n      queryId = query.map(function (q) {\n        return util_4.ObjectToUniqueKey(q);\n      }).join('$');\n    }\n    var listen = this.removeListen_(pathString, queryId);\n    if (listen && listen.onComplete) listen.onComplete('permission_denied');\n  };\n  /**\n   * @param {!string} pathString\n   * @param {!string} queryId\n   * @return {{queries:Array.<Query>, onComplete:function(string)}}\n   * @private\n   */\n  PersistentConnection.prototype.removeListen_ = function (pathString, queryId) {\n    var normalizedPathString = new Path_1.Path(pathString).toString(); // normalize path.\n    var listen;\n    if (this.listens_[normalizedPathString] !== undefined) {\n      listen = this.listens_[normalizedPathString][queryId];\n      delete this.listens_[normalizedPathString][queryId];\n      if (util_1.getCount(this.listens_[normalizedPathString]) === 0) {\n        delete this.listens_[normalizedPathString];\n      }\n    } else {\n      // all listens for this path has already been removed\n      listen = undefined;\n    }\n    return listen;\n  };\n  PersistentConnection.prototype.onAuthRevoked_ = function (statusCode, explanation) {\n    util_4.log('Auth token revoked: ' + statusCode + '/' + explanation);\n    this.authToken_ = null;\n    this.forceTokenRefresh_ = true;\n    this.realtime_.close();\n    if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\n      // We'll wait a couple times before logging the warning / increasing the\n      // retry period since oauth tokens will report as \"invalid\" if they're\n      // just expired. Plus there may be transient issues that resolve themselves.\n      this.invalidAuthTokenCount_++;\n      if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {\n        // Set a long reconnect delay because recovery is unlikely\n        this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n        // Notify the auth token provider that the token is invalid, which will log\n        // a warning\n        this.authTokenProvider_.notifyForInvalidToken();\n      }\n    }\n  };\n  PersistentConnection.prototype.onSecurityDebugPacket_ = function (body) {\n    if (this.securityDebugCallback_) {\n      this.securityDebugCallback_(body);\n    } else {\n      if ('msg' in body && typeof console !== 'undefined') {\n        console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\n      }\n    }\n  };\n  PersistentConnection.prototype.restoreState_ = function () {\n    var _this = this;\n    //Re-authenticate ourselves if we have a credential stored.\n    this.tryAuth();\n    // Puts depend on having received the corresponding data update from the server before they complete, so we must\n    // make sure to send listens before puts.\n    util_1.forEach(this.listens_, function (pathString, queries) {\n      util_1.forEach(queries, function (key, listenSpec) {\n        _this.sendListen_(listenSpec);\n      });\n    });\n    for (var i = 0; i < this.outstandingPuts_.length; i++) {\n      if (this.outstandingPuts_[i]) this.sendPut_(i);\n    }\n    while (this.onDisconnectRequestQueue_.length) {\n      var request = this.onDisconnectRequestQueue_.shift();\n      this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);\n    }\n  };\n  /**\n   * Sends client stats for first connection\n   * @private\n   */\n  PersistentConnection.prototype.sendConnectStats_ = function () {\n    var stats = {};\n    var clientName = 'js';\n    if (util_6.CONSTANTS.NODE_ADMIN) {\n      clientName = 'admin_node';\n    } else if (util_6.CONSTANTS.NODE_CLIENT) {\n      clientName = 'node';\n    }\n    stats['sdk.' + clientName + '.' + app_1.default.SDK_VERSION.replace(/\\./g, '-')] = 1;\n    if (util_7.isMobileCordova()) {\n      stats['framework.cordova'] = 1;\n    } else if (util_7.isReactNative()) {\n      stats['framework.reactnative'] = 1;\n    }\n    this.reportStats(stats);\n  };\n  /**\n   * @return {boolean}\n   * @private\n   */\n  PersistentConnection.prototype.shouldReconnect_ = function () {\n    var online = OnlineMonitor_1.OnlineMonitor.getInstance().currentlyOnline();\n    return util_1.isEmpty(this.interruptReasons_) && online;\n  };\n  /**\n   * @private\n   */\n  PersistentConnection.nextPersistentConnectionId_ = 0;\n  /**\n   * Counter for number of connections created. Mainly used for tagging in the logs\n   * @type {number}\n   * @private\n   */\n  PersistentConnection.nextConnectionId_ = 0;\n  return PersistentConnection;\n}(ServerActions_1.ServerActions);\nexports.PersistentConnection = PersistentConnection;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA,IAAMA,mBAAmB,GAAG,IAAI;AAChC,IAAMC,2BAA2B,GAAG,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC;AACnD,IAAMC,8BAA8B,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;AAClD,IAAMC,0BAA0B,GAAG,GAAG;AACtC,IAAMC,6BAA6B,GAAG,KAAK,CAAC,CAAC;AAC7C,IAAMC,4BAA4B,GAAG,aAAa;AAElD;AACA,IAAMC,4BAA4B,GAAG,CAAC;AAyBtC;;;;;;AAMA;EAA0CC;EAyDxC;;;;;;;;;EASA,8BACUC,SAAmB,EACnBC,aAKC,EACDC,gBAAsC,EACtCC,mBAAqC,EACrCC,kBAAqC,EACrCC,aAA6B;IAXvC,YAaEC,iBAAO;IAZCC,eAAS,GAATP,SAAS;IACTO,mBAAa,GAAbN,aAAa;IAMbM,sBAAgB,GAAhBL,gBAAgB;IAChBK,yBAAmB,GAAnBJ,mBAAmB;IACnBI,wBAAkB,GAAlBH,kBAAkB;IAClBG,mBAAa,GAAbF,aAAa;IA5EvB;IACAE,QAAE,GAAGC,oBAAoB,CAACC,2BAA2B,EAAE;IAC/CF,UAAI,GAAGG,iBAAU,CAAC,IAAI,GAAGH,KAAI,CAACI,EAAE,GAAG,GAAG,CAAC;IAE/C;IACQJ,uBAAiB,GAAkC,EAAE;IACrDA,cAAQ,GAA0D,EAAE;IACpEA,sBAAgB,GAAqB,EAAE;IACvCA,0BAAoB,GAAG,CAAC;IACxBA,+BAAyB,GAA0B,EAAE;IACrDA,gBAAU,GAAG,KAAK;IAClBA,qBAAe,GAAGf,mBAAmB;IACrCe,wBAAkB,GAAGd,2BAA2B;IAChDc,4BAAsB,GAAiC,IAAI;IACnEA,mBAAa,GAAkB,IAAI;IAEnC;IACQA,+BAAyB,GAAkB,IAAI;IAEvD;IACQA,cAAQ,GAAY,KAAK;IAEjC;IACQA,oBAAc,GAAsC,EAAE;IACtDA,oBAAc,GAAG,CAAC;IAE1B;;;;IAIQA,eAAS,GAGN,IAAI;IAEf;IACQA,gBAAU,GAAkB,IAAI;IAChCA,wBAAkB,GAAG,KAAK;IAC1BA,4BAAsB,GAAG,CAAC;IAE1BA,sBAAgB,GAAG,IAAI;IACvBA,gCAA0B,GAAkB,IAAI;IAChDA,oCAA8B,GAAkB,IAAI;IAsC1D,IAAIF,aAAa,IAAI,CAACO,gBAAS,EAAE,EAAE;MACjC,MAAM,IAAIC,KAAK,CACb,gFAAgF,CACjF;IACH;IACAN,KAAI,CAACO,gBAAgB,CAAC,CAAC,CAAC;IAExBC,qCAAiB,CAACC,WAAW,EAAE,CAACC,EAAE,CAAC,SAAS,EAAEV,KAAI,CAACW,UAAU,EAAEX,KAAI,CAAC;IAEpE,IAAIP,SAAS,CAACmB,IAAI,CAACC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;MAC5CC,6BAAa,CAACL,WAAW,EAAE,CAACC,EAAE,CAAC,QAAQ,EAAEV,KAAI,CAACe,SAAS,EAAEf,KAAI,CAAC;IAChE;;EACF;EAEA;;;;;;EAMUC,0CAAW,GAArB,UACEe,MAAc,EACdC,IAAS,EACTC,UAA6B;IAE7B,IAAMC,SAAS,GAAG,EAAE,IAAI,CAACC,cAAc;IAEvC,IAAMC,GAAG,GAAG;MAAEC,CAAC,EAAEH,SAAS;MAAEI,CAAC,EAAEP,MAAM;MAAEQ,CAAC,EAAEP;IAAI,CAAE;IAChD,IAAI,CAACQ,IAAI,CAACC,gBAAS,CAACL,GAAG,CAAC,CAAC;IACzBM,aAAM,CACJ,IAAI,CAACC,UAAU,EACf,wDAAwD,CACzD;IACD,IAAI,CAACC,SAAS,CAACC,WAAW,CAACT,GAAG,CAAC;IAC/B,IAAIH,UAAU,EAAE;MACd,IAAI,CAACa,cAAc,CAACZ,SAAS,CAAC,GAAGD,UAAU;IAC7C;EACF,CAAC;EAED;;;EAGAjB,qCAAM,GAAN,UACE+B,KAAY,EACZC,aAA2B,EAC3BC,GAAkB,EAClBC,UAAuC;IAEvC,IAAMC,OAAO,GAAGJ,KAAK,CAACK,eAAe,EAAE;IACvC,IAAMC,UAAU,GAAGN,KAAK,CAACO,IAAI,CAACC,QAAQ,EAAE;IACxC,IAAI,CAACf,IAAI,CAAC,oBAAoB,GAAGa,UAAU,GAAG,GAAG,GAAGF,OAAO,CAAC;IAC5D,IAAI,CAACK,QAAQ,CAACH,UAAU,CAAC,GAAG,IAAI,CAACG,QAAQ,CAACH,UAAU,CAAC,IAAI,EAAE;IAC3DX,aAAM,CACJK,KAAK,CAACU,cAAc,EAAE,CAACC,SAAS,EAAE,IAChC,CAACX,KAAK,CAACU,cAAc,EAAE,CAACE,YAAY,EAAE,EACxC,oDAAoD,CACrD;IACDjB,aAAM,CACJ,CAAC,IAAI,CAACc,QAAQ,CAACH,UAAU,CAAC,CAACF,OAAO,CAAC,EACnC,8CAA8C,CAC/C;IACD,IAAMS,UAAU,GAAe;MAC7BV,UAAU,EAAEA,UAAU;MACtBW,MAAM,EAAEb,aAAa;MACrBD,KAAK,EAAEA,KAAK;MACZE,GAAG,EAAEA;KACN;IACD,IAAI,CAACO,QAAQ,CAACH,UAAU,CAAC,CAACF,OAAO,CAAC,GAAGS,UAAU;IAE/C,IAAI,IAAI,CAACjB,UAAU,EAAE;MACnB,IAAI,CAACmB,WAAW,CAACF,UAAU,CAAC;IAC9B;EACF,CAAC;EAED;;;;;;;EAOQ5C,0CAAW,GAAnB,UAAoB4C,UAAsB;IAA1C;IACE,IAAMb,KAAK,GAAGa,UAAU,CAACb,KAAK;IAC9B,IAAMM,UAAU,GAAGN,KAAK,CAACO,IAAI,CAACC,QAAQ,EAAE;IACxC,IAAMJ,OAAO,GAAGJ,KAAK,CAACK,eAAe,EAAE;IACvC,IAAI,CAACZ,IAAI,CAAC,YAAY,GAAGa,UAAU,GAAG,OAAO,GAAGF,OAAO,CAAC;IACxD,IAAMY,GAAG,GAAyB;MAAE,QAASC,CAAC,EAAEX;IAAU,CAAE;IAE5D,IAAMtB,MAAM,GAAG,GAAG;IAElB;IACA,IAAI6B,UAAU,CAACX,GAAG,EAAE;MAClBc,GAAG,CAAC,GAAG,CAAC,GAAGhB,KAAK,CAACkB,WAAW,EAAE;MAC9BF,GAAG,CAAC,GAAG,CAAC,GAAGH,UAAU,CAACX,GAAG;IAC3B;IAEAc,GAAG,CAAU,GAAG,CAAC,GAAGH,UAAU,CAACC,MAAM,EAAE;IAEvC,IAAI,CAAChB,WAAW,CAACd,MAAM,EAAEgC,GAAG,EAAE,UAACG,OAA6B;MAC1D,IAAMC,OAAO,GAAQD,OAAO,CAAU,GAAG,CAAC;MAC1C,IAAME,MAAM,GAAWF,OAAO,CAAY,GAAG,CAAC;MAE9C;MACAlD,oBAAoB,CAACqD,qBAAqB,CAACF,OAAO,EAAEpB,KAAK,CAAC;MAE1D,IAAMuB,iBAAiB,GACrBvD,KAAI,CAACyC,QAAQ,CAACH,UAAU,CAAC,IAAItC,KAAI,CAACyC,QAAQ,CAACH,UAAU,CAAC,CAACF,OAAO,CAAC;MACjE;MACA,IAAImB,iBAAiB,KAAKV,UAAU,EAAE;QACpC7C,KAAI,CAACyB,IAAI,CAAC,iBAAiB,EAAE0B,OAAO,CAAC;QAErC,IAAIE,MAAM,KAAK,IAAI,EAAE;UACnBrD,KAAI,CAACwD,aAAa,CAAClB,UAAU,EAAEF,OAAO,CAAC;QACzC;QAEA,IAAIS,UAAU,CAACV,UAAU,EAAE;UACzBU,UAAU,CAACV,UAAU,CAACkB,MAAM,EAAED,OAAO,CAAC;QACxC;MACF;IACF,CAAC,CAAC;EACJ,CAAC;EAED;;;;;EAKenD,0CAAqB,GAApC,UAAqCmD,OAAY,EAAEpB,KAAY;IAC7D,IAAIoB,OAAO,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAIK,eAAQ,CAACL,OAAO,EAAE,GAAG,CAAC,EAAE;MACpE,IAAMM,QAAQ,GAAGD,cAAO,CAACL,OAAO,EAAE,GAAG,CAAC;MACtC,IAAIO,KAAK,CAACC,OAAO,CAACF,QAAQ,CAAC,IAAI,CAACA,QAAQ,CAAC7C,OAAO,CAAC,UAAU,CAAC,EAAE;QAC5D,IAAMgD,SAAS,GACb,eAAe,GACf7B,KAAK,CACFU,cAAc,EAAE,CAChBoB,QAAQ,EAAE,CACVtB,QAAQ,EAAE,GACb,GAAG;QACL,IAAMuB,SAAS,GAAG/B,KAAK,CAACO,IAAI,CAACC,QAAQ,EAAE;QACvCrC,WAAI,CACF,+DAA+D,IAC7D,6CAA2C0D,SAAS,SAAM,KACvDE,SAAS,oDAAiD,EAChE;MACH;IACF;EACF,CAAC;EAED;;;EAGA9D,+CAAgB,GAAhB,UAAiB+D,KAAa;IAC5B,IAAI,CAACC,UAAU,GAAGD,KAAK;IACvB,IAAI,CAACvC,IAAI,CAAC,sBAAsB,CAAC;IACjC,IAAI,IAAI,CAACwC,UAAU,EAAE;MACnB,IAAI,CAACC,OAAO,EAAE;IAChB,CAAC,MAAM;MACL;MACA;MACA,IAAI,IAAI,CAACtC,UAAU,EAAE;QACnB,IAAI,CAACE,WAAW,CAAC,QAAQ,EAAE,EAAE,EAAE,aAAO,CAAC,CAAC;MAC1C;IACF;IAEA,IAAI,CAACqC,sCAAsC,CAACH,KAAK,CAAC;EACpD,CAAC;EAED;;;;EAIQ/D,qEAAsC,GAA9C,UAA+CmE,UAAkB;IAC/D;IACA;IACA,IAAMC,gBAAgB,GAAGD,UAAU,IAAIA,UAAU,CAACE,MAAM,KAAK,EAAE;IAC/D,IAAID,gBAAgB,IAAIE,cAAO,CAACH,UAAU,CAAC,EAAE;MAC3C,IAAI,CAAC3C,IAAI,CACP,+DAA+D,CAChE;MACD,IAAI,CAAC+C,kBAAkB,GAAGrF,8BAA8B;IAC1D;EACF,CAAC;EAED;;;;EAIAc,sCAAO,GAAP;IAAA;IACE,IAAI,IAAI,CAAC2B,UAAU,IAAI,IAAI,CAACqC,UAAU,EAAE;MACtC,IAAMQ,OAAK,GAAG,IAAI,CAACR,UAAU;MAC7B,IAAMS,UAAU,GAAGH,oBAAa,CAACE,OAAK,CAAC,GAAG,MAAM,GAAG,OAAO;MAC1D,IAAME,WAAW,GAAyB;QAAEC,IAAI,EAAEH;MAAK,CAAE;MACzD,IAAI,IAAI,CAAC3E,aAAa,KAAK,IAAI,EAAE;QAC/B6E,WAAW,CAAC,QAAQ,CAAC,GAAG,IAAI;MAC9B,CAAC,MAAM,IAAI,OAAO,IAAI,CAAC7E,aAAa,KAAK,QAAQ,EAAE;QACjD6E,WAAW,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC7E,aAAa;MAC7C;MACA,IAAI,CAACgC,WAAW,CAAC4C,UAAU,EAAEC,WAAW,EAAE,UAACE,GAAyB;QAClE,IAAMxB,MAAM,GAAWwB,GAAG,CAAY,GAAG,CAAC;QAC1C,IAAMC,IAAI,GAAWD,GAAG,CAAU,GAAG,CAAC,IAAI,OAAO;QAEjD,IAAI7E,KAAI,CAACiE,UAAU,KAAKQ,OAAK,EAAE;UAC7B,IAAIpB,MAAM,KAAK,IAAI,EAAE;YACnBrD,KAAI,CAAC+E,sBAAsB,GAAG,CAAC;UACjC,CAAC,MAAM;YACL;YACA/E,KAAI,CAACgF,cAAc,CAAC3B,MAAM,EAAEyB,IAAI,CAAC;UACnC;QACF;MACF,CAAC,CAAC;IACJ;EACF,CAAC;EAED;;;EAGA7E,uCAAQ,GAAR,UAAS+B,KAAY,EAAEE,GAAkB;IACvC,IAAMI,UAAU,GAAGN,KAAK,CAACO,IAAI,CAACC,QAAQ,EAAE;IACxC,IAAMJ,OAAO,GAAGJ,KAAK,CAACK,eAAe,EAAE;IAEvC,IAAI,CAACZ,IAAI,CAAC,sBAAsB,GAAGa,UAAU,GAAG,GAAG,GAAGF,OAAO,CAAC;IAE9DT,aAAM,CACJK,KAAK,CAACU,cAAc,EAAE,CAACC,SAAS,EAAE,IAChC,CAACX,KAAK,CAACU,cAAc,EAAE,CAACE,YAAY,EAAE,EACxC,sDAAsD,CACvD;IACD,IAAMqC,MAAM,GAAG,IAAI,CAACzB,aAAa,CAAClB,UAAU,EAAEF,OAAO,CAAC;IACtD,IAAI6C,MAAM,IAAI,IAAI,CAACrD,UAAU,EAAE;MAC7B,IAAI,CAACsD,aAAa,CAAC5C,UAAU,EAAEF,OAAO,EAAEJ,KAAK,CAACkB,WAAW,EAAE,EAAEhB,GAAG,CAAC;IACnE;EACF,CAAC;EAEOjC,4CAAa,GAArB,UACEqC,UAAkB,EAClBF,OAAe,EACf+C,QAAgB,EAChBjD,GAAkB;IAElB,IAAI,CAACT,IAAI,CAAC,cAAc,GAAGa,UAAU,GAAG,OAAO,GAAGF,OAAO,CAAC;IAE1D,IAAMY,GAAG,GAAyB;MAAE,QAASC,CAAC,EAAEX;IAAU,CAAE;IAC5D,IAAMtB,MAAM,GAAG,GAAG;IAClB;IACA,IAAIkB,GAAG,EAAE;MACPc,GAAG,CAAC,GAAG,CAAC,GAAGmC,QAAQ;MACnBnC,GAAG,CAAC,GAAG,CAAC,GAAGd,GAAG;IAChB;IAEA,IAAI,CAACJ,WAAW,CAACd,MAAM,EAAEgC,GAAG,CAAC;EAC/B,CAAC;EAED;;;EAGA/C,8CAAe,GAAf,UACEqC,UAAkB,EAClBwC,IAAS,EACT3C,UAA2C;IAE3C,IAAI,IAAI,CAACP,UAAU,EAAE;MACnB,IAAI,CAACwD,iBAAiB,CAAC,GAAG,EAAE9C,UAAU,EAAEwC,IAAI,EAAE3C,UAAU,CAAC;IAC3D,CAAC,MAAM;MACL,IAAI,CAACkD,yBAAyB,CAACC,IAAI,CAAC;QAClChD,UAAU;QACVtB,MAAM,EAAE,GAAG;QACX8D,IAAI;QACJ3C,UAAU;OACX,CAAC;IACJ;EACF,CAAC;EAED;;;EAGAlC,gDAAiB,GAAjB,UACEqC,UAAkB,EAClBwC,IAAS,EACT3C,UAA2C;IAE3C,IAAI,IAAI,CAACP,UAAU,EAAE;MACnB,IAAI,CAACwD,iBAAiB,CAAC,IAAI,EAAE9C,UAAU,EAAEwC,IAAI,EAAE3C,UAAU,CAAC;IAC5D,CAAC,MAAM;MACL,IAAI,CAACkD,yBAAyB,CAACC,IAAI,CAAC;QAClChD,UAAU;QACVtB,MAAM,EAAE,IAAI;QACZ8D,IAAI;QACJ3C,UAAU;OACX,CAAC;IACJ;EACF,CAAC;EAED;;;EAGAlC,iDAAkB,GAAlB,UACEqC,UAAkB,EAClBH,UAA2C;IAE3C,IAAI,IAAI,CAACP,UAAU,EAAE;MACnB,IAAI,CAACwD,iBAAiB,CAAC,IAAI,EAAE9C,UAAU,EAAE,IAAI,EAAEH,UAAU,CAAC;IAC5D,CAAC,MAAM;MACL,IAAI,CAACkD,yBAAyB,CAACC,IAAI,CAAC;QAClChD,UAAU;QACVtB,MAAM,EAAE,IAAI;QACZ8D,IAAI,EAAE,IAAI;QACV3C,UAAU;OACX,CAAC;IACJ;EACF,CAAC;EAEOlC,gDAAiB,GAAzB,UACEe,MAAc,EACdsB,UAAkB,EAClBwC,IAAS,EACT3C,UAA0C;IAE1C,IAAMoD,OAAO,GAAG;MAAE,QAAStC,CAAC,EAAEX,UAAU;MAAE,QAASkD,CAAC,EAAEV;IAAI,CAAE;IAC5D,IAAI,CAACrD,IAAI,CAAC,eAAe,GAAGT,MAAM,EAAEuE,OAAO,CAAC;IAC5C,IAAI,CAACzD,WAAW,CAACd,MAAM,EAAEuE,OAAO,EAAE,UAACE,QAA8B;MAC/D,IAAItD,UAAU,EAAE;QACduD,UAAU,CAAC;UACTvD,UAAU,CAACsD,QAAQ,CAAY,GAAG,CAAC,EAAEA,QAAQ,CAAY,GAAG,CAAC,CAAC;QAChE,CAAC,EAAEE,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;MACnB;IACF,CAAC,CAAC;EACJ,CAAC;EAED;;;EAGA3F,kCAAG,GAAH,UACEqC,UAAkB,EAClBwC,IAAS,EACT3C,UAA2C,EAC3C0D,IAAa;IAEb,IAAI,CAACC,WAAW,CAAC,GAAG,EAAExD,UAAU,EAAEwC,IAAI,EAAE3C,UAAU,EAAE0D,IAAI,CAAC;EAC3D,CAAC;EAED;;;EAGA5F,oCAAK,GAAL,UACEqC,UAAkB,EAClBwC,IAAS,EACT3C,UAAiD,EACjD0D,IAAa;IAEb,IAAI,CAACC,WAAW,CAAC,GAAG,EAAExD,UAAU,EAAEwC,IAAI,EAAE3C,UAAU,EAAE0D,IAAI,CAAC;EAC3D,CAAC;EAED5F,0CAAW,GAAX,UACEe,MAAc,EACdsB,UAAkB,EAClBwC,IAAS,EACT3C,UAAiD,EACjD0D,IAAa;IAEb,IAAMN,OAAO,GAAyB;MACpC,QAAStC,CAAC,EAAEX,UAAU;MACtB,QAASkD,CAAC,EAAEV;KACb;IAED,IAAIe,IAAI,KAAKE,SAAS,EAAER,OAAO,CAAU,GAAG,CAAC,GAAGM,IAAI;IAEpD;IACA,IAAI,CAACG,gBAAgB,CAACV,IAAI,CAAC;MACzBtE,MAAM;MACNuE,OAAO;MACPpD,UAAU;KACX,CAAC;IAEF,IAAI,CAAC8D,oBAAoB,EAAE;IAC3B,IAAMC,KAAK,GAAG,IAAI,CAACF,gBAAgB,CAAC1B,MAAM,GAAG,CAAC;IAE9C,IAAI,IAAI,CAAC1C,UAAU,EAAE;MACnB,IAAI,CAACuE,QAAQ,CAACD,KAAK,CAAC;IACtB,CAAC,MAAM;MACL,IAAI,CAACzE,IAAI,CAAC,iBAAiB,GAAGa,UAAU,CAAC;IAC3C;EACF,CAAC;EAEOrC,uCAAQ,GAAhB,UAAiBiG,KAAa;IAA9B;IACE,IAAMlF,MAAM,GAAG,IAAI,CAACgF,gBAAgB,CAACE,KAAK,CAAC,CAAClF,MAAM;IAClD,IAAMuE,OAAO,GAAG,IAAI,CAACS,gBAAgB,CAACE,KAAK,CAAC,CAACX,OAAO;IACpD,IAAMpD,UAAU,GAAG,IAAI,CAAC6D,gBAAgB,CAACE,KAAK,CAAC,CAAC/D,UAAU;IAC1D,IAAI,CAAC6D,gBAAgB,CAACE,KAAK,CAAC,CAACE,MAAM,GAAG,IAAI,CAACxE,UAAU;IAErD,IAAI,CAACE,WAAW,CAACd,MAAM,EAAEuE,OAAO,EAAE,UAACpC,OAA6B;MAC9DnD,KAAI,CAACyB,IAAI,CAACT,MAAM,GAAG,WAAW,EAAEmC,OAAO,CAAC;MAExC,OAAOnD,KAAI,CAACgG,gBAAgB,CAACE,KAAK,CAAC;MACnClG,KAAI,CAACiG,oBAAoB,EAAE;MAE3B;MACA,IAAIjG,KAAI,CAACiG,oBAAoB,KAAK,CAAC,EAAE;QACnCjG,KAAI,CAACgG,gBAAgB,GAAG,EAAE;MAC5B;MAEA,IAAI7D,UAAU,EACZA,UAAU,CAACgB,OAAO,CAAY,GAAG,CAAC,EAAEA,OAAO,CAAY,GAAG,CAAC,CAAC;IAChE,CAAC,CAAC;EACJ,CAAC;EAED;;;EAGAlD,0CAAW,GAAX,UAAYoG,KAA2B;IAAvC;IACE;IACA,IAAI,IAAI,CAACzE,UAAU,EAAE;MACnB,IAAM2D,OAAO,GAAG;QAAE,YAAae,CAAC,EAAED;MAAK,CAAE;MACzC,IAAI,CAAC5E,IAAI,CAAC,aAAa,EAAE8D,OAAO,CAAC;MAEjC,IAAI,CAACzD,WAAW,EAAC,SAAU,GAAG,EAAEyD,OAAO,EAAE,gBAAM;QAC7C,IAAMlC,MAAM,GAAGkD,MAAM,CAAY,GAAG,CAAC;QACrC,IAAIlD,MAAM,KAAK,IAAI,EAAE;UACnB,IAAMmD,WAAW,GAAGD,MAAM,CAAY,GAAG,CAAC;UAC1CvG,KAAI,CAACyB,IAAI,CAAC,aAAa,EAAE,uBAAuB,GAAG+E,WAAW,CAAC;QACjE;MACF,CAAC,CAAC;IACJ;EACF,CAAC;EAED;;;;EAIQvG,6CAAc,GAAtB,UAAuBkD,OAA6B;IAClD,IAAI,GAAG,IAAIA,OAAO,EAAE;MAClB;MACA,IAAI,CAAC1B,IAAI,CAAC,eAAe,GAAGC,gBAAS,CAACyB,OAAO,CAAC,CAAC;MAC/C,IAAMsD,MAAM,GAAGtD,OAAO,CAAC,GAAG,CAAC;MAC3B,IAAMjC,UAAU,GAAG,IAAI,CAACa,cAAc,CAAC0E,MAAM,CAAC;MAC9C,IAAIvF,UAAU,EAAE;QACd,OAAO,IAAI,CAACa,cAAc,CAAC0E,MAAM,CAAC;QAClCvF,UAAU,CAACiC,OAAO,CAAU,GAAG,CAAC,CAAC;MACnC;IACF,CAAC,MAAM,IAAI,OAAO,IAAIA,OAAO,EAAE;MAC7B,MAAM,oCAAoC,GAAGA,OAAO,CAAC,OAAO,CAAC;IAC/D,CAAC,MAAM,IAAI,GAAG,IAAIA,OAAO,EAAE;MACzB;MACA,IAAI,CAACuD,WAAW,CAACvD,OAAO,CAAC,GAAG,CAAC,EAAEA,OAAO,CAAC,GAAG,CAAC,CAAC;IAC9C;EACF,CAAC;EAEOlD,0CAAW,GAAnB,UAAoBe,MAAc,EAAEC,IAA0B;IAC5D,IAAI,CAACQ,IAAI,CAAC,qBAAqB,EAAET,MAAM,EAAEC,IAAI,CAAC;IAC9C,IAAID,MAAM,KAAK,GAAG,EAChB,IAAI,CAACtB,aAAa,CAChBuB,IAAI,CAAU,GAAG,CAAC,EAClBA,IAAI,CAAU,GAAG,CAAC,EAClB,WAAY,KAAK,EACjBA,IAAI,CAAC,GAAG,CAAC,CACV,CAAC,KACC,IAAID,MAAM,KAAK,GAAG,EACrB,IAAI,CAACtB,aAAa,CAChBuB,IAAI,CAAU,GAAG,CAAC,EAClBA,IAAI,CAAU,GAAG,CAAC,EAClB,YAAa,IAAI,EACjBA,IAAI,CAAC,GAAG,CAAC,CACV,CAAC,KACC,IAAID,MAAM,KAAK,GAAG,EACrB,IAAI,CAAC2F,gBAAgB,CAAC1F,IAAI,CAAU,GAAG,CAAC,EAAEA,IAAI,CAAW,GAAG,CAAC,CAAC,CAAC,KAC5D,IAAID,MAAM,KAAK,IAAI,EACtB,IAAI,CAACgE,cAAc,CACjB/D,IAAI,CAAiB,GAAG,CAAC,EACzBA,IAAI,CAAmB,GAAG,CAAC,CAC5B,CAAC,KACC,IAAID,MAAM,KAAK,IAAI,EAAE,IAAI,CAAC4F,sBAAsB,CAAC3F,IAAI,CAAC,CAAC,KAE1Dd,YAAK,CACH,4CAA4C,GAC1CuB,gBAAS,CAACV,MAAM,CAAC,GACjB,oCAAoC,CACvC;EACL,CAAC;EAEOf,uCAAQ,GAAhB,UAAiB4G,SAAiB,EAAEC,SAAiB;IACnD,IAAI,CAACrF,IAAI,CAAC,kBAAkB,CAAC;IAC7B,IAAI,CAACG,UAAU,GAAG,IAAI;IACtB,IAAI,CAACmF,8BAA8B,GAAG,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE;IAC1D,IAAI,CAACC,gBAAgB,CAACL,SAAS,CAAC;IAChC,IAAI,CAACM,aAAa,GAAGL,SAAS;IAC9B,IAAI,IAAI,CAACM,gBAAgB,EAAE;MACzB,IAAI,CAACC,iBAAiB,EAAE;IAC1B;IACA,IAAI,CAACC,aAAa,EAAE;IACpB,IAAI,CAACF,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACzH,gBAAgB,CAAC,IAAI,CAAC;EAC7B,CAAC;EAEOM,+CAAgB,GAAxB,UAAyBsH,OAAe;IAAxC;IACE5F,aAAM,CACJ,CAAC,IAAI,CAACE,SAAS,EACf,wDAAwD,CACzD;IAED,IAAI,IAAI,CAAC2F,yBAAyB,EAAE;MAClCC,YAAY,CAAC,IAAI,CAACD,yBAAyB,CAAC;IAC9C;IAEA;IACA;IAEA,IAAI,CAACA,yBAAyB,GAAG9B,UAAU,CAAC;MAC1C1F,KAAI,CAACwH,yBAAyB,GAAG,IAAI;MACrCxH,KAAI,CAAC0H,oBAAoB,EAAE;IAC7B,CAAC,EAAE/B,IAAI,CAACC,KAAK,CAAC2B,OAAO,CAAC,CAAQ;EAChC,CAAC;EAED;;;;EAIQtH,yCAAU,GAAlB,UAAmB0H,OAAgB;IACjC;IACA,IACEA,OAAO,IACP,CAAC,IAAI,CAACC,QAAQ,IACd,IAAI,CAACC,eAAe,KAAK,IAAI,CAACrD,kBAChC,EAAE;MACA,IAAI,CAAC/C,IAAI,CAAC,yCAAyC,CAAC;MACpD,IAAI,CAACoG,eAAe,GAAG5I,mBAAmB;MAE1C,IAAI,CAAC,IAAI,CAAC4C,SAAS,EAAE;QACnB,IAAI,CAACtB,gBAAgB,CAAC,CAAC,CAAC;MAC1B;IACF;IACA,IAAI,CAACqH,QAAQ,GAAGD,OAAO;EACzB,CAAC;EAEO1H,wCAAS,GAAjB,UAAkB6H,MAAe;IAC/B,IAAIA,MAAM,EAAE;MACV,IAAI,CAACrG,IAAI,CAAC,sBAAsB,CAAC;MACjC,IAAI,CAACoG,eAAe,GAAG5I,mBAAmB;MAC1C,IAAI,CAAC,IAAI,CAAC4C,SAAS,EAAE;QACnB,IAAI,CAACtB,gBAAgB,CAAC,CAAC,CAAC;MAC1B;IACF,CAAC,MAAM;MACL,IAAI,CAACkB,IAAI,CAAC,4CAA4C,CAAC;MACvD,IAAI,IAAI,CAACI,SAAS,EAAE;QAClB,IAAI,CAACA,SAAS,CAACkG,KAAK,EAAE;MACxB;IACF;EACF,CAAC;EAEO9H,oDAAqB,GAA7B;IACE,IAAI,CAACwB,IAAI,CAAC,0BAA0B,CAAC;IACrC,IAAI,CAACG,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,SAAS,GAAG,IAAI;IAErB;IACA,IAAI,CAACmG,uBAAuB,EAAE;IAE9B;IACA,IAAI,CAACjG,cAAc,GAAG,EAAE;IAExB,IAAI,IAAI,CAACkG,gBAAgB,EAAE,EAAE;MAC3B,IAAI,CAAC,IAAI,CAACL,QAAQ,EAAE;QAClB,IAAI,CAACnG,IAAI,CAAC,4CAA4C,CAAC;QACvD,IAAI,CAACoG,eAAe,GAAG,IAAI,CAACrD,kBAAkB;QAC9C,IAAI,CAAC0D,0BAA0B,GAAG,IAAIlB,IAAI,EAAE,CAACC,OAAO,EAAE;MACxD,CAAC,MAAM,IAAI,IAAI,CAACF,8BAA8B,EAAE;QAC9C;QACA,IAAMoB,6BAA6B,GACjC,IAAInB,IAAI,EAAE,CAACC,OAAO,EAAE,GAAG,IAAI,CAACF,8BAA8B;QAC5D,IAAIoB,6BAA6B,GAAG9I,6BAA6B,EAC/D,IAAI,CAACwI,eAAe,GAAG5I,mBAAmB;QAC5C,IAAI,CAAC8H,8BAA8B,GAAG,IAAI;MAC5C;MAEA,IAAMqB,2BAA2B,GAC/B,IAAIpB,IAAI,EAAE,CAACC,OAAO,EAAE,GAAG,IAAI,CAACiB,0BAA0B;MACxD,IAAIG,cAAc,GAAG1C,IAAI,CAAC2C,GAAG,CAC3B,CAAC,EACD,IAAI,CAACT,eAAe,GAAGO,2BAA2B,CACnD;MACDC,cAAc,GAAG1C,IAAI,CAAC4C,MAAM,EAAE,GAAGF,cAAc;MAE/C,IAAI,CAAC5G,IAAI,CAAC,yBAAyB,GAAG4G,cAAc,GAAG,IAAI,CAAC;MAC5D,IAAI,CAAC9H,gBAAgB,CAAC8H,cAAc,CAAC;MAErC;MACA,IAAI,CAACR,eAAe,GAAGlC,IAAI,CAAC6C,GAAG,CAC7B,IAAI,CAAChE,kBAAkB,EACvB,IAAI,CAACqD,eAAe,GAAGzI,0BAA0B,CAClD;IACH;IACA,IAAI,CAACO,gBAAgB,CAAC,KAAK,CAAC;EAC9B,CAAC;EAEOM,mDAAoB,GAA5B;IACE,IAAI,IAAI,CAACgI,gBAAgB,EAAE,EAAE;MAC3B,IAAI,CAACxG,IAAI,CAAC,6BAA6B,CAAC;MACxC,IAAI,CAACyG,0BAA0B,GAAG,IAAIlB,IAAI,EAAE,CAACC,OAAO,EAAE;MACtD,IAAI,CAACF,8BAA8B,GAAG,IAAI;MAC1C,IAAM0B,eAAa,GAAG,IAAI,CAACC,cAAc,CAACC,IAAI,CAAC,IAAI,CAAC;MACpD,IAAMC,SAAO,GAAG,IAAI,CAACC,QAAQ,CAACF,IAAI,CAAC,IAAI,CAAC;MACxC,IAAMG,cAAY,GAAG,IAAI,CAACC,qBAAqB,CAACJ,IAAI,CAAC,IAAI,CAAC;MAC1D,IAAMK,QAAM,GAAG,IAAI,CAAC5I,EAAE,GAAG,GAAG,GAAGH,oBAAoB,CAACgJ,iBAAiB,EAAE;MACvE,IAAMC,MAAI,GAAG,IAAI;MACjB,IAAMC,eAAa,GAAG,IAAI,CAAChC,aAAa;MACxC,IAAIiC,UAAQ,GAAG,KAAK;MACpB,IAAIC,YAAU,GAAsB,IAAI;MACxC,IAAMC,SAAO,GAAG;QACd,IAAID,YAAU,EAAE;UACdA,YAAU,CAACtB,KAAK,EAAE;QACpB,CAAC,MAAM;UACLqB,UAAQ,GAAG,IAAI;UACfN,cAAY,EAAE;QAChB;MACF,CAAC;MACD,IAAMS,aAAa,GAAG,UAASlI,GAAW;QACxCM,aAAM,CACJ0H,YAAU,EACV,wDAAwD,CACzD;QACDA,YAAU,CAACvH,WAAW,CAACT,GAAG,CAAC;MAC7B,CAAC;MAED,IAAI,CAACQ,SAAS,GAAG;QACfkG,KAAK,EAAEuB,SAAO;QACdxH,WAAW,EAAEyH;OACd;MAED,IAAMC,YAAY,GAAG,IAAI,CAACC,kBAAkB;MAC5C,IAAI,CAACA,kBAAkB,GAAG,KAAK;MAE/B;MACA,IAAI,CAAC5J,kBAAkB,CACpB6J,QAAQ,CAACF,YAAY,CAAC,CACtBG,IAAI,CAAC,UAASpD,MAAM;QACnB,IAAI,CAAC6C,UAAQ,EAAE;UACbjJ,UAAG,CAAC,4CAA4C,CAAC;UACjD+I,MAAI,CAACjF,UAAU,GAAGsC,MAAM,IAAIA,MAAM,CAACqD,WAAW;UAC9CP,YAAU,GAAG,IAAIQ,uBAAU,CACzBb,QAAM,EACNE,MAAI,CAACzJ,SAAS,EACdgJ,eAAa,EACbG,SAAO,EACPE,cAAY,EACZ,aAAc,UAASgB,MAAM;YAC3B3J,WAAI,CAAC2J,MAAM,GAAG,IAAI,GAAGZ,MAAI,CAACzJ,SAAS,CAAC+C,QAAQ,EAAE,GAAG,GAAG,CAAC;YACrD0G,MAAI,CAACa,SAAS,CAACzK,4BAA4B,CAAC;UAC9C,CAAC,EACD6J,eAAa,CACd;QACH,CAAC,MAAM;UACLhJ,UAAG,CAAC,uCAAuC,CAAC;QAC9C;MACF,CAAC,CAAC,CACDwJ,IAAI,CAAC,IAAI,EAAE,UAASK,KAAK;QACxBd,MAAI,CAACzH,IAAI,CAAC,uBAAuB,GAAGuI,KAAK,CAAC;QAC1C,IAAI,CAACZ,UAAQ,EAAE;UACb,IAAIa,gBAAS,CAACC,UAAU,EAAE;YACxB;YACA;YACA;YACA/J,WAAI,CAAC6J,KAAK,CAAC;UACb;UACAV,SAAO,EAAE;QACX;MACF,CAAC,CAAC;IACN;EACF,CAAC;EAED;;;EAGArJ,wCAAS,GAAT,UAAU6J,MAAc;IACtB3J,UAAG,CAAC,sCAAsC,GAAG2J,MAAM,CAAC;IACpD,IAAI,CAACK,iBAAiB,CAACL,MAAM,CAAC,GAAG,IAAI;IACrC,IAAI,IAAI,CAACjI,SAAS,EAAE;MAClB,IAAI,CAACA,SAAS,CAACkG,KAAK,EAAE;IACxB,CAAC,MAAM;MACL,IAAI,IAAI,CAACP,yBAAyB,EAAE;QAClCC,YAAY,CAAC,IAAI,CAACD,yBAAyB,CAAC;QAC5C,IAAI,CAACA,yBAAyB,GAAG,IAAI;MACvC;MACA,IAAI,IAAI,CAAC5F,UAAU,EAAE;QACnB,IAAI,CAACmH,qBAAqB,EAAE;MAC9B;IACF;EACF,CAAC;EAED;;;EAGA9I,qCAAM,GAAN,UAAO6J,MAAc;IACnB3J,UAAG,CAAC,kCAAkC,GAAG2J,MAAM,CAAC;IAChD,OAAO,IAAI,CAACK,iBAAiB,CAACL,MAAM,CAAC;IACrC,IAAIrG,cAAO,CAAC,IAAI,CAAC0G,iBAAiB,CAAC,EAAE;MACnC,IAAI,CAACtC,eAAe,GAAG5I,mBAAmB;MAC1C,IAAI,CAAC,IAAI,CAAC4C,SAAS,EAAE;QACnB,IAAI,CAACtB,gBAAgB,CAAC,CAAC,CAAC;MAC1B;IACF;EACF,CAAC;EAEON,+CAAgB,GAAxB,UAAyB4G,SAAiB;IACxC,IAAMuD,KAAK,GAAGvD,SAAS,GAAG,IAAIG,IAAI,EAAE,CAACC,OAAO,EAAE;IAC9C,IAAI,CAACrH,mBAAmB,CAAC;MAAEyK,gBAAgB,EAAED;IAAK,CAAE,CAAC;EACvD,CAAC;EAEOnK,sDAAuB,GAA/B;IACE,KAAK,IAAIqK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACtE,gBAAgB,CAAC1B,MAAM,EAAEgG,CAAC,EAAE,EAAE;MACrD,IAAMC,GAAG,GAAG,IAAI,CAACvE,gBAAgB,CAACsE,CAAC,CAAC;MACpC,IAAIC,GAAG,IAAI,QAAS,GAAG,IAAIA,GAAG,CAAChF,OAAO,IAAIgF,GAAG,CAACnE,MAAM,EAAE;QACpD,IAAImE,GAAG,CAACpI,UAAU,EAAEoI,GAAG,CAACpI,UAAU,CAAC,YAAY,CAAC;QAEhD,OAAO,IAAI,CAAC6D,gBAAgB,CAACsE,CAAC,CAAC;QAC/B,IAAI,CAACrE,oBAAoB,EAAE;MAC7B;IACF;IAEA;IACA,IAAI,IAAI,CAACA,oBAAoB,KAAK,CAAC,EAAE,IAAI,CAACD,gBAAgB,GAAG,EAAE;EACjE,CAAC;EAED;;;;;EAKQ/F,+CAAgB,GAAxB,UAAyBqC,UAAkB,EAAEN,KAAa;IACxD;IACA,IAAII,OAAO;IACX,IAAI,CAACJ,KAAK,EAAE;MACVI,OAAO,GAAG,SAAS;IACrB,CAAC,MAAM;MACLA,OAAO,GAAGJ,KAAK,CAACwI,GAAG,CAAC,WAAC;QAAI,+BAAiB,CAACC,CAAC,CAAC;MAApB,CAAoB,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;IAC1D;IACA,IAAMzF,MAAM,GAAG,IAAI,CAACzB,aAAa,CAAClB,UAAU,EAAEF,OAAO,CAAC;IACtD,IAAI6C,MAAM,IAAIA,MAAM,CAAC9C,UAAU,EAAE8C,MAAM,CAAC9C,UAAU,CAAC,mBAAmB,CAAC;EACzE,CAAC;EAED;;;;;;EAMQlC,4CAAa,GAArB,UAAsBqC,UAAkB,EAAEF,OAAe;IACvD,IAAMuI,oBAAoB,GAAG,IAAIC,WAAI,CAACtI,UAAU,CAAC,CAACE,QAAQ,EAAE,CAAC,CAAC;IAC9D,IAAIyC,MAAM;IACV,IAAI,IAAI,CAACxC,QAAQ,CAACkI,oBAAoB,CAAC,KAAK5E,SAAS,EAAE;MACrDd,MAAM,GAAG,IAAI,CAACxC,QAAQ,CAACkI,oBAAoB,CAAC,CAACvI,OAAO,CAAC;MACrD,OAAO,IAAI,CAACK,QAAQ,CAACkI,oBAAoB,CAAC,CAACvI,OAAO,CAAC;MACnD,IAAIqB,eAAQ,CAAC,IAAI,CAAChB,QAAQ,CAACkI,oBAAoB,CAAC,CAAC,KAAK,CAAC,EAAE;QACvD,OAAO,IAAI,CAAClI,QAAQ,CAACkI,oBAAoB,CAAC;MAC5C;IACF,CAAC,MAAM;MACL;MACA1F,MAAM,GAAGc,SAAS;IACpB;IACA,OAAOd,MAAM;EACf,CAAC;EAEOhF,6CAAc,GAAtB,UAAuB4K,UAAkB,EAAEC,WAAmB;IAC5D3K,UAAG,CAAC,sBAAsB,GAAG0K,UAAU,GAAG,GAAG,GAAGC,WAAW,CAAC;IAC5D,IAAI,CAAC7G,UAAU,GAAG,IAAI;IACtB,IAAI,CAACwF,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAAC5H,SAAS,CAACkG,KAAK,EAAE;IACtB,IAAI8C,UAAU,KAAK,eAAe,IAAIA,UAAU,KAAK,mBAAmB,EAAE;MACxE;MACA;MACA;MACA,IAAI,CAAC9F,sBAAsB,EAAE;MAC7B,IAAI,IAAI,CAACA,sBAAsB,IAAIxF,4BAA4B,EAAE;QAC/D;QACA,IAAI,CAACsI,eAAe,GAAG1I,8BAA8B;QAErD;QACA;QACA,IAAI,CAACU,kBAAkB,CAACkL,qBAAqB,EAAE;MACjD;IACF;EACF,CAAC;EAEO9K,qDAAsB,GAA9B,UAA+BgB,IAA0B;IACvD,IAAI,IAAI,CAAC+J,sBAAsB,EAAE;MAC/B,IAAI,CAACA,sBAAsB,CAAC/J,IAAI,CAAC;IACnC,CAAC,MAAM;MACL,IAAI,KAAK,IAAIA,IAAI,IAAI,OAAOgK,OAAO,KAAK,WAAW,EAAE;QACnDA,OAAO,CAACC,GAAG,CAAC,YAAY,GAAGjK,IAAI,CAAC,KAAK,CAAC,CAACkK,OAAO,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;MACvE;IACF;EACF,CAAC;EAEOlL,4CAAa,GAArB;IAAA;IACE;IACA,IAAI,CAACiE,OAAO,EAAE;IAEd;IACA;IACAT,cAAO,CAAC,IAAI,CAAChB,QAAQ,EAAE,UAACH,UAAkB,EAAE8I,OAAe;MACzD3H,cAAO,CAAC2H,OAAO,EAAE,UAACC,GAAW,EAAExI,UAAsB;QACnD7C,KAAI,CAAC+C,WAAW,CAACF,UAAU,CAAC;MAC9B,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,KAAK,IAAIyH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACtE,gBAAgB,CAAC1B,MAAM,EAAEgG,CAAC,EAAE,EAAE;MACrD,IAAI,IAAI,CAACtE,gBAAgB,CAACsE,CAAC,CAAC,EAAE,IAAI,CAACnE,QAAQ,CAACmE,CAAC,CAAC;IAChD;IAEA,OAAO,IAAI,CAACjF,yBAAyB,CAACf,MAAM,EAAE;MAC5C,IAAMiB,OAAO,GAAG,IAAI,CAACF,yBAAyB,CAACiG,KAAK,EAAE;MACtD,IAAI,CAAClG,iBAAiB,CACpBG,OAAO,CAACvE,MAAM,EACduE,OAAO,CAACjD,UAAU,EAClBiD,OAAO,CAACT,IAAI,EACZS,OAAO,CAACpD,UAAU,CACnB;IACH;EACF,CAAC;EAED;;;;EAIQlC,gDAAiB,GAAzB;IACE,IAAMoG,KAAK,GAA4B,EAAE;IAEzC,IAAIkF,UAAU,GAAG,IAAI;IACrB,IAAItB,gBAAS,CAACC,UAAU,EAAE;MACxBqB,UAAU,GAAG,YAAY;IAC3B,CAAC,MAAM,IAAItB,gBAAS,CAACuB,WAAW,EAAE;MAChCD,UAAU,GAAG,MAAM;IACrB;IAEAlF,KAAK,CACH,MAAM,GAAGkF,UAAU,GAAG,GAAG,GAAGE,aAAQ,CAACC,WAAW,CAACP,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CACrE,GAAG,CAAC;IAEL,IAAI9K,sBAAe,EAAE,EAAE;MACrBgG,KAAK,CAAC,mBAAmB,CAAC,GAAG,CAAC;IAChC,CAAC,MAAM,IAAIhG,oBAAa,EAAE,EAAE;MAC1BgG,KAAK,CAAC,uBAAuB,CAAC,GAAG,CAAC;IACpC;IACA,IAAI,CAACsF,WAAW,CAACtF,KAAK,CAAC;EACzB,CAAC;EAED;;;;EAIQpG,+CAAgB,GAAxB;IACE,IAAM6H,MAAM,GAAGhH,6BAAa,CAACL,WAAW,EAAE,CAACmL,eAAe,EAAE;IAC5D,OAAOnI,cAAO,CAAC,IAAI,CAAC0G,iBAAiB,CAAC,IAAIrC,MAAM;EAClD,CAAC;EAt3BD;;;EAGe7H,gDAA2B,GAAG,CAAC;EAE9C;;;;;EAKeA,sCAAiB,GAAG,CAAC;EA62BtC,2BAAC;CAp6BD,CAA0C4L,6BAAa;AAA1CC","names":["RECONNECT_MIN_DELAY","RECONNECT_MAX_DELAY_DEFAULT","RECONNECT_MAX_DELAY_FOR_ADMINS","RECONNECT_DELAY_MULTIPLIER","RECONNECT_DELAY_RESET_TIMEOUT","SERVER_KILL_INTERRUPT_REASON","INVALID_AUTH_TOKEN_THRESHOLD","__extends","repoInfo_","onDataUpdate_","onConnectStatus_","onServerInfoUpdate_","authTokenProvider_","authOverride_","_super","_this","PersistentConnection","nextPersistentConnectionId_","util_4","id","util_7","Error","scheduleConnect_","VisibilityMonitor_1","getInstance","on","onVisible_","host","indexOf","OnlineMonitor_1","onOnline_","action","body","onResponse","curReqNum","requestNumber_","msg","r","a","b","log_","util_2","util_3","connected_","realtime_","sendRequest","requestCBHash_","query","currentHashFn","tag","onComplete","queryId","queryIdentifier","pathString","path","toString","listens_","getQueryParams","isDefault","loadsAllData","listenSpec","hashFn","sendListen_","req","p","queryObject","message","payload","status","warnOnListenWarnings_","currentListenSpec","removeListen_","util_1","warnings","Array","isArray","indexSpec","getIndex","indexPath","token","authToken_","tryAuth","reduceReconnectDelayIfAdminCredential_","credential","isFirebaseSecret","length","util_5","maxReconnectDelay_","token_1","authMethod","requestData","cred","res","data","invalidAuthTokenCount_","onAuthRevoked_","listen","sendUnlisten_","queryObj","sendOnDisconnect_","onDisconnectRequestQueue_","push","request","d","response","setTimeout","Math","floor","hash","putInternal","undefined","outstandingPuts_","outstandingPutCount_","index","sendPut_","queued","stats","c","result","errorReason","reqNum","onDataPush_","onListenRevoked_","onSecurityDebugPacket_","timestamp","sessionId","lastConnectionEstablishedTime_","Date","getTime","handleTimestamp_","lastSessionId","firstConnection_","sendConnectStats_","restoreState_","timeout","establishConnectionTimer_","clearTimeout","establishConnection_","visible","visible_","reconnectDelay_","online","close","cancelSentTransactions_","shouldReconnect_","lastConnectionAttemptTime_","timeSinceLastConnectSucceeded","timeSinceLastConnectAttempt","reconnectDelay","max","random","min","onDataMessage_1","onDataMessage_","bind","onReady_1","onReady_","onDisconnect_1","onRealtimeDisconnect_","connId_1","nextConnectionId_","self_1","lastSessionId_1","canceled_1","connection_1","closeFn_1","sendRequestFn","forceRefresh","forceTokenRefresh_","getToken","then","accessToken","Connection_1","reason","interrupt","error","util_6","NODE_ADMIN","interruptReasons_","delta","serverTimeOffset","i","put","map","q","join","normalizedPathString","Path_1","statusCode","explanation","notifyForInvalidToken","securityDebugCallback_","console","log","replace","queries","key","shift","clientName","NODE_CLIENT","app_1","SDK_VERSION","reportStats","currentlyOnline","ServerActions_1","exports"],"sources":["../src/core/PersistentConnection.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\nimport { forEach, contains, isEmpty, getCount, safeGet } from '@firebase/util';\nimport { stringify } from '@firebase/util';\nimport { assert } from '@firebase/util';\nimport { error, log, logWrapper, warn, ObjectToUniqueKey } from './util/util';\nimport { Path } from './util/Path';\nimport { VisibilityMonitor } from './util/VisibilityMonitor';\nimport { OnlineMonitor } from './util/OnlineMonitor';\nimport { isAdmin, isValidFormat } from '@firebase/util';\nimport { Connection } from '../realtime/Connection';\nimport { CONSTANTS } from '@firebase/util';\nimport { isMobileCordova, isReactNative, isNodeSdk } from '@firebase/util';\nimport { ServerActions } from './ServerActions';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { RepoInfo } from './RepoInfo';\nimport { Query } from '../api/Query';\n\nconst RECONNECT_MIN_DELAY = 1000;\nconst RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\nconst RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\nconst RECONNECT_DELAY_MULTIPLIER = 1.3;\nconst RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\nconst SERVER_KILL_INTERRUPT_REASON = 'server_kill';\n\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nconst INVALID_AUTH_TOKEN_THRESHOLD = 3;\n\ninterface ListenSpec {\n  onComplete(s: string, p?: any): void;\n\n  hashFn(): string;\n\n  query: Query;\n  tag: number | null;\n}\n\ninterface OnDisconnectRequest {\n  pathString: string;\n  action: string;\n  data: any;\n  onComplete?: (a: string, b: string) => void;\n}\n\ninterface OutstandingPut {\n  action: string;\n  request: Object;\n  queued?: boolean;\n  onComplete: (a: string, b?: string) => void;\n}\n\n/**\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\n *\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\n * in quotes to make sure the closure compiler does not minify them.\n */\nexport class PersistentConnection extends ServerActions {\n  // Used for diagnostic logging.\n  id = PersistentConnection.nextPersistentConnectionId_++;\n  private log_ = logWrapper('p:' + this.id + ':');\n\n  /** @private {Object} */\n  private interruptReasons_: { [reason: string]: boolean } = {};\n  private listens_: { [path: string]: { [queryId: string]: ListenSpec } } = {};\n  private outstandingPuts_: OutstandingPut[] = [];\n  private outstandingPutCount_ = 0;\n  private onDisconnectRequestQueue_: OnDisconnectRequest[] = [];\n  private connected_ = false;\n  private reconnectDelay_ = RECONNECT_MIN_DELAY;\n  private maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n  private securityDebugCallback_: ((a: Object) => void) | null = null;\n  lastSessionId: string | null = null;\n\n  /** @private {number|null} */\n  private establishConnectionTimer_: number | null = null;\n\n  /** @private {boolean} */\n  private visible_: boolean = false;\n\n  // Before we get connected, we keep a queue of pending messages to send.\n  private requestCBHash_: { [k: number]: (a: any) => void } = {};\n  private requestNumber_ = 0;\n\n  /** @private {?{\n   *   sendRequest(Object),\n   *   close()\n   * }} */\n  private realtime_: {\n    sendRequest(a: Object): void;\n    close(): void;\n  } | null = null;\n\n  /** @private {string|null} */\n  private authToken_: string | null = null;\n  private forceTokenRefresh_ = false;\n  private invalidAuthTokenCount_ = 0;\n\n  private firstConnection_ = true;\n  private lastConnectionAttemptTime_: number | null = null;\n  private lastConnectionEstablishedTime_: number | null = null;\n\n  /**\n   * @private\n   */\n  private static nextPersistentConnectionId_ = 0;\n\n  /**\n   * Counter for number of connections created. Mainly used for tagging in the logs\n   * @type {number}\n   * @private\n   */\n  private static nextConnectionId_ = 0;\n\n  /**\n   * @implements {ServerActions}\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param onConnectStatus_\n   * @param onServerInfoUpdate_\n   * @param authTokenProvider_\n   * @param authOverride_\n   */\n  constructor(\n    private repoInfo_: RepoInfo,\n    private onDataUpdate_: (\n      a: string,\n      b: any,\n      c: boolean,\n      d: number | null\n    ) => void,\n    private onConnectStatus_: (a: boolean) => void,\n    private onServerInfoUpdate_: (a: any) => void,\n    private authTokenProvider_: AuthTokenProvider,\n    private authOverride_?: Object | null\n  ) {\n    super();\n\n    if (authOverride_ && !isNodeSdk()) {\n      throw new Error(\n        'Auth override specified in options, but not supported on non Node.js platforms'\n      );\n    }\n    this.scheduleConnect_(0);\n\n    VisibilityMonitor.getInstance().on('visible', this.onVisible_, this);\n\n    if (repoInfo_.host.indexOf('fblocal') === -1) {\n      OnlineMonitor.getInstance().on('online', this.onOnline_, this);\n    }\n  }\n\n  /**\n   * @param {!string} action\n   * @param {*} body\n   * @param {function(*)=} onResponse\n   * @protected\n   */\n  protected sendRequest(\n    action: string,\n    body: any,\n    onResponse?: (a: any) => void\n  ) {\n    const curReqNum = ++this.requestNumber_;\n\n    const msg = { r: curReqNum, a: action, b: body };\n    this.log_(stringify(msg));\n    assert(\n      this.connected_,\n      \"sendRequest call when we're not connected not allowed.\"\n    );\n    this.realtime_.sendRequest(msg);\n    if (onResponse) {\n      this.requestCBHash_[curReqNum] = onResponse;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  listen(\n    query: Query,\n    currentHashFn: () => string,\n    tag: number | null,\n    onComplete: (a: string, b: any) => void\n  ) {\n    const queryId = query.queryIdentifier();\n    const pathString = query.path.toString();\n    this.log_('Listen called for ' + pathString + ' ' + queryId);\n    this.listens_[pathString] = this.listens_[pathString] || {};\n    assert(\n      query.getQueryParams().isDefault() ||\n        !query.getQueryParams().loadsAllData(),\n      'listen() called for non-default but complete query'\n    );\n    assert(\n      !this.listens_[pathString][queryId],\n      'listen() called twice for same path/queryId.'\n    );\n    const listenSpec: ListenSpec = {\n      onComplete: onComplete,\n      hashFn: currentHashFn,\n      query: query,\n      tag: tag\n    };\n    this.listens_[pathString][queryId] = listenSpec;\n\n    if (this.connected_) {\n      this.sendListen_(listenSpec);\n    }\n  }\n\n  /**\n   * @param {!{onComplete(),\n   *           hashFn():!string,\n   *           query: !Query,\n   *           tag: ?number}} listenSpec\n   * @private\n   */\n  private sendListen_(listenSpec: ListenSpec) {\n    const query = listenSpec.query;\n    const pathString = query.path.toString();\n    const queryId = query.queryIdentifier();\n    this.log_('Listen on ' + pathString + ' for ' + queryId);\n    const req: { [k: string]: any } = { /*path*/ p: pathString };\n\n    const action = 'q';\n\n    // Only bother to send query if it's non-default.\n    if (listenSpec.tag) {\n      req['q'] = query.queryObject();\n      req['t'] = listenSpec.tag;\n    }\n\n    req[/*hash*/ 'h'] = listenSpec.hashFn();\n\n    this.sendRequest(action, req, (message: { [k: string]: any }) => {\n      const payload: any = message[/*data*/ 'd'];\n      const status: string = message[/*status*/ 's'];\n\n      // print warnings in any case...\n      PersistentConnection.warnOnListenWarnings_(payload, query);\n\n      const currentListenSpec =\n        this.listens_[pathString] && this.listens_[pathString][queryId];\n      // only trigger actions if the listen hasn't been removed and readded\n      if (currentListenSpec === listenSpec) {\n        this.log_('listen response', message);\n\n        if (status !== 'ok') {\n          this.removeListen_(pathString, queryId);\n        }\n\n        if (listenSpec.onComplete) {\n          listenSpec.onComplete(status, payload);\n        }\n      }\n    });\n  }\n\n  /**\n   * @param {*} payload\n   * @param {!Query} query\n   * @private\n   */\n  private static warnOnListenWarnings_(payload: any, query: Query) {\n    if (payload && typeof payload === 'object' && contains(payload, 'w')) {\n      const warnings = safeGet(payload, 'w');\n      if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\n        const indexSpec =\n          '\".indexOn\": \"' +\n          query\n            .getQueryParams()\n            .getIndex()\n            .toString() +\n          '\"';\n        const indexPath = query.path.toString();\n        warn(\n          `Using an unspecified index. Your data will be downloaded and ` +\n            `filtered on the client. Consider adding ${indexSpec} at ` +\n            `${indexPath} to your security rules for better performance.`\n        );\n      }\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  refreshAuthToken(token: string) {\n    this.authToken_ = token;\n    this.log_('Auth token refreshed');\n    if (this.authToken_) {\n      this.tryAuth();\n    } else {\n      //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n      //the credential so we dont become authenticated next time we connect.\n      if (this.connected_) {\n        this.sendRequest('unauth', {}, () => {});\n      }\n    }\n\n    this.reduceReconnectDelayIfAdminCredential_(token);\n  }\n\n  /**\n   * @param {!string} credential\n   * @private\n   */\n  private reduceReconnectDelayIfAdminCredential_(credential: string) {\n    // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n    // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n    const isFirebaseSecret = credential && credential.length === 40;\n    if (isFirebaseSecret || isAdmin(credential)) {\n      this.log_(\n        'Admin auth credential detected.  Reducing max reconnect time.'\n      );\n      this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n    }\n  }\n\n  /**\n   * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\n   * a auth revoked (the connection is closed).\n   */\n  tryAuth() {\n    if (this.connected_ && this.authToken_) {\n      const token = this.authToken_;\n      const authMethod = isValidFormat(token) ? 'auth' : 'gauth';\n      const requestData: { [k: string]: any } = { cred: token };\n      if (this.authOverride_ === null) {\n        requestData['noauth'] = true;\n      } else if (typeof this.authOverride_ === 'object') {\n        requestData['authvar'] = this.authOverride_;\n      }\n      this.sendRequest(authMethod, requestData, (res: { [k: string]: any }) => {\n        const status: string = res[/*status*/ 's'];\n        const data: string = res[/*data*/ 'd'] || 'error';\n\n        if (this.authToken_ === token) {\n          if (status === 'ok') {\n            this.invalidAuthTokenCount_ = 0;\n          } else {\n            // Triggers reconnect and force refresh for auth token\n            this.onAuthRevoked_(status, data);\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  unlisten(query: Query, tag: number | null) {\n    const pathString = query.path.toString();\n    const queryId = query.queryIdentifier();\n\n    this.log_('Unlisten called for ' + pathString + ' ' + queryId);\n\n    assert(\n      query.getQueryParams().isDefault() ||\n        !query.getQueryParams().loadsAllData(),\n      'unlisten() called for non-default but complete query'\n    );\n    const listen = this.removeListen_(pathString, queryId);\n    if (listen && this.connected_) {\n      this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);\n    }\n  }\n\n  private sendUnlisten_(\n    pathString: string,\n    queryId: string,\n    queryObj: Object,\n    tag: number | null\n  ) {\n    this.log_('Unlisten on ' + pathString + ' for ' + queryId);\n\n    const req: { [k: string]: any } = { /*path*/ p: pathString };\n    const action = 'n';\n    // Only bother sending queryId if it's non-default.\n    if (tag) {\n      req['q'] = queryObj;\n      req['t'] = tag;\n    }\n\n    this.sendRequest(action, req);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectPut(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('o', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'o',\n        data,\n        onComplete\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectMerge(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('om', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'om',\n        data,\n        onComplete\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectCancel(\n    pathString: string,\n    onComplete?: (a: string, b: string) => void\n  ) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('oc', pathString, null, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'oc',\n        data: null,\n        onComplete\n      });\n    }\n  }\n\n  private sendOnDisconnect_(\n    action: string,\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string) => void\n  ) {\n    const request = { /*path*/ p: pathString, /*data*/ d: data };\n    this.log_('onDisconnect ' + action, request);\n    this.sendRequest(action, request, (response: { [k: string]: any }) => {\n      if (onComplete) {\n        setTimeout(function() {\n          onComplete(response[/*status*/ 's'], response[/* data */ 'd']);\n        }, Math.floor(0));\n      }\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  put(\n    pathString: string,\n    data: any,\n    onComplete?: (a: string, b: string) => void,\n    hash?: string\n  ) {\n    this.putInternal('p', pathString, data, onComplete, hash);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  merge(\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string | null) => void,\n    hash?: string\n  ) {\n    this.putInternal('m', pathString, data, onComplete, hash);\n  }\n\n  putInternal(\n    action: string,\n    pathString: string,\n    data: any,\n    onComplete: (a: string, b: string | null) => void,\n    hash?: string\n  ) {\n    const request: { [k: string]: any } = {\n      /*path*/ p: pathString,\n      /*data*/ d: data\n    };\n\n    if (hash !== undefined) request[/*hash*/ 'h'] = hash;\n\n    // TODO: Only keep track of the most recent put for a given path?\n    this.outstandingPuts_.push({\n      action,\n      request,\n      onComplete\n    });\n\n    this.outstandingPutCount_++;\n    const index = this.outstandingPuts_.length - 1;\n\n    if (this.connected_) {\n      this.sendPut_(index);\n    } else {\n      this.log_('Buffering put: ' + pathString);\n    }\n  }\n\n  private sendPut_(index: number) {\n    const action = this.outstandingPuts_[index].action;\n    const request = this.outstandingPuts_[index].request;\n    const onComplete = this.outstandingPuts_[index].onComplete;\n    this.outstandingPuts_[index].queued = this.connected_;\n\n    this.sendRequest(action, request, (message: { [k: string]: any }) => {\n      this.log_(action + ' response', message);\n\n      delete this.outstandingPuts_[index];\n      this.outstandingPutCount_--;\n\n      // Clean up array occasionally.\n      if (this.outstandingPutCount_ === 0) {\n        this.outstandingPuts_ = [];\n      }\n\n      if (onComplete)\n        onComplete(message[/*status*/ 's'], message[/* data */ 'd']);\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  reportStats(stats: { [k: string]: any }) {\n    // If we're not connected, we just drop the stats.\n    if (this.connected_) {\n      const request = { /*counters*/ c: stats };\n      this.log_('reportStats', request);\n\n      this.sendRequest(/*stats*/ 's', request, result => {\n        const status = result[/*status*/ 's'];\n        if (status !== 'ok') {\n          const errorReason = result[/* data */ 'd'];\n          this.log_('reportStats', 'Error sending stats: ' + errorReason);\n        }\n      });\n    }\n  }\n\n  /**\n   * @param {*} message\n   * @private\n   */\n  private onDataMessage_(message: { [k: string]: any }) {\n    if ('r' in message) {\n      // this is a response\n      this.log_('from server: ' + stringify(message));\n      const reqNum = message['r'];\n      const onResponse = this.requestCBHash_[reqNum];\n      if (onResponse) {\n        delete this.requestCBHash_[reqNum];\n        onResponse(message[/*body*/ 'b']);\n      }\n    } else if ('error' in message) {\n      throw 'A server-side error has occurred: ' + message['error'];\n    } else if ('a' in message) {\n      // a and b are action and body, respectively\n      this.onDataPush_(message['a'], message['b']);\n    }\n  }\n\n  private onDataPush_(action: string, body: { [k: string]: any }) {\n    this.log_('handleServerMessage', action, body);\n    if (action === 'd')\n      this.onDataUpdate_(\n        body[/*path*/ 'p'],\n        body[/*data*/ 'd'],\n        /*isMerge*/ false,\n        body['t']\n      );\n    else if (action === 'm')\n      this.onDataUpdate_(\n        body[/*path*/ 'p'],\n        body[/*data*/ 'd'],\n        /*isMerge=*/ true,\n        body['t']\n      );\n    else if (action === 'c')\n      this.onListenRevoked_(body[/*path*/ 'p'], body[/*query*/ 'q']);\n    else if (action === 'ac')\n      this.onAuthRevoked_(\n        body[/*status code*/ 's'],\n        body[/* explanation */ 'd']\n      );\n    else if (action === 'sd') this.onSecurityDebugPacket_(body);\n    else\n      error(\n        'Unrecognized action received from server: ' +\n          stringify(action) +\n          '\\nAre you using the latest client?'\n      );\n  }\n\n  private onReady_(timestamp: number, sessionId: string) {\n    this.log_('connection ready');\n    this.connected_ = true;\n    this.lastConnectionEstablishedTime_ = new Date().getTime();\n    this.handleTimestamp_(timestamp);\n    this.lastSessionId = sessionId;\n    if (this.firstConnection_) {\n      this.sendConnectStats_();\n    }\n    this.restoreState_();\n    this.firstConnection_ = false;\n    this.onConnectStatus_(true);\n  }\n\n  private scheduleConnect_(timeout: number) {\n    assert(\n      !this.realtime_,\n      \"Scheduling a connect when we're already connected/ing?\"\n    );\n\n    if (this.establishConnectionTimer_) {\n      clearTimeout(this.establishConnectionTimer_);\n    }\n\n    // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n    // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n\n    this.establishConnectionTimer_ = setTimeout(() => {\n      this.establishConnectionTimer_ = null;\n      this.establishConnection_();\n    }, Math.floor(timeout)) as any;\n  }\n\n  /**\n   * @param {boolean} visible\n   * @private\n   */\n  private onVisible_(visible: boolean) {\n    // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n    if (\n      visible &&\n      !this.visible_ &&\n      this.reconnectDelay_ === this.maxReconnectDelay_\n    ) {\n      this.log_('Window became visible.  Reducing delay.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n    this.visible_ = visible;\n  }\n\n  private onOnline_(online: boolean) {\n    if (online) {\n      this.log_('Browser went online.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    } else {\n      this.log_('Browser went offline.  Killing connection.');\n      if (this.realtime_) {\n        this.realtime_.close();\n      }\n    }\n  }\n\n  private onRealtimeDisconnect_() {\n    this.log_('data client disconnected');\n    this.connected_ = false;\n    this.realtime_ = null;\n\n    // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n    this.cancelSentTransactions_();\n\n    // Clear out the pending requests.\n    this.requestCBHash_ = {};\n\n    if (this.shouldReconnect_()) {\n      if (!this.visible_) {\n        this.log_(\"Window isn't visible.  Delaying reconnect.\");\n        this.reconnectDelay_ = this.maxReconnectDelay_;\n        this.lastConnectionAttemptTime_ = new Date().getTime();\n      } else if (this.lastConnectionEstablishedTime_) {\n        // If we've been connected long enough, reset reconnect delay to minimum.\n        const timeSinceLastConnectSucceeded =\n          new Date().getTime() - this.lastConnectionEstablishedTime_;\n        if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT)\n          this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        this.lastConnectionEstablishedTime_ = null;\n      }\n\n      const timeSinceLastConnectAttempt =\n        new Date().getTime() - this.lastConnectionAttemptTime_;\n      let reconnectDelay = Math.max(\n        0,\n        this.reconnectDelay_ - timeSinceLastConnectAttempt\n      );\n      reconnectDelay = Math.random() * reconnectDelay;\n\n      this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\n      this.scheduleConnect_(reconnectDelay);\n\n      // Adjust reconnect delay for next time.\n      this.reconnectDelay_ = Math.min(\n        this.maxReconnectDelay_,\n        this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER\n      );\n    }\n    this.onConnectStatus_(false);\n  }\n\n  private establishConnection_() {\n    if (this.shouldReconnect_()) {\n      this.log_('Making a connection attempt');\n      this.lastConnectionAttemptTime_ = new Date().getTime();\n      this.lastConnectionEstablishedTime_ = null;\n      const onDataMessage = this.onDataMessage_.bind(this);\n      const onReady = this.onReady_.bind(this);\n      const onDisconnect = this.onRealtimeDisconnect_.bind(this);\n      const connId = this.id + ':' + PersistentConnection.nextConnectionId_++;\n      const self = this;\n      const lastSessionId = this.lastSessionId;\n      let canceled = false;\n      let connection: Connection | null = null;\n      const closeFn = function() {\n        if (connection) {\n          connection.close();\n        } else {\n          canceled = true;\n          onDisconnect();\n        }\n      };\n      const sendRequestFn = function(msg: Object) {\n        assert(\n          connection,\n          \"sendRequest call when we're not connected not allowed.\"\n        );\n        connection.sendRequest(msg);\n      };\n\n      this.realtime_ = {\n        close: closeFn,\n        sendRequest: sendRequestFn\n      };\n\n      const forceRefresh = this.forceTokenRefresh_;\n      this.forceTokenRefresh_ = false;\n\n      // First fetch auth token, and establish connection after fetching the token was successful\n      this.authTokenProvider_\n        .getToken(forceRefresh)\n        .then(function(result) {\n          if (!canceled) {\n            log('getToken() completed. Creating connection.');\n            self.authToken_ = result && result.accessToken;\n            connection = new Connection(\n              connId,\n              self.repoInfo_,\n              onDataMessage,\n              onReady,\n              onDisconnect,\n              /* onKill= */ function(reason) {\n                warn(reason + ' (' + self.repoInfo_.toString() + ')');\n                self.interrupt(SERVER_KILL_INTERRUPT_REASON);\n              },\n              lastSessionId\n            );\n          } else {\n            log('getToken() completed but was canceled');\n          }\n        })\n        .then(null, function(error) {\n          self.log_('Failed to get token: ' + error);\n          if (!canceled) {\n            if (CONSTANTS.NODE_ADMIN) {\n              // This may be a critical error for the Admin Node.js SDK, so log a warning.\n              // But getToken() may also just have temporarily failed, so we still want to\n              // continue retrying.\n              warn(error);\n            }\n            closeFn();\n          }\n        });\n    }\n  }\n\n  /**\n   * @param {string} reason\n   */\n  interrupt(reason: string) {\n    log('Interrupting connection for reason: ' + reason);\n    this.interruptReasons_[reason] = true;\n    if (this.realtime_) {\n      this.realtime_.close();\n    } else {\n      if (this.establishConnectionTimer_) {\n        clearTimeout(this.establishConnectionTimer_);\n        this.establishConnectionTimer_ = null;\n      }\n      if (this.connected_) {\n        this.onRealtimeDisconnect_();\n      }\n    }\n  }\n\n  /**\n   * @param {string} reason\n   */\n  resume(reason: string) {\n    log('Resuming connection for reason: ' + reason);\n    delete this.interruptReasons_[reason];\n    if (isEmpty(this.interruptReasons_)) {\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n  }\n\n  private handleTimestamp_(timestamp: number) {\n    const delta = timestamp - new Date().getTime();\n    this.onServerInfoUpdate_({ serverTimeOffset: delta });\n  }\n\n  private cancelSentTransactions_() {\n    for (let i = 0; i < this.outstandingPuts_.length; i++) {\n      const put = this.outstandingPuts_[i];\n      if (put && /*hash*/ 'h' in put.request && put.queued) {\n        if (put.onComplete) put.onComplete('disconnect');\n\n        delete this.outstandingPuts_[i];\n        this.outstandingPutCount_--;\n      }\n    }\n\n    // Clean up array occasionally.\n    if (this.outstandingPutCount_ === 0) this.outstandingPuts_ = [];\n  }\n\n  /**\n   * @param {!string} pathString\n   * @param {Array.<*>=} query\n   * @private\n   */\n  private onListenRevoked_(pathString: string, query?: any[]) {\n    // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n    let queryId;\n    if (!query) {\n      queryId = 'default';\n    } else {\n      queryId = query.map(q => ObjectToUniqueKey(q)).join('$');\n    }\n    const listen = this.removeListen_(pathString, queryId);\n    if (listen && listen.onComplete) listen.onComplete('permission_denied');\n  }\n\n  /**\n   * @param {!string} pathString\n   * @param {!string} queryId\n   * @return {{queries:Array.<Query>, onComplete:function(string)}}\n   * @private\n   */\n  private removeListen_(pathString: string, queryId: string): ListenSpec {\n    const normalizedPathString = new Path(pathString).toString(); // normalize path.\n    let listen;\n    if (this.listens_[normalizedPathString] !== undefined) {\n      listen = this.listens_[normalizedPathString][queryId];\n      delete this.listens_[normalizedPathString][queryId];\n      if (getCount(this.listens_[normalizedPathString]) === 0) {\n        delete this.listens_[normalizedPathString];\n      }\n    } else {\n      // all listens for this path has already been removed\n      listen = undefined;\n    }\n    return listen;\n  }\n\n  private onAuthRevoked_(statusCode: string, explanation: string) {\n    log('Auth token revoked: ' + statusCode + '/' + explanation);\n    this.authToken_ = null;\n    this.forceTokenRefresh_ = true;\n    this.realtime_.close();\n    if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\n      // We'll wait a couple times before logging the warning / increasing the\n      // retry period since oauth tokens will report as \"invalid\" if they're\n      // just expired. Plus there may be transient issues that resolve themselves.\n      this.invalidAuthTokenCount_++;\n      if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {\n        // Set a long reconnect delay because recovery is unlikely\n        this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n\n        // Notify the auth token provider that the token is invalid, which will log\n        // a warning\n        this.authTokenProvider_.notifyForInvalidToken();\n      }\n    }\n  }\n\n  private onSecurityDebugPacket_(body: { [k: string]: any }) {\n    if (this.securityDebugCallback_) {\n      this.securityDebugCallback_(body);\n    } else {\n      if ('msg' in body && typeof console !== 'undefined') {\n        console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\n      }\n    }\n  }\n\n  private restoreState_() {\n    //Re-authenticate ourselves if we have a credential stored.\n    this.tryAuth();\n\n    // Puts depend on having received the corresponding data update from the server before they complete, so we must\n    // make sure to send listens before puts.\n    forEach(this.listens_, (pathString: string, queries: Object) => {\n      forEach(queries, (key: string, listenSpec: ListenSpec) => {\n        this.sendListen_(listenSpec);\n      });\n    });\n\n    for (let i = 0; i < this.outstandingPuts_.length; i++) {\n      if (this.outstandingPuts_[i]) this.sendPut_(i);\n    }\n\n    while (this.onDisconnectRequestQueue_.length) {\n      const request = this.onDisconnectRequestQueue_.shift();\n      this.sendOnDisconnect_(\n        request.action,\n        request.pathString,\n        request.data,\n        request.onComplete\n      );\n    }\n  }\n\n  /**\n   * Sends client stats for first connection\n   * @private\n   */\n  private sendConnectStats_() {\n    const stats: { [k: string]: number } = {};\n\n    let clientName = 'js';\n    if (CONSTANTS.NODE_ADMIN) {\n      clientName = 'admin_node';\n    } else if (CONSTANTS.NODE_CLIENT) {\n      clientName = 'node';\n    }\n\n    stats[\n      'sdk.' + clientName + '.' + firebase.SDK_VERSION.replace(/\\./g, '-')\n    ] = 1;\n\n    if (isMobileCordova()) {\n      stats['framework.cordova'] = 1;\n    } else if (isReactNative()) {\n      stats['framework.reactnative'] = 1;\n    }\n    this.reportStats(stats);\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  private shouldReconnect_(): boolean {\n    const online = OnlineMonitor.getInstance().currentlyOnline();\n    return isEmpty(this.interruptReasons_) && online;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}