{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"../core/util/util\");\nvar CountedSet_1 = require(\"../core/util/CountedSet\");\nvar StatsManager_1 = require(\"../core/stats/StatsManager\");\nvar PacketReceiver_1 = require(\"./polling/PacketReceiver\");\nvar Constants_1 = require(\"./Constants\");\nvar util_2 = require(\"@firebase/util\");\nvar util_3 = require(\"@firebase/util\");\n// URL query parameters associated with longpolling\nexports.FIREBASE_LONGPOLL_START_PARAM = 'start';\nexports.FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';\nexports.FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';\nexports.FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';\nexports.FIREBASE_LONGPOLL_ID_PARAM = 'id';\nexports.FIREBASE_LONGPOLL_PW_PARAM = 'pw';\nexports.FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';\nexports.FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';\nexports.FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';\nexports.FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';\nexports.FIREBASE_LONGPOLL_DATA_PARAM = 'd';\nexports.FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = 'disconn';\nexports.FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';\n//Data size constants.\n//TODO: Perf: the maximum length actually differs from browser to browser.\n// We should check what browser we're on and set accordingly.\nvar MAX_URL_DATA_SIZE = 1870;\nvar SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\nvar MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\n/**\n * Keepalive period\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\n * length of 30 seconds that we can't exceed.\n * @const\n * @type {number}\n */\nvar KEEPALIVE_REQUEST_INTERVAL = 25000;\n/**\n * How long to wait before aborting a long-polling connection attempt.\n * @const\n * @type {number}\n */\nvar LP_CONNECT_TIMEOUT = 30000;\n/**\n * This class manages a single long-polling connection.\n *\n * @constructor\n * @implements {Transport}\n */\nvar BrowserPollConnection = /** @class */function () {\n  /**\n   * @param {string} connId An identifier for this connection, used for logging\n   * @param {RepoInfo} repoInfo The info for the endpoint to send data to.\n   * @param {string=} transportSessionId Optional transportSessionid if we are reconnecting for an existing\n   *                                         transport session\n   * @param {string=}  lastSessionId Optional lastSessionId if the PersistentConnection has already created a\n   *                                     connection previously\n   */\n  function BrowserPollConnection(connId, repoInfo, transportSessionId, lastSessionId) {\n    this.connId = connId;\n    this.repoInfo = repoInfo;\n    this.transportSessionId = transportSessionId;\n    this.lastSessionId = lastSessionId;\n    this.bytesSent = 0;\n    this.bytesReceived = 0;\n    this.everConnected_ = false;\n    this.log_ = util_1.logWrapper(connId);\n    this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo);\n    this.urlFn = function (params) {\n      return repoInfo.connectionURL(Constants_1.LONG_POLLING, params);\n    };\n  }\n  /**\n   *\n   * @param {function(Object)} onMessage Callback when messages arrive\n   * @param {function()} onDisconnect Callback with connection lost.\n   */\n  BrowserPollConnection.prototype.open = function (onMessage, onDisconnect) {\n    var _this = this;\n    this.curSegmentNum = 0;\n    this.onDisconnect_ = onDisconnect;\n    this.myPacketOrderer = new PacketReceiver_1.PacketReceiver(onMessage);\n    this.isClosed_ = false;\n    this.connectTimeoutTimer_ = setTimeout(function () {\n      _this.log_('Timed out trying to connect.');\n      // Make sure we clear the host cache\n      _this.onClosed_();\n      _this.connectTimeoutTimer_ = null;\n    }, Math.floor(LP_CONNECT_TIMEOUT));\n    // Ensure we delay the creation of the iframe until the DOM is loaded.\n    util_1.executeWhenDOMReady(function () {\n      if (_this.isClosed_) return;\n      //Set up a callback that gets triggered once a connection is set up.\n      _this.scriptTagHolder = new FirebaseIFrameScriptHolder(function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var command = args[0],\n          arg1 = args[1],\n          arg2 = args[2],\n          arg3 = args[3],\n          arg4 = args[4];\n        _this.incrementIncomingBytes_(args);\n        if (!_this.scriptTagHolder) return; // we closed the connection.\n        if (_this.connectTimeoutTimer_) {\n          clearTimeout(_this.connectTimeoutTimer_);\n          _this.connectTimeoutTimer_ = null;\n        }\n        _this.everConnected_ = true;\n        if (command == exports.FIREBASE_LONGPOLL_START_PARAM) {\n          _this.id = arg1;\n          _this.password = arg2;\n        } else if (command === exports.FIREBASE_LONGPOLL_CLOSE_COMMAND) {\n          // Don't clear the host cache. We got a response from the server, so we know it's reachable\n          if (arg1) {\n            // We aren't expecting any more data (other than what the server's already in the process of sending us\n            // through our already open polls), so don't send any more.\n            _this.scriptTagHolder.sendNewPolls = false;\n            // arg1 in this case is the last response number sent by the server. We should try to receive\n            // all of the responses up to this one before closing\n            _this.myPacketOrderer.closeAfter(arg1, function () {\n              _this.onClosed_();\n            });\n          } else {\n            _this.onClosed_();\n          }\n        } else {\n          throw new Error('Unrecognized command received: ' + command);\n        }\n      }, function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var pN = args[0],\n          data = args[1];\n        _this.incrementIncomingBytes_(args);\n        _this.myPacketOrderer.handleResponse(pN, data);\n      }, function () {\n        _this.onClosed_();\n      }, _this.urlFn);\n      //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\n      //from cache.\n      var urlParams = {};\n      urlParams[exports.FIREBASE_LONGPOLL_START_PARAM] = 't';\n      urlParams[exports.FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);\n      if (_this.scriptTagHolder.uniqueCallbackIdentifier) urlParams[exports.FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = _this.scriptTagHolder.uniqueCallbackIdentifier;\n      urlParams[Constants_1.VERSION_PARAM] = Constants_1.PROTOCOL_VERSION;\n      if (_this.transportSessionId) {\n        urlParams[Constants_1.TRANSPORT_SESSION_PARAM] = _this.transportSessionId;\n      }\n      if (_this.lastSessionId) {\n        urlParams[Constants_1.LAST_SESSION_PARAM] = _this.lastSessionId;\n      }\n      if (!util_3.isNodeSdk() && typeof location !== 'undefined' && location.href && location.href.indexOf(Constants_1.FORGE_DOMAIN) !== -1) {\n        urlParams[Constants_1.REFERER_PARAM] = Constants_1.FORGE_REF;\n      }\n      var connectURL = _this.urlFn(urlParams);\n      _this.log_('Connecting via long-poll to ' + connectURL);\n      _this.scriptTagHolder.addTag(connectURL, function () {\n        /* do nothing */\n      });\n    });\n  };\n  /**\n   * Call this when a handshake has completed successfully and we want to consider the connection established\n   */\n  BrowserPollConnection.prototype.start = function () {\n    this.scriptTagHolder.startLongPoll(this.id, this.password);\n    this.addDisconnectPingFrame(this.id, this.password);\n  };\n  /**\n   * Forces long polling to be considered as a potential transport\n   */\n  BrowserPollConnection.forceAllow = function () {\n    BrowserPollConnection.forceAllow_ = true;\n  };\n  /**\n   * Forces longpolling to not be considered as a potential transport\n   */\n  BrowserPollConnection.forceDisallow = function () {\n    BrowserPollConnection.forceDisallow_ = true;\n  };\n  // Static method, use string literal so it can be accessed in a generic way\n  BrowserPollConnection.isAvailable = function () {\n    // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\n    // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\n    return BrowserPollConnection.forceAllow_ || !BrowserPollConnection.forceDisallow_ && typeof document !== 'undefined' && document.createElement != null && !util_1.isChromeExtensionContentScript() && !util_1.isWindowsStoreApp() && !util_3.isNodeSdk();\n  };\n  /**\n   * No-op for polling\n   */\n  BrowserPollConnection.prototype.markConnectionHealthy = function () {};\n  /**\n   * Stops polling and cleans up the iframe\n   * @private\n   */\n  BrowserPollConnection.prototype.shutdown_ = function () {\n    this.isClosed_ = true;\n    if (this.scriptTagHolder) {\n      this.scriptTagHolder.close();\n      this.scriptTagHolder = null;\n    }\n    //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\n    if (this.myDisconnFrame) {\n      document.body.removeChild(this.myDisconnFrame);\n      this.myDisconnFrame = null;\n    }\n    if (this.connectTimeoutTimer_) {\n      clearTimeout(this.connectTimeoutTimer_);\n      this.connectTimeoutTimer_ = null;\n    }\n  };\n  /**\n   * Triggered when this transport is closed\n   * @private\n   */\n  BrowserPollConnection.prototype.onClosed_ = function () {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is closing itself');\n      this.shutdown_();\n      if (this.onDisconnect_) {\n        this.onDisconnect_(this.everConnected_);\n        this.onDisconnect_ = null;\n      }\n    }\n  };\n  /**\n   * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\n   * that we've left.\n   */\n  BrowserPollConnection.prototype.close = function () {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is being closed.');\n      this.shutdown_();\n    }\n  };\n  /**\n   * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\n   * broken into chunks (since URLs have a small maximum length).\n   * @param {!Object} data The JSON data to transmit.\n   */\n  BrowserPollConnection.prototype.send = function (data) {\n    var dataStr = util_2.stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length);\n    //first, lets get the base64-encoded data\n    var base64data = util_2.base64Encode(dataStr);\n    //We can only fit a certain amount in each URL, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n    var dataSegs = util_1.splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\n    //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\n    //of segments so that we can reassemble the packet on the server.\n    for (var i = 0; i < dataSegs.length; i++) {\n      this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);\n      this.curSegmentNum++;\n    }\n  };\n  /**\n   * This is how we notify the server that we're leaving.\n   * We aren't able to send requests with DHTML on a window close event, but we can\n   * trigger XHR requests in some browsers (everything but Opera basically).\n   * @param {!string} id\n   * @param {!string} pw\n   */\n  BrowserPollConnection.prototype.addDisconnectPingFrame = function (id, pw) {\n    if (util_3.isNodeSdk()) return;\n    this.myDisconnFrame = document.createElement('iframe');\n    var urlParams = {};\n    urlParams[exports.FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';\n    urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = id;\n    urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = pw;\n    this.myDisconnFrame.src = this.urlFn(urlParams);\n    this.myDisconnFrame.style.display = 'none';\n    document.body.appendChild(this.myDisconnFrame);\n  };\n  /**\n   * Used to track the bytes received by this client\n   * @param {*} args\n   * @private\n   */\n  BrowserPollConnection.prototype.incrementIncomingBytes_ = function (args) {\n    // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\n    var bytesReceived = util_2.stringify(args).length;\n    this.bytesReceived += bytesReceived;\n    this.stats_.incrementCounter('bytes_received', bytesReceived);\n  };\n  return BrowserPollConnection;\n}();\nexports.BrowserPollConnection = BrowserPollConnection;\n/*********************************************************************************************\n * A wrapper around an iframe that is used as a long-polling script holder.\n * @constructor\n *********************************************************************************************/\nvar FirebaseIFrameScriptHolder = /** @class */function () {\n  /**\n   * @param commandCB - The callback to be called when control commands are recevied from the server.\n   * @param onMessageCB - The callback to be triggered when responses arrive from the server.\n   * @param onDisconnect - The callback to be triggered when this tag holder is closed\n   * @param urlFn - A function that provides the URL of the endpoint to send data to.\n   */\n  function FirebaseIFrameScriptHolder(commandCB, onMessageCB, onDisconnect, urlFn) {\n    this.onDisconnect = onDisconnect;\n    this.urlFn = urlFn;\n    //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\n    //problems in some browsers.\n    /**\n     * @type {CountedSet.<number, number>}\n     */\n    this.outstandingRequests = new CountedSet_1.CountedSet();\n    //A queue of the pending segments waiting for transmission to the server.\n    this.pendingSegs = [];\n    //A serial number. We use this for two things:\n    // 1) A way to ensure the browser doesn't cache responses to polls\n    // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\n    //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\n    //    JSONP code in the order it was added to the iframe.\n    this.currentSerial = Math.floor(Math.random() * 100000000);\n    // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\n    // incoming data from the server that we're waiting for).\n    this.sendNewPolls = true;\n    if (!util_3.isNodeSdk()) {\n      //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\n      //iframes where we put the long-polling script tags. We have two callbacks:\n      //   1) Command Callback - Triggered for control issues, like starting a connection.\n      //   2) Message Callback - Triggered when new data arrives.\n      this.uniqueCallbackIdentifier = util_1.LUIDGenerator();\n      window[exports.FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;\n      window[exports.FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;\n      //Create an iframe for us to add script tags to.\n      this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\n      // Set the iframe's contents.\n      var script = '';\n      // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\n      // for ie9, but ie8 needs to do it again in the document itself.\n      if (this.myIFrame.src && this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {\n        var currentDomain = document.domain;\n        script = '<script>document.domain=\"' + currentDomain + '\";</script>';\n      }\n      var iframeContents = '<html><body>' + script + '</body></html>';\n      try {\n        this.myIFrame.doc.open();\n        this.myIFrame.doc.write(iframeContents);\n        this.myIFrame.doc.close();\n      } catch (e) {\n        util_1.log('frame writing exception');\n        if (e.stack) {\n          util_1.log(e.stack);\n        }\n        util_1.log(e);\n      }\n    } else {\n      this.commandCB = commandCB;\n      this.onMessageCB = onMessageCB;\n    }\n  }\n  /**\n   * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\n   * actually use.\n   * @private\n   * @return {Element}\n   */\n  FirebaseIFrameScriptHolder.createIFrame_ = function () {\n    var iframe = document.createElement('iframe');\n    iframe.style.display = 'none';\n    // This is necessary in order to initialize the document inside the iframe\n    if (document.body) {\n      document.body.appendChild(iframe);\n      try {\n        // If document.domain has been modified in IE, this will throw an error, and we need to set the\n        // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\n        // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\n        var a = iframe.contentWindow.document;\n        if (!a) {\n          // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\n          util_1.log('No IE domain setting required');\n        }\n      } catch (e) {\n        var domain = document.domain;\n        iframe.src = \"javascript:void((function(){document.open();document.domain='\" + domain + \"';document.close();})())\";\n      }\n    } else {\n      // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\n      // never gets hit.\n      throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';\n    }\n    // Get the document of the iframe in a browser-specific way.\n    if (iframe.contentDocument) {\n      iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari\n    } else if (iframe.contentWindow) {\n      iframe.doc = iframe.contentWindow.document; // Internet Explorer\n    } else if (iframe.document) {\n      iframe.doc = iframe.document; //others?\n    }\n\n    return iframe;\n  };\n  /**\n   * Cancel all outstanding queries and remove the frame.\n   */\n  FirebaseIFrameScriptHolder.prototype.close = function () {\n    var _this = this;\n    //Mark this iframe as dead, so no new requests are sent.\n    this.alive = false;\n    if (this.myIFrame) {\n      //We have to actually remove all of the html inside this iframe before removing it from the\n      //window, or IE will continue loading and executing the script tags we've already added, which\n      //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.\n      this.myIFrame.doc.body.innerHTML = '';\n      setTimeout(function () {\n        if (_this.myIFrame !== null) {\n          document.body.removeChild(_this.myIFrame);\n          _this.myIFrame = null;\n        }\n      }, Math.floor(0));\n    }\n    if (util_3.isNodeSdk() && this.myID) {\n      var urlParams = {};\n      urlParams[exports.FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM] = 't';\n      urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n      urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n      var theURL = this.urlFn(urlParams);\n      FirebaseIFrameScriptHolder.nodeRestRequest(theURL);\n    }\n    // Protect from being called recursively.\n    var onDisconnect = this.onDisconnect;\n    if (onDisconnect) {\n      this.onDisconnect = null;\n      onDisconnect();\n    }\n  };\n  /**\n   * Actually start the long-polling session by adding the first script tag(s) to the iframe.\n   * @param {!string} id - The ID of this connection\n   * @param {!string} pw - The password for this connection\n   */\n  FirebaseIFrameScriptHolder.prototype.startLongPoll = function (id, pw) {\n    this.myID = id;\n    this.myPW = pw;\n    this.alive = true;\n    //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\n    while (this.newRequest_()) {}\n  };\n  /**\n   * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\n   * too many outstanding requests and we are still alive.\n   *\n   * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\n   * needed.\n   */\n  FirebaseIFrameScriptHolder.prototype.newRequest_ = function () {\n    // We keep one outstanding request open all the time to receive data, but if we need to send data\n    // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\n    // close the old request.\n    if (this.alive && this.sendNewPolls && this.outstandingRequests.count() < (this.pendingSegs.length > 0 ? 2 : 1)) {\n      //construct our url\n      this.currentSerial++;\n      var urlParams = {};\n      urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n      urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n      urlParams[exports.FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\n      var theURL = this.urlFn(urlParams);\n      //Now add as much data as we can.\n      var curDataString = '';\n      var i = 0;\n      while (this.pendingSegs.length > 0) {\n        //first, lets see if the next segment will fit.\n        var nextSeg = this.pendingSegs[0];\n        if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE) {\n          //great, the segment will fit. Lets append it.\n          var theSeg = this.pendingSegs.shift();\n          curDataString = curDataString + '&' + exports.FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + '=' + theSeg.seg + '&' + exports.FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + '=' + theSeg.ts + '&' + exports.FIREBASE_LONGPOLL_DATA_PARAM + i + '=' + theSeg.d;\n          i++;\n        } else {\n          break;\n        }\n      }\n      theURL = theURL + curDataString;\n      this.addLongPollTag_(theURL, this.currentSerial);\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * Queue a packet for transmission to the server.\n   * @param segnum - A sequential id for this packet segment used for reassembly\n   * @param totalsegs - The total number of segments in this packet\n   * @param data - The data for this segment.\n   */\n  FirebaseIFrameScriptHolder.prototype.enqueueSegment = function (segnum, totalsegs, data) {\n    //add this to the queue of segments to send.\n    this.pendingSegs.push({\n      seg: segnum,\n      ts: totalsegs,\n      d: data\n    });\n    //send the data immediately if there isn't already data being transmitted, unless\n    //startLongPoll hasn't been called yet.\n    if (this.alive) {\n      this.newRequest_();\n    }\n  };\n  /**\n   * Add a script tag for a regular long-poll request.\n   * @param {!string} url - The URL of the script tag.\n   * @param {!number} serial - The serial number of the request.\n   * @private\n   */\n  FirebaseIFrameScriptHolder.prototype.addLongPollTag_ = function (url, serial) {\n    var _this = this;\n    //remember that we sent this request.\n    this.outstandingRequests.add(serial, 1);\n    var doNewRequest = function doNewRequest() {\n      _this.outstandingRequests.remove(serial);\n      _this.newRequest_();\n    };\n    // If this request doesn't return on its own accord (by the server sending us some data), we'll\n    // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\n    var keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));\n    var readyStateCB = function readyStateCB() {\n      // Request completed.  Cancel the keepalive.\n      clearTimeout(keepaliveTimeout);\n      // Trigger a new request so we can continue receiving data.\n      doNewRequest();\n    };\n    this.addTag(url, readyStateCB);\n  };\n  /**\n   * Add an arbitrary script tag to the iframe.\n   * @param {!string} url - The URL for the script tag source.\n   * @param {!function()} loadCB - A callback to be triggered once the script has loaded.\n   */\n  FirebaseIFrameScriptHolder.prototype.addTag = function (url, loadCB) {\n    var _this = this;\n    if (util_3.isNodeSdk()) {\n      this.doNodeLongPoll(url, loadCB);\n    } else {\n      setTimeout(function () {\n        try {\n          // if we're already closed, don't add this poll\n          if (!_this.sendNewPolls) return;\n          var newScript_1 = _this.myIFrame.doc.createElement('script');\n          newScript_1.type = 'text/javascript';\n          newScript_1.async = true;\n          newScript_1.src = url;\n          newScript_1.onload = newScript_1.onreadystatechange = function () {\n            var rstate = newScript_1.readyState;\n            if (!rstate || rstate === 'loaded' || rstate === 'complete') {\n              newScript_1.onload = newScript_1.onreadystatechange = null;\n              if (newScript_1.parentNode) {\n                newScript_1.parentNode.removeChild(newScript_1);\n              }\n              loadCB();\n            }\n          };\n          newScript_1.onerror = function () {\n            util_1.log('Long-poll script failed to load: ' + url);\n            _this.sendNewPolls = false;\n            _this.close();\n          };\n          _this.myIFrame.doc.body.appendChild(newScript_1);\n        } catch (e) {\n          // TODO: we should make this error visible somehow\n        }\n      }, Math.floor(1));\n    }\n  };\n  return FirebaseIFrameScriptHolder;\n}();\nexports.FirebaseIFrameScriptHolder = FirebaseIFrameScriptHolder;","map":{"version":3,"mappings":"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","names":["exports","MAX_URL_DATA_SIZE","SEG_HEADER_SIZE","MAX_PAYLOAD_SIZE","KEEPALIVE_REQUEST_INTERVAL","LP_CONNECT_TIMEOUT","connId","repoInfo","transportSessionId","lastSessionId","log_","util_1","stats_","StatsManager_1","getCollection","urlFn","params","connectionURL","Constants_1","BrowserPollConnection","onMessage","onDisconnect","curSegmentNum","onDisconnect_","myPacketOrderer","PacketReceiver_1","isClosed_","connectTimeoutTimer_","setTimeout","_this","onClosed_","Math","floor","scriptTagHolder","FirebaseIFrameScriptHolder","_i","args","arg1","arg2","arg3","arg4","incrementIncomingBytes_","clearTimeout","everConnected_","command","id","password","sendNewPolls","closeAfter","Error","data","handleResponse","pN","urlParams","random","uniqueCallbackIdentifier","util_3","location","href","indexOf","connectURL","addTag","startLongPoll","addDisconnectPingFrame","forceAllow_","forceDisallow_","document","createElement","close","myDisconnFrame","body","removeChild","shutdown_","dataStr","util_2","bytesSent","length","incrementCounter","base64data","dataSegs","i","enqueueSegment","pw","src","style","display","appendChild","bytesReceived","commandCB","onMessageCB","CountedSet_1","window","myIFrame","createIFrame_","script","substr","currentDomain","domain","iframeContents","doc","open","write","e","stack","iframe","a","contentWindow","contentDocument","alive","innerHTML","myID","myPW","theURL","nodeRestRequest","newRequest_","outstandingRequests","count","pendingSegs","currentSerial","curDataString","nextSeg","d","theSeg","shift","seg","ts","addLongPollTag_","segnum","totalsegs","push","url","serial","add","doNewRequest","remove","keepaliveTimeout","readyStateCB","loadCB","doNodeLongPoll","newScript_1","type","async","onload","onreadystatechange","rstate","readyState","parentNode","onerror"],"sources":["../src/realtime/BrowserPollConnection.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  executeWhenDOMReady,\n  isChromeExtensionContentScript,\n  isWindowsStoreApp,\n  log,\n  logWrapper,\n  LUIDGenerator,\n  splitStringBySize\n} from '../core/util/util';\nimport { CountedSet } from '../core/util/CountedSet';\nimport { StatsManager } from '../core/stats/StatsManager';\nimport { PacketReceiver } from './polling/PacketReceiver';\nimport {\n  FORGE_DOMAIN,\n  FORGE_REF,\n  LAST_SESSION_PARAM,\n  LONG_POLLING,\n  PROTOCOL_VERSION,\n  REFERER_PARAM,\n  TRANSPORT_SESSION_PARAM,\n  VERSION_PARAM\n} from './Constants';\nimport { base64Encode, stringify } from '@firebase/util';\nimport { isNodeSdk } from '@firebase/util';\nimport { Transport } from './Transport';\nimport { RepoInfo } from '../core/RepoInfo';\nimport { StatsCollection } from '../core/stats/StatsCollection';\n\n// URL query parameters associated with longpolling\nexport const FIREBASE_LONGPOLL_START_PARAM = 'start';\nexport const FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';\nexport const FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';\nexport const FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';\nexport const FIREBASE_LONGPOLL_ID_PARAM = 'id';\nexport const FIREBASE_LONGPOLL_PW_PARAM = 'pw';\nexport const FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';\nexport const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';\nexport const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';\nexport const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';\nexport const FIREBASE_LONGPOLL_DATA_PARAM = 'd';\nexport const FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = 'disconn';\nexport const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';\n\n//Data size constants.\n//TODO: Perf: the maximum length actually differs from browser to browser.\n// We should check what browser we're on and set accordingly.\nconst MAX_URL_DATA_SIZE = 1870;\nconst SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\nconst MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\n\n/**\n * Keepalive period\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\n * length of 30 seconds that we can't exceed.\n * @const\n * @type {number}\n */\nconst KEEPALIVE_REQUEST_INTERVAL = 25000;\n\n/**\n * How long to wait before aborting a long-polling connection attempt.\n * @const\n * @type {number}\n */\nconst LP_CONNECT_TIMEOUT = 30000;\n\n/**\n * This class manages a single long-polling connection.\n *\n * @constructor\n * @implements {Transport}\n */\nexport class BrowserPollConnection implements Transport {\n  bytesSent = 0;\n  bytesReceived = 0;\n  urlFn: (params: object) => string;\n  scriptTagHolder: FirebaseIFrameScriptHolder;\n  myDisconnFrame: HTMLIFrameElement;\n  curSegmentNum: number;\n  myPacketOrderer: PacketReceiver;\n  id: string;\n  password: string;\n  private log_: (...a: any[]) => void;\n  private stats_: StatsCollection;\n  private everConnected_ = false;\n  private isClosed_: boolean;\n  private connectTimeoutTimer_: number | null;\n  private onDisconnect_: ((a?: boolean) => void) | null;\n\n  /**\n   * @param {string} connId An identifier for this connection, used for logging\n   * @param {RepoInfo} repoInfo The info for the endpoint to send data to.\n   * @param {string=} transportSessionId Optional transportSessionid if we are reconnecting for an existing\n   *                                         transport session\n   * @param {string=}  lastSessionId Optional lastSessionId if the PersistentConnection has already created a\n   *                                     connection previously\n   */\n  constructor(\n    public connId: string,\n    public repoInfo: RepoInfo,\n    public transportSessionId?: string,\n    public lastSessionId?: string\n  ) {\n    this.log_ = logWrapper(connId);\n    this.stats_ = StatsManager.getCollection(repoInfo);\n    this.urlFn = (params: { [k: string]: string }) =>\n      repoInfo.connectionURL(LONG_POLLING, params);\n  }\n\n  /**\n   *\n   * @param {function(Object)} onMessage Callback when messages arrive\n   * @param {function()} onDisconnect Callback with connection lost.\n   */\n  open(onMessage: (msg: Object) => void, onDisconnect: (a?: boolean) => void) {\n    this.curSegmentNum = 0;\n    this.onDisconnect_ = onDisconnect;\n    this.myPacketOrderer = new PacketReceiver(onMessage);\n    this.isClosed_ = false;\n\n    this.connectTimeoutTimer_ = setTimeout(() => {\n      this.log_('Timed out trying to connect.');\n      // Make sure we clear the host cache\n      this.onClosed_();\n      this.connectTimeoutTimer_ = null;\n    }, Math.floor(LP_CONNECT_TIMEOUT)) as any;\n\n    // Ensure we delay the creation of the iframe until the DOM is loaded.\n    executeWhenDOMReady(() => {\n      if (this.isClosed_) return;\n\n      //Set up a callback that gets triggered once a connection is set up.\n      this.scriptTagHolder = new FirebaseIFrameScriptHolder(\n        (...args) => {\n          const [command, arg1, arg2, arg3, arg4] = args;\n          this.incrementIncomingBytes_(args);\n          if (!this.scriptTagHolder) return; // we closed the connection.\n\n          if (this.connectTimeoutTimer_) {\n            clearTimeout(this.connectTimeoutTimer_);\n            this.connectTimeoutTimer_ = null;\n          }\n          this.everConnected_ = true;\n          if (command == FIREBASE_LONGPOLL_START_PARAM) {\n            this.id = arg1;\n            this.password = arg2;\n          } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\n            // Don't clear the host cache. We got a response from the server, so we know it's reachable\n            if (arg1) {\n              // We aren't expecting any more data (other than what the server's already in the process of sending us\n              // through our already open polls), so don't send any more.\n              this.scriptTagHolder.sendNewPolls = false;\n\n              // arg1 in this case is the last response number sent by the server. We should try to receive\n              // all of the responses up to this one before closing\n              this.myPacketOrderer.closeAfter(arg1, () => {\n                this.onClosed_();\n              });\n            } else {\n              this.onClosed_();\n            }\n          } else {\n            throw new Error('Unrecognized command received: ' + command);\n          }\n        },\n        (...args) => {\n          const [pN, data] = args;\n          this.incrementIncomingBytes_(args);\n          this.myPacketOrderer.handleResponse(pN, data);\n        },\n        () => {\n          this.onClosed_();\n        },\n        this.urlFn\n      );\n\n      //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\n      //from cache.\n      const urlParams: { [k: string]: string | number } = {};\n      urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';\n      urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(\n        Math.random() * 100000000\n      );\n      if (this.scriptTagHolder.uniqueCallbackIdentifier)\n        urlParams[\n          FIREBASE_LONGPOLL_CALLBACK_ID_PARAM\n        ] = this.scriptTagHolder.uniqueCallbackIdentifier;\n      urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n      if (this.transportSessionId) {\n        urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;\n      }\n      if (this.lastSessionId) {\n        urlParams[LAST_SESSION_PARAM] = this.lastSessionId;\n      }\n      if (\n        !isNodeSdk() &&\n        typeof location !== 'undefined' &&\n        location.href &&\n        location.href.indexOf(FORGE_DOMAIN) !== -1\n      ) {\n        urlParams[REFERER_PARAM] = FORGE_REF;\n      }\n      const connectURL = this.urlFn(urlParams);\n      this.log_('Connecting via long-poll to ' + connectURL);\n      this.scriptTagHolder.addTag(connectURL, () => {\n        /* do nothing */\n      });\n    });\n  }\n\n  /**\n   * Call this when a handshake has completed successfully and we want to consider the connection established\n   */\n  start() {\n    this.scriptTagHolder.startLongPoll(this.id, this.password);\n    this.addDisconnectPingFrame(this.id, this.password);\n  }\n\n  private static forceAllow_: boolean;\n\n  /**\n   * Forces long polling to be considered as a potential transport\n   */\n  static forceAllow() {\n    BrowserPollConnection.forceAllow_ = true;\n  }\n\n  private static forceDisallow_: boolean;\n\n  /**\n   * Forces longpolling to not be considered as a potential transport\n   */\n  static forceDisallow() {\n    BrowserPollConnection.forceDisallow_ = true;\n  }\n\n  // Static method, use string literal so it can be accessed in a generic way\n  static isAvailable() {\n    // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\n    // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\n    return (\n      BrowserPollConnection.forceAllow_ ||\n      (!BrowserPollConnection.forceDisallow_ &&\n        typeof document !== 'undefined' &&\n        document.createElement != null &&\n        !isChromeExtensionContentScript() &&\n        !isWindowsStoreApp() &&\n        !isNodeSdk())\n    );\n  }\n\n  /**\n   * No-op for polling\n   */\n  markConnectionHealthy() {}\n\n  /**\n   * Stops polling and cleans up the iframe\n   * @private\n   */\n  private shutdown_() {\n    this.isClosed_ = true;\n\n    if (this.scriptTagHolder) {\n      this.scriptTagHolder.close();\n      this.scriptTagHolder = null;\n    }\n\n    //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\n    if (this.myDisconnFrame) {\n      document.body.removeChild(this.myDisconnFrame);\n      this.myDisconnFrame = null;\n    }\n\n    if (this.connectTimeoutTimer_) {\n      clearTimeout(this.connectTimeoutTimer_);\n      this.connectTimeoutTimer_ = null;\n    }\n  }\n\n  /**\n   * Triggered when this transport is closed\n   * @private\n   */\n  private onClosed_() {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is closing itself');\n      this.shutdown_();\n\n      if (this.onDisconnect_) {\n        this.onDisconnect_(this.everConnected_);\n        this.onDisconnect_ = null;\n      }\n    }\n  }\n\n  /**\n   * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\n   * that we've left.\n   */\n  close() {\n    if (!this.isClosed_) {\n      this.log_('Longpoll is being closed.');\n      this.shutdown_();\n    }\n  }\n\n  /**\n   * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\n   * broken into chunks (since URLs have a small maximum length).\n   * @param {!Object} data The JSON data to transmit.\n   */\n  send(data: Object) {\n    const dataStr = stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length);\n\n    //first, lets get the base64-encoded data\n    const base64data = base64Encode(dataStr);\n\n    //We can only fit a certain amount in each URL, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n    const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\n\n    //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\n    //of segments so that we can reassemble the packet on the server.\n    for (let i = 0; i < dataSegs.length; i++) {\n      this.scriptTagHolder.enqueueSegment(\n        this.curSegmentNum,\n        dataSegs.length,\n        dataSegs[i]\n      );\n      this.curSegmentNum++;\n    }\n  }\n\n  /**\n   * This is how we notify the server that we're leaving.\n   * We aren't able to send requests with DHTML on a window close event, but we can\n   * trigger XHR requests in some browsers (everything but Opera basically).\n   * @param {!string} id\n   * @param {!string} pw\n   */\n  addDisconnectPingFrame(id: string, pw: string) {\n    if (isNodeSdk()) return;\n    this.myDisconnFrame = document.createElement('iframe');\n    const urlParams: { [k: string]: string } = {};\n    urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';\n    urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\n    urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\n    this.myDisconnFrame.src = this.urlFn(urlParams);\n    this.myDisconnFrame.style.display = 'none';\n\n    document.body.appendChild(this.myDisconnFrame);\n  }\n\n  /**\n   * Used to track the bytes received by this client\n   * @param {*} args\n   * @private\n   */\n  private incrementIncomingBytes_(args: any) {\n    // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\n    const bytesReceived = stringify(args).length;\n    this.bytesReceived += bytesReceived;\n    this.stats_.incrementCounter('bytes_received', bytesReceived);\n  }\n}\n\nexport interface IFrameElement extends HTMLIFrameElement {\n  doc: Document;\n}\n\n/*********************************************************************************************\n * A wrapper around an iframe that is used as a long-polling script holder.\n * @constructor\n *********************************************************************************************/\nexport class FirebaseIFrameScriptHolder {\n  //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\n  //problems in some browsers.\n  /**\n   * @type {CountedSet.<number, number>}\n   */\n  outstandingRequests = new CountedSet<number, number>();\n\n  //A queue of the pending segments waiting for transmission to the server.\n  pendingSegs: { seg: number; ts: number; d: any }[] = [];\n\n  //A serial number. We use this for two things:\n  // 1) A way to ensure the browser doesn't cache responses to polls\n  // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\n  //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\n  //    JSONP code in the order it was added to the iframe.\n  currentSerial = Math.floor(Math.random() * 100000000);\n\n  // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\n  // incoming data from the server that we're waiting for).\n  sendNewPolls = true;\n\n  uniqueCallbackIdentifier: number;\n  myIFrame: IFrameElement;\n  alive: boolean;\n  myID: string;\n  myPW: string;\n  commandCB: (command: string, ...args: any[]) => void;\n  onMessageCB: (...args: any[]) => void;\n\n  /**\n   * @param commandCB - The callback to be called when control commands are recevied from the server.\n   * @param onMessageCB - The callback to be triggered when responses arrive from the server.\n   * @param onDisconnect - The callback to be triggered when this tag holder is closed\n   * @param urlFn - A function that provides the URL of the endpoint to send data to.\n   */\n  constructor(\n    commandCB: (command: string, ...args: any[]) => void,\n    onMessageCB: (...args: any[]) => void,\n    public onDisconnect: () => void,\n    public urlFn: (a: object) => string\n  ) {\n    if (!isNodeSdk()) {\n      //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\n      //iframes where we put the long-polling script tags. We have two callbacks:\n      //   1) Command Callback - Triggered for control issues, like starting a connection.\n      //   2) Message Callback - Triggered when new data arrives.\n      this.uniqueCallbackIdentifier = LUIDGenerator();\n      (window as any)[\n        FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier\n      ] = commandCB;\n      (window as any)[\n        FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier\n      ] = onMessageCB;\n\n      //Create an iframe for us to add script tags to.\n      this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\n\n      // Set the iframe's contents.\n      let script = '';\n      // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\n      // for ie9, but ie8 needs to do it again in the document itself.\n      if (\n        this.myIFrame.src &&\n        this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:'\n      ) {\n        const currentDomain = document.domain;\n        script = '<script>document.domain=\"' + currentDomain + '\";</script>';\n      }\n      const iframeContents = '<html><body>' + script + '</body></html>';\n      try {\n        this.myIFrame.doc.open();\n        this.myIFrame.doc.write(iframeContents);\n        this.myIFrame.doc.close();\n      } catch (e) {\n        log('frame writing exception');\n        if (e.stack) {\n          log(e.stack);\n        }\n        log(e);\n      }\n    } else {\n      this.commandCB = commandCB;\n      this.onMessageCB = onMessageCB;\n    }\n  }\n\n  /**\n   * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\n   * actually use.\n   * @private\n   * @return {Element}\n   */\n  private static createIFrame_(): IFrameElement {\n    const iframe = document.createElement('iframe') as IFrameElement;\n    iframe.style.display = 'none';\n\n    // This is necessary in order to initialize the document inside the iframe\n    if (document.body) {\n      document.body.appendChild(iframe);\n      try {\n        // If document.domain has been modified in IE, this will throw an error, and we need to set the\n        // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\n        // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\n        const a = iframe.contentWindow.document;\n        if (!a) {\n          // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\n          log('No IE domain setting required');\n        }\n      } catch (e) {\n        const domain = document.domain;\n        iframe.src =\n          \"javascript:void((function(){document.open();document.domain='\" +\n          domain +\n          \"';document.close();})())\";\n      }\n    } else {\n      // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\n      // never gets hit.\n      throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';\n    }\n\n    // Get the document of the iframe in a browser-specific way.\n    if (iframe.contentDocument) {\n      (iframe as any).doc = iframe.contentDocument; // Firefox, Opera, Safari\n    } else if (iframe.contentWindow) {\n      (iframe as any).doc = iframe.contentWindow.document; // Internet Explorer\n    } else if ((iframe as any).document) {\n      (iframe as any).doc = (iframe as any).document; //others?\n    }\n\n    return iframe;\n  }\n\n  /**\n   * Cancel all outstanding queries and remove the frame.\n   */\n  close() {\n    //Mark this iframe as dead, so no new requests are sent.\n    this.alive = false;\n\n    if (this.myIFrame) {\n      //We have to actually remove all of the html inside this iframe before removing it from the\n      //window, or IE will continue loading and executing the script tags we've already added, which\n      //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.\n      this.myIFrame.doc.body.innerHTML = '';\n      setTimeout(() => {\n        if (this.myIFrame !== null) {\n          document.body.removeChild(this.myIFrame);\n          this.myIFrame = null;\n        }\n      }, Math.floor(0));\n    }\n\n    if (isNodeSdk() && this.myID) {\n      const urlParams: { [k: string]: string } = {};\n      urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM] = 't';\n      urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n      urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n      const theURL = this.urlFn(urlParams);\n      (FirebaseIFrameScriptHolder as any).nodeRestRequest(theURL);\n    }\n\n    // Protect from being called recursively.\n    const onDisconnect = this.onDisconnect;\n    if (onDisconnect) {\n      this.onDisconnect = null;\n      onDisconnect();\n    }\n  }\n\n  /**\n   * Actually start the long-polling session by adding the first script tag(s) to the iframe.\n   * @param {!string} id - The ID of this connection\n   * @param {!string} pw - The password for this connection\n   */\n  startLongPoll(id: string, pw: string) {\n    this.myID = id;\n    this.myPW = pw;\n    this.alive = true;\n\n    //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\n    while (this.newRequest_()) {}\n  }\n\n  /**\n   * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\n   * too many outstanding requests and we are still alive.\n   *\n   * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\n   * needed.\n   */\n  private newRequest_() {\n    // We keep one outstanding request open all the time to receive data, but if we need to send data\n    // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\n    // close the old request.\n    if (\n      this.alive &&\n      this.sendNewPolls &&\n      this.outstandingRequests.count() < (this.pendingSegs.length > 0 ? 2 : 1)\n    ) {\n      //construct our url\n      this.currentSerial++;\n      const urlParams: { [k: string]: string | number } = {};\n      urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n      urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n      urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\n      let theURL = this.urlFn(urlParams);\n      //Now add as much data as we can.\n      let curDataString = '';\n      let i = 0;\n\n      while (this.pendingSegs.length > 0) {\n        //first, lets see if the next segment will fit.\n        const nextSeg = this.pendingSegs[0];\n        if (\n          nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <=\n          MAX_URL_DATA_SIZE\n        ) {\n          //great, the segment will fit. Lets append it.\n          const theSeg = this.pendingSegs.shift();\n          curDataString =\n            curDataString +\n            '&' +\n            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +\n            i +\n            '=' +\n            theSeg.seg +\n            '&' +\n            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +\n            i +\n            '=' +\n            theSeg.ts +\n            '&' +\n            FIREBASE_LONGPOLL_DATA_PARAM +\n            i +\n            '=' +\n            theSeg.d;\n          i++;\n        } else {\n          break;\n        }\n      }\n\n      theURL = theURL + curDataString;\n      this.addLongPollTag_(theURL, this.currentSerial);\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Queue a packet for transmission to the server.\n   * @param segnum - A sequential id for this packet segment used for reassembly\n   * @param totalsegs - The total number of segments in this packet\n   * @param data - The data for this segment.\n   */\n  enqueueSegment(segnum: number, totalsegs: number, data: any) {\n    //add this to the queue of segments to send.\n    this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });\n\n    //send the data immediately if there isn't already data being transmitted, unless\n    //startLongPoll hasn't been called yet.\n    if (this.alive) {\n      this.newRequest_();\n    }\n  }\n\n  /**\n   * Add a script tag for a regular long-poll request.\n   * @param {!string} url - The URL of the script tag.\n   * @param {!number} serial - The serial number of the request.\n   * @private\n   */\n  private addLongPollTag_(url: string, serial: number) {\n    //remember that we sent this request.\n    this.outstandingRequests.add(serial, 1);\n\n    const doNewRequest = () => {\n      this.outstandingRequests.remove(serial);\n      this.newRequest_();\n    };\n\n    // If this request doesn't return on its own accord (by the server sending us some data), we'll\n    // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\n    const keepaliveTimeout = setTimeout(\n      doNewRequest,\n      Math.floor(KEEPALIVE_REQUEST_INTERVAL)\n    );\n\n    const readyStateCB = () => {\n      // Request completed.  Cancel the keepalive.\n      clearTimeout(keepaliveTimeout);\n\n      // Trigger a new request so we can continue receiving data.\n      doNewRequest();\n    };\n\n    this.addTag(url, readyStateCB);\n  }\n\n  /**\n   * Add an arbitrary script tag to the iframe.\n   * @param {!string} url - The URL for the script tag source.\n   * @param {!function()} loadCB - A callback to be triggered once the script has loaded.\n   */\n  addTag(url: string, loadCB: () => void) {\n    if (isNodeSdk()) {\n      (this as any).doNodeLongPoll(url, loadCB);\n    } else {\n      setTimeout(() => {\n        try {\n          // if we're already closed, don't add this poll\n          if (!this.sendNewPolls) return;\n          const newScript = this.myIFrame.doc.createElement('script');\n          newScript.type = 'text/javascript';\n          newScript.async = true;\n          newScript.src = url;\n          newScript.onload = (newScript as any).onreadystatechange = function() {\n            const rstate = (newScript as any).readyState;\n            if (!rstate || rstate === 'loaded' || rstate === 'complete') {\n              newScript.onload = (newScript as any).onreadystatechange = null;\n              if (newScript.parentNode) {\n                newScript.parentNode.removeChild(newScript);\n              }\n              loadCB();\n            }\n          };\n          newScript.onerror = () => {\n            log('Long-poll script failed to load: ' + url);\n            this.sendNewPolls = false;\n            this.close();\n          };\n          this.myIFrame.doc.body.appendChild(newScript);\n        } catch (e) {\n          // TODO: we should make this error visible somehow\n        }\n      }, Math.floor(1));\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}