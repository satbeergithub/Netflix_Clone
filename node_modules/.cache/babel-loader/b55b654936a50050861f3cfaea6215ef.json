{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as args from './implementation/args';\nimport { AuthWrapper } from './implementation/authwrapper';\nimport { Location } from './implementation/location';\nimport * as fbsPromiseImpl from './implementation/promise_external';\nimport * as RequestExports from './implementation/request';\nimport { Reference } from './reference';\n/**\n * A service that provides firebaseStorage.Reference instances.\n * @param opt_url gs:// url to a custom Storage Bucket\n *\n * @struct\n */\nvar Service = /** @class */function () {\n  function Service(app, pool, url) {\n    this.bucket_ = null;\n    function maker(authWrapper, loc) {\n      return new Reference(authWrapper, loc);\n    }\n    this.authWrapper_ = new AuthWrapper(app, maker, RequestExports.makeRequest, this, pool);\n    this.app_ = app;\n    if (url != null) {\n      this.bucket_ = Location.makeFromBucketSpec(url);\n    } else {\n      var authWrapperBucket = this.authWrapper_.bucket();\n      if (authWrapperBucket != null) {\n        this.bucket_ = new Location(authWrapperBucket, '');\n      }\n    }\n    this.internals_ = new ServiceInternals(this);\n  }\n  /**\n   * Returns a firebaseStorage.Reference for the given path in the default\n   * bucket.\n   */\n  Service.prototype.ref = function (path) {\n    function validator(path) {\n      if (/^[A-Za-z]+:\\/\\//.test(path)) {\n        throw 'Expected child path but got a URL, use refFromURL instead.';\n      }\n    }\n    args.validate('ref', [args.stringSpec(validator, true)], arguments);\n    if (this.bucket_ == null) {\n      throw new Error('No Storage Bucket defined in Firebase Options.');\n    }\n    var ref = new Reference(this.authWrapper_, this.bucket_);\n    if (path != null) {\n      return ref.child(path);\n    } else {\n      return ref;\n    }\n  };\n  /**\n   * Returns a firebaseStorage.Reference object for the given absolute URL,\n   * which must be a gs:// or http[s]:// URL.\n   */\n  Service.prototype.refFromURL = function (url) {\n    function validator(p) {\n      if (!/^[A-Za-z]+:\\/\\//.test(p)) {\n        throw 'Expected full URL but got a child path, use ref instead.';\n      }\n      try {\n        Location.makeFromUrl(p);\n      } catch (e) {\n        throw 'Expected valid full URL but got an invalid one.';\n      }\n    }\n    args.validate('refFromURL', [args.stringSpec(validator, false)], arguments);\n    return new Reference(this.authWrapper_, url);\n  };\n  Object.defineProperty(Service.prototype, \"maxUploadRetryTime\", {\n    get: function () {\n      return this.authWrapper_.maxUploadRetryTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Service.prototype.setMaxUploadRetryTime = function (time) {\n    args.validate('setMaxUploadRetryTime', [args.nonNegativeNumberSpec()], arguments);\n    this.authWrapper_.setMaxUploadRetryTime(time);\n  };\n  Object.defineProperty(Service.prototype, \"maxOperationRetryTime\", {\n    get: function () {\n      return this.authWrapper_.maxOperationRetryTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Service.prototype.setMaxOperationRetryTime = function (time) {\n    args.validate('setMaxOperationRetryTime', [args.nonNegativeNumberSpec()], arguments);\n    this.authWrapper_.setMaxOperationRetryTime(time);\n  };\n  Object.defineProperty(Service.prototype, \"app\", {\n    get: function () {\n      return this.app_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Service.prototype, \"INTERNAL\", {\n    get: function () {\n      return this.internals_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Service;\n}();\nexport { Service };\n/**\n * @struct\n */\nvar ServiceInternals = /** @class */function () {\n  function ServiceInternals(service) {\n    this.service_ = service;\n  }\n  /**\n   * Called when the associated app is deleted.\n   * @see {!fbs.AuthWrapper.prototype.deleteApp}\n   */\n  ServiceInternals.prototype.delete = function () {\n    this.service_.authWrapper_.deleteApp();\n    return fbsPromiseImpl.resolve(undefined);\n  };\n  return ServiceInternals;\n}();\nexport { ServiceInternals };","map":{"version":3,"mappings":"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","names":["args","AuthWrapper","Location","fbsPromiseImpl","RequestExports","Reference","app","pool","url","authWrapper","loc","authWrapper_","maker","makeRequest","app_","bucket_","makeFromBucketSpec","authWrapperBucket","bucket","internals_","ServiceInternals","Service","path","test","validate","stringSpec","validator","arguments","Error","ref","child","p","makeFromUrl","e","Object","maxUploadRetryTime","time","nonNegativeNumberSpec","setMaxUploadRetryTime","maxOperationRetryTime","setMaxOperationRetryTime","service","service_","deleteApp","resolve","undefined"],"sources":["../src/service.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app';\nimport * as args from './implementation/args';\nimport { AuthWrapper } from './implementation/authwrapper';\nimport { Location } from './implementation/location';\nimport * as fbsPromiseImpl from './implementation/promise_external';\nimport * as RequestExports from './implementation/request';\nimport { Request } from './implementation/request';\nimport { XhrIoPool } from './implementation/xhriopool';\nimport { Reference } from './reference';\n\n/**\n * A service that provides firebaseStorage.Reference instances.\n * @param opt_url gs:// url to a custom Storage Bucket\n *\n * @struct\n */\nexport class Service {\n  authWrapper_: AuthWrapper;\n  private app_: FirebaseApp;\n  private bucket_: Location | null = null;\n  private internals_: ServiceInternals;\n\n  constructor(app: FirebaseApp, pool: XhrIoPool, url?: string) {\n    function maker(authWrapper: AuthWrapper, loc: Location) {\n      return new Reference(authWrapper, loc);\n    }\n    this.authWrapper_ = new AuthWrapper(\n      app,\n      maker,\n      RequestExports.makeRequest,\n      this,\n      pool\n    );\n    this.app_ = app;\n    if (url != null) {\n      this.bucket_ = Location.makeFromBucketSpec(url);\n    } else {\n      const authWrapperBucket = this.authWrapper_.bucket();\n      if (authWrapperBucket != null) {\n        this.bucket_ = new Location(authWrapperBucket, '');\n      }\n    }\n    this.internals_ = new ServiceInternals(this);\n  }\n\n  /**\n   * Returns a firebaseStorage.Reference for the given path in the default\n   * bucket.\n   */\n  ref(path?: string): Reference {\n    function validator(path: string) {\n      if (/^[A-Za-z]+:\\/\\//.test(path)) {\n        throw 'Expected child path but got a URL, use refFromURL instead.';\n      }\n    }\n    args.validate('ref', [args.stringSpec(validator, true)], arguments);\n    if (this.bucket_ == null) {\n      throw new Error('No Storage Bucket defined in Firebase Options.');\n    }\n\n    let ref = new Reference(this.authWrapper_, this.bucket_);\n    if (path != null) {\n      return ref.child(path);\n    } else {\n      return ref;\n    }\n  }\n\n  /**\n   * Returns a firebaseStorage.Reference object for the given absolute URL,\n   * which must be a gs:// or http[s]:// URL.\n   */\n  refFromURL(url: string): Reference {\n    function validator(p: string) {\n      if (!/^[A-Za-z]+:\\/\\//.test(p)) {\n        throw 'Expected full URL but got a child path, use ref instead.';\n      }\n      try {\n        Location.makeFromUrl(p);\n      } catch (e) {\n        throw 'Expected valid full URL but got an invalid one.';\n      }\n    }\n    args.validate('refFromURL', [args.stringSpec(validator, false)], arguments);\n    return new Reference(this.authWrapper_, url);\n  }\n\n  get maxUploadRetryTime(): number {\n    return this.authWrapper_.maxUploadRetryTime();\n  }\n\n  setMaxUploadRetryTime(time: number) {\n    args.validate(\n      'setMaxUploadRetryTime',\n      [args.nonNegativeNumberSpec()],\n      arguments\n    );\n    this.authWrapper_.setMaxUploadRetryTime(time);\n  }\n\n  get maxOperationRetryTime(): number {\n    return this.authWrapper_.maxOperationRetryTime();\n  }\n\n  setMaxOperationRetryTime(time: number) {\n    args.validate(\n      'setMaxOperationRetryTime',\n      [args.nonNegativeNumberSpec()],\n      arguments\n    );\n    this.authWrapper_.setMaxOperationRetryTime(time);\n  }\n\n  get app(): FirebaseApp {\n    return this.app_;\n  }\n\n  get INTERNAL(): ServiceInternals {\n    return this.internals_;\n  }\n}\n\n/**\n * @struct\n */\nexport class ServiceInternals {\n  service_: Service;\n\n  constructor(service: Service) {\n    this.service_ = service;\n  }\n\n  /**\n   * Called when the associated app is deleted.\n   * @see {!fbs.AuthWrapper.prototype.deleteApp}\n   */\n  delete(): Promise<void> {\n    this.service_.authWrapper_.deleteApp();\n    return fbsPromiseImpl.resolve<void>(undefined);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}