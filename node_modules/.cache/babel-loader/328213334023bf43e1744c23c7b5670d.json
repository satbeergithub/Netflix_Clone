{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Defines methods used to actually send HTTP requests from\n * abstract representations.\n */\nimport firebase from '@firebase/app';\nimport * as array from './array';\nimport * as backoff from './backoff';\nimport * as errorsExports from './error';\nimport * as object from './object';\nimport * as promiseimpl from './promise_external';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport * as XhrIoExports from './xhrio';\n/**\n * @struct\n * @template T\n */\nvar NetworkRequest = /** @class */function () {\n  function NetworkRequest(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {\n    this.pendingXhr_ = null;\n    this.backoffId_ = null;\n    this.resolve_ = null;\n    this.reject_ = null;\n    this.canceled_ = false;\n    this.appDelete_ = false;\n    this.url_ = url;\n    this.method_ = method;\n    this.headers_ = headers;\n    this.body_ = body;\n    this.successCodes_ = successCodes.slice();\n    this.additionalRetryCodes_ = additionalRetryCodes.slice();\n    this.callback_ = callback;\n    this.errorCallback_ = errorCallback;\n    this.progressCallback_ = progressCallback;\n    this.timeout_ = timeout;\n    this.pool_ = pool;\n    var self = this;\n    this.promise_ = promiseimpl.make(function (resolve, reject) {\n      self.resolve_ = resolve;\n      self.reject_ = reject;\n      self.start_();\n    });\n  }\n  /**\n   * Actually starts the retry loop.\n   */\n  NetworkRequest.prototype.start_ = function () {\n    var self = this;\n    function doTheRequest(backoffCallback, canceled) {\n      if (canceled) {\n        backoffCallback(false, new RequestEndStatus(false, null, true));\n        return;\n      }\n      var xhr = self.pool_.createXhrIo();\n      self.pendingXhr_ = xhr;\n      function progressListener(progressEvent) {\n        var loaded = progressEvent.loaded;\n        var total = progressEvent.lengthComputable ? progressEvent.total : -1;\n        if (self.progressCallback_ !== null) {\n          self.progressCallback_(loaded, total);\n        }\n      }\n      if (self.progressCallback_ !== null) {\n        xhr.addUploadProgressListener(progressListener);\n      }\n      xhr.send(self.url_, self.method_, self.body_, self.headers_).then(function (xhr) {\n        if (self.progressCallback_ !== null) {\n          xhr.removeUploadProgressListener(progressListener);\n        }\n        self.pendingXhr_ = null;\n        xhr = xhr;\n        var hitServer = xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;\n        var status = xhr.getStatus();\n        if (!hitServer || self.isRetryStatusCode_(status)) {\n          var wasCanceled = xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;\n          backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));\n          return;\n        }\n        var successCode = array.contains(self.successCodes_, status);\n        backoffCallback(true, new RequestEndStatus(successCode, xhr));\n      });\n    }\n    /**\n     * @param requestWentThrough True if the request eventually went\n     *     through, false if it hit the retry limit or was canceled.\n     */\n    function backoffDone(requestWentThrough, status) {\n      var resolve = self.resolve_;\n      var reject = self.reject_;\n      var xhr = status.xhr;\n      if (status.wasSuccessCode) {\n        try {\n          var result = self.callback_(xhr, xhr.getResponseText());\n          if (type.isJustDef(result)) {\n            resolve(result);\n          } else {\n            resolve();\n          }\n        } catch (e) {\n          reject(e);\n        }\n      } else {\n        if (xhr !== null) {\n          var err = errorsExports.unknown();\n          err.setServerResponseProp(xhr.getResponseText());\n          if (self.errorCallback_) {\n            reject(self.errorCallback_(xhr, err));\n          } else {\n            reject(err);\n          }\n        } else {\n          if (status.canceled) {\n            var err = self.appDelete_ ? errorsExports.appDeleted() : errorsExports.canceled();\n            reject(err);\n          } else {\n            var err = errorsExports.retryLimitExceeded();\n            reject(err);\n          }\n        }\n      }\n    }\n    if (this.canceled_) {\n      backoffDone(false, new RequestEndStatus(false, null, true));\n    } else {\n      this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);\n    }\n  };\n  /** @inheritDoc */\n  NetworkRequest.prototype.getPromise = function () {\n    return this.promise_;\n  };\n  /** @inheritDoc */\n  NetworkRequest.prototype.cancel = function (appDelete) {\n    this.canceled_ = true;\n    this.appDelete_ = appDelete || false;\n    if (this.backoffId_ !== null) {\n      backoff.stop(this.backoffId_);\n    }\n    if (this.pendingXhr_ !== null) {\n      this.pendingXhr_.abort();\n    }\n  };\n  NetworkRequest.prototype.isRetryStatusCode_ = function (status) {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    var isFiveHundredCode = status >= 500 && status < 600;\n    var extraRetryCodes = [\n    // Request Timeout: web server didn't receive full request in time.\n    408,\n    // Too Many Requests: you're getting rate-limited, basically.\n    429];\n    var isExtraRetryCode = array.contains(extraRetryCodes, status);\n    var isRequestSpecificRetryCode = array.contains(this.additionalRetryCodes_, status);\n    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;\n  };\n  return NetworkRequest;\n}();\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled Defaults to false.\n * @struct\n */\nvar RequestEndStatus = /** @class */function () {\n  function RequestEndStatus(wasSuccessCode, xhr, opt_canceled) {\n    this.wasSuccessCode = wasSuccessCode;\n    this.xhr = xhr;\n    this.canceled = !!opt_canceled;\n  }\n  return RequestEndStatus;\n}();\nexport { RequestEndStatus };\nexport function addAuthHeader_(headers, authToken) {\n  if (authToken !== null && authToken.length > 0) {\n    headers['Authorization'] = 'Firebase ' + authToken;\n  }\n}\nexport function addVersionHeader_(headers) {\n  var number = typeof firebase !== 'undefined' ? firebase.SDK_VERSION : 'AppManager';\n  headers['X-Firebase-Storage-Version'] = 'webjs/' + number;\n}\n/**\n * @template T\n */\nexport function makeRequest(requestInfo, authToken, pool) {\n  var queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);\n  var url = requestInfo.url + queryPart;\n  var headers = object.clone(requestInfo.headers);\n  addAuthHeader_(headers, authToken);\n  addVersionHeader_(headers);\n  return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);\n}","map":{"version":3,"mappings":"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","names":["firebase","array","backoff","errorsExports","object","promiseimpl","type","UrlUtils","XhrIoExports","url","method","headers","body","successCodes","additionalRetryCodes","callback","errorCallback","timeout","progressCallback","pool","url_","method_","headers_","body_","successCodes_","slice","additionalRetryCodes_","callback_","errorCallback_","progressCallback_","timeout_","pool_","self","promise_","make","resolve","reject","resolve_","reject_","start_","NetworkRequest","backoffCallback","canceled","RequestEndStatus","xhr","createXhrIo","pendingXhr_","progressEvent","loaded","total","lengthComputable","addUploadProgressListener","progressListener","send","then","removeUploadProgressListener","hitServer","getErrorCode","ErrorCode","NO_ERROR","status","getStatus","isRetryStatusCode_","wasCanceled","ABORT","successCode","contains","requestWentThrough","wasSuccessCode","result","getResponseText","isJustDef","e","err","unknown","setServerResponseProp","appDelete_","appDeleted","retryLimitExceeded","canceled_","backoffDone","backoffId_","start","doTheRequest","appDelete","stop","abort","isFiveHundredCode","extraRetryCodes","isExtraRetryCode","isRequestSpecificRetryCode","opt_canceled","authToken","length","number","SDK_VERSION","requestInfo","queryPart","makeQueryString","urlParams","clone","addAuthHeader_","addVersionHeader_","handler","errorHandler"],"sources":["../src/implementation/request.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Defines methods used to actually send HTTP requests from\n * abstract representations.\n */\n\nimport firebase, { FirebaseNamespace } from '@firebase/app';\nimport * as array from './array';\nimport * as backoff from './backoff';\nimport * as errorsExports from './error';\nimport { FirebaseStorageError } from './error';\nimport { errors } from './error';\nimport * as object from './object';\nimport * as promiseimpl from './promise_external';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport * as XhrIoExports from './xhrio';\nimport { Headers, XhrIo } from './xhrio';\nimport { XhrIoPool } from './xhriopool';\n\n/**\n * @template T\n */\nexport interface Request<T> {\n  getPromise(): Promise<T>;\n\n  /**\n   * Cancels the request. IMPORTANT: the promise may still be resolved with an\n   * appropriate value (if the request is finished before you call this method,\n   * but the promise has not yet been resolved), so don't just assume it will be\n   * rejected if you call this function.\n   * @param appDelete True if the cancelation came from the app being deleted.\n   */\n  cancel(appDelete?: boolean): void;\n}\n\n/**\n * @struct\n * @template T\n */\nclass NetworkRequest<T> implements Request<T> {\n  private url_: string;\n  private method_: string;\n  private headers_: Headers;\n  private body_: string | Blob | Uint8Array | null;\n  private successCodes_: number[];\n  private additionalRetryCodes_: number[];\n  private pendingXhr_: XhrIo | null = null;\n  private backoffId_: backoff.id | null = null;\n  private resolve_: Function | null = null;\n  private reject_: Function | null = null;\n  private canceled_: boolean = false;\n  private appDelete_: boolean = false;\n  private callback_: (p1: XhrIo, p2: string) => T;\n  private errorCallback_:\n    | ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError)\n    | null;\n  private progressCallback_: ((p1: number, p2: number) => void) | null;\n  private timeout_: number;\n  private pool_: XhrIoPool;\n  promise_: Promise<T>;\n\n  constructor(\n    url: string,\n    method: string,\n    headers: Headers,\n    body: string | Blob | Uint8Array | null,\n    successCodes: number[],\n    additionalRetryCodes: number[],\n    callback: (p1: XhrIo, p2: string) => T,\n    errorCallback:\n      | ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError)\n      | null,\n    timeout: number,\n    progressCallback: ((p1: number, p2: number) => void) | null,\n    pool: XhrIoPool\n  ) {\n    this.url_ = url;\n    this.method_ = method;\n    this.headers_ = headers;\n    this.body_ = body;\n    this.successCodes_ = successCodes.slice();\n    this.additionalRetryCodes_ = additionalRetryCodes.slice();\n    this.callback_ = callback;\n    this.errorCallback_ = errorCallback;\n    this.progressCallback_ = progressCallback;\n    this.timeout_ = timeout;\n    this.pool_ = pool;\n    let self = this;\n    this.promise_ = promiseimpl.make(function(resolve, reject) {\n      self.resolve_ = resolve;\n      self.reject_ = reject;\n      self.start_();\n    });\n  }\n\n  /**\n   * Actually starts the retry loop.\n   */\n  private start_() {\n    let self = this;\n\n    function doTheRequest(\n      backoffCallback: (p1: boolean, ...p2: any[]) => void,\n      canceled: boolean\n    ) {\n      if (canceled) {\n        backoffCallback(false, new RequestEndStatus(false, null, true));\n        return;\n      }\n      let xhr = self.pool_.createXhrIo();\n      self.pendingXhr_ = xhr;\n\n      function progressListener(progressEvent: ProgressEvent) {\n        let loaded = progressEvent.loaded;\n        let total = progressEvent.lengthComputable ? progressEvent.total : -1;\n        if (self.progressCallback_ !== null) {\n          self.progressCallback_(loaded, total);\n        }\n      }\n      if (self.progressCallback_ !== null) {\n        xhr.addUploadProgressListener(progressListener);\n      }\n      xhr\n        .send(self.url_, self.method_, self.body_, self.headers_)\n        .then(function(xhr: XhrIo) {\n          if (self.progressCallback_ !== null) {\n            xhr.removeUploadProgressListener(progressListener);\n          }\n          self.pendingXhr_ = null;\n          xhr = xhr as XhrIo;\n          let hitServer =\n            xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;\n          let status = xhr.getStatus();\n          if (!hitServer || self.isRetryStatusCode_(status)) {\n            let wasCanceled =\n              xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;\n            backoffCallback(\n              false,\n              new RequestEndStatus(false, null, wasCanceled)\n            );\n            return;\n          }\n          let successCode = array.contains(self.successCodes_, status);\n          backoffCallback(true, new RequestEndStatus(successCode, xhr));\n        });\n    }\n\n    /**\n     * @param requestWentThrough True if the request eventually went\n     *     through, false if it hit the retry limit or was canceled.\n     */\n    function backoffDone(\n      requestWentThrough: boolean,\n      status: RequestEndStatus\n    ) {\n      let resolve = self.resolve_ as Function;\n      let reject = self.reject_ as Function;\n      let xhr = status.xhr as XhrIo;\n      if (status.wasSuccessCode) {\n        try {\n          let result = self.callback_(xhr, xhr.getResponseText());\n          if (type.isJustDef(result)) {\n            resolve(result);\n          } else {\n            resolve();\n          }\n        } catch (e) {\n          reject(e);\n        }\n      } else {\n        if (xhr !== null) {\n          let err = errorsExports.unknown();\n          err.setServerResponseProp(xhr.getResponseText());\n          if (self.errorCallback_) {\n            reject(self.errorCallback_(xhr, err));\n          } else {\n            reject(err);\n          }\n        } else {\n          if (status.canceled) {\n            let err = self.appDelete_\n              ? errorsExports.appDeleted()\n              : errorsExports.canceled();\n            reject(err);\n          } else {\n            let err = errorsExports.retryLimitExceeded();\n            reject(err);\n          }\n        }\n      }\n    }\n    if (this.canceled_) {\n      backoffDone(false, new RequestEndStatus(false, null, true));\n    } else {\n      this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);\n    }\n  }\n\n  /** @inheritDoc */\n  getPromise() {\n    return this.promise_;\n  }\n\n  /** @inheritDoc */\n  cancel(appDelete?: boolean) {\n    this.canceled_ = true;\n    this.appDelete_ = appDelete || false;\n    if (this.backoffId_ !== null) {\n      backoff.stop(this.backoffId_);\n    }\n    if (this.pendingXhr_ !== null) {\n      this.pendingXhr_.abort();\n    }\n  }\n\n  private isRetryStatusCode_(status: number): boolean {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    let isFiveHundredCode = status >= 500 && status < 600;\n    let extraRetryCodes = [\n      // Request Timeout: web server didn't receive full request in time.\n      408,\n      // Too Many Requests: you're getting rate-limited, basically.\n      429\n    ];\n    let isExtraRetryCode = array.contains(extraRetryCodes, status);\n    let isRequestSpecificRetryCode = array.contains(\n      this.additionalRetryCodes_,\n      status\n    );\n    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;\n  }\n}\n\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled Defaults to false.\n * @struct\n */\nexport class RequestEndStatus {\n  /**\n   * True if the request was canceled.\n   */\n  canceled: boolean;\n\n  constructor(\n    public wasSuccessCode: boolean,\n    public xhr: XhrIo | null,\n    opt_canceled?: boolean\n  ) {\n    this.canceled = !!opt_canceled;\n  }\n}\n\nexport function addAuthHeader_(headers: Headers, authToken: string | null) {\n  if (authToken !== null && authToken.length > 0) {\n    headers['Authorization'] = 'Firebase ' + authToken;\n  }\n}\n\nexport function addVersionHeader_(headers: Headers) {\n  let number =\n    typeof firebase !== 'undefined' ? firebase.SDK_VERSION : 'AppManager';\n  headers['X-Firebase-Storage-Version'] = 'webjs/' + number;\n}\n\n/**\n * @template T\n */\nexport function makeRequest<T>(\n  requestInfo: RequestInfo<T>,\n  authToken: string | null,\n  pool: XhrIoPool\n): Request<T> {\n  let queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);\n  let url = requestInfo.url + queryPart;\n  let headers = object.clone<Headers>(requestInfo.headers);\n  addAuthHeader_(headers, authToken);\n  addVersionHeader_(headers);\n  return new NetworkRequest<T>(\n    url,\n    requestInfo.method,\n    headers,\n    requestInfo.body,\n    requestInfo.successCodes,\n    requestInfo.additionalRetryCodes,\n    requestInfo.handler,\n    requestInfo.errorHandler,\n    requestInfo.timeout,\n    requestInfo.progressCallback,\n    pool\n  );\n}\n"]},"metadata":{},"sourceType":"module"}