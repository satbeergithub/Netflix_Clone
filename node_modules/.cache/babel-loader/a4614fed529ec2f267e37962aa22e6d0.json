{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar stringToByteArray = function (str) {\n  var output = [],\n    p = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    while (c > 255) {\n      output[p++] = c & 255;\n      c >>= 8;\n    }\n    output[p++] = c;\n  }\n  return output;\n};\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param {Array<number>} bytes Array of numbers representing characters.\n * @return {string} Stringification of the array.\n */\nvar byteArrayToString = function (bytes) {\n  var CHUNK_SIZE = 8192;\n  // Special-case the simple case for speed's sake.\n  if (bytes.length < CHUNK_SIZE) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n  // The remaining logic splits conversion by chunks since\n  // Function#apply() has a maximum parameter count.\n  // See discussion: http://goo.gl/LrWmZ9\n  var str = '';\n  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n    var chunk = bytes.slice(i, i + CHUNK_SIZE);\n    str += String.fromCharCode.apply(null, chunk);\n  }\n  return str;\n};\n// Static lookup maps, lazily populated by init_()\nexports.base64 = {\n  /**\n   * Maps bytes to characters.\n   * @type {Object}\n   * @private\n   */\n  byteToCharMap_: null,\n  /**\n   * Maps characters to bytes.\n   * @type {Object}\n   * @private\n   */\n  charToByteMap_: null,\n  /**\n   * Maps bytes to websafe characters.\n   * @type {Object}\n   * @private\n   */\n  byteToCharMapWebSafe_: null,\n  /**\n   * Maps websafe characters to bytes.\n   * @type {Object}\n   * @private\n   */\n  charToByteMapWebSafe_: null,\n  /**\n   * Our default alphabet, shared between\n   * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n   * @type {string}\n   */\n  ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n  /**\n   * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n   * @type {string}\n   */\n  get ENCODED_VALS() {\n    return this.ENCODED_VALS_BASE + '+/=';\n  },\n  /**\n   * Our websafe alphabet.\n   * @type {string}\n   */\n  get ENCODED_VALS_WEBSAFE() {\n    return this.ENCODED_VALS_BASE + '-_.';\n  },\n  /**\n   * Whether this browser supports the atob and btoa functions. This extension\n   * started at Mozilla but is now implemented by many browsers. We use the\n   * ASSUME_* variables to avoid pulling in the full useragent detection library\n   * but still allowing the standard per-browser compilations.\n   *\n   * @type {boolean}\n   */\n  HAS_NATIVE_SUPPORT: typeof atob === 'function',\n  /**\n   * Base64-encode an array of bytes.\n   *\n   * @param {Array<number>|Uint8Array} input An array of bytes (numbers with\n   *     value in [0, 255]) to encode.\n   * @param {boolean=} opt_webSafe Boolean indicating we should use the\n   *     alternative alphabet.\n   * @return {string} The base64 encoded string.\n   */\n  encodeByteArray: function (input, opt_webSafe) {\n    if (!Array.isArray(input)) {\n      throw Error('encodeByteArray takes an array as a parameter');\n    }\n    this.init_();\n    var byteToCharMap = opt_webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;\n    var output = [];\n    for (var i = 0; i < input.length; i += 3) {\n      var byte1 = input[i];\n      var haveByte2 = i + 1 < input.length;\n      var byte2 = haveByte2 ? input[i + 1] : 0;\n      var haveByte3 = i + 2 < input.length;\n      var byte3 = haveByte3 ? input[i + 2] : 0;\n      var outByte1 = byte1 >> 2;\n      var outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;\n      var outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;\n      var outByte4 = byte3 & 0x3f;\n      if (!haveByte3) {\n        outByte4 = 64;\n        if (!haveByte2) {\n          outByte3 = 64;\n        }\n      }\n      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n    }\n    return output.join('');\n  },\n  /**\n   * Base64-encode a string.\n   *\n   * @param {string} input A string to encode.\n   * @param {boolean=} opt_webSafe If true, we should use the\n   *     alternative alphabet.\n   * @return {string} The base64 encoded string.\n   */\n  encodeString: function (input, opt_webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {\n      return btoa(input);\n    }\n    return this.encodeByteArray(stringToByteArray(input), opt_webSafe);\n  },\n  /**\n   * Base64-decode a string.\n   *\n   * @param {string} input to decode.\n   * @param {boolean=} opt_webSafe True if we should use the\n   *     alternative alphabet.\n   * @return {string} string representing the decoded value.\n   */\n  decodeString: function (input, opt_webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {\n      return atob(input);\n    }\n    return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));\n  },\n  /**\n   * Base64-decode a string.\n   *\n   * In base-64 decoding, groups of four characters are converted into three\n   * bytes.  If the encoder did not apply padding, the input length may not\n   * be a multiple of 4.\n   *\n   * In this case, the last group will have fewer than 4 characters, and\n   * padding will be inferred.  If the group has one or two characters, it decodes\n   * to one byte.  If the group has three characters, it decodes to two bytes.\n   *\n   * @param {string} input Input to decode.\n   * @param {boolean=} opt_webSafe True if we should use the web-safe alphabet.\n   * @return {!Array<number>} bytes representing the decoded value.\n   */\n  decodeStringToByteArray: function (input, opt_webSafe) {\n    this.init_();\n    var charToByteMap = opt_webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;\n    var output = [];\n    for (var i = 0; i < input.length;) {\n      var byte1 = charToByteMap[input.charAt(i++)];\n      var haveByte2 = i < input.length;\n      var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n      ++i;\n      var haveByte3 = i < input.length;\n      var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n      var haveByte4 = i < input.length;\n      var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n        throw Error();\n      }\n      var outByte1 = byte1 << 2 | byte2 >> 4;\n      output.push(outByte1);\n      if (byte3 != 64) {\n        var outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;\n        output.push(outByte2);\n        if (byte4 != 64) {\n          var outByte3 = byte3 << 6 & 0xc0 | byte4;\n          output.push(outByte3);\n        }\n      }\n    }\n    return output;\n  },\n  /**\n   * Lazy static initialization function. Called before\n   * accessing any of the static map variables.\n   * @private\n   */\n  init_: function () {\n    if (!this.byteToCharMap_) {\n      this.byteToCharMap_ = {};\n      this.charToByteMap_ = {};\n      this.byteToCharMapWebSafe_ = {};\n      this.charToByteMapWebSafe_ = {};\n      // We want quick mappings back and forth, so we precompute two maps.\n      for (var i = 0; i < this.ENCODED_VALS.length; i++) {\n        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n        this.charToByteMap_[this.byteToCharMap_[i]] = i;\n        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n        // Be forgiving when decoding and correctly decode both encodings.\n        if (i >= this.ENCODED_VALS_BASE.length) {\n          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n        }\n      }\n    }\n  }\n};\n/**\n * URL-safe base64 encoding\n * @param {!string} str\n * @return {!string}\n */\nexports.base64Encode = function (str) {\n  var utf8Bytes = stringToByteArray(str);\n  return exports.base64.encodeByteArray(utf8Bytes, true);\n};\n/**\n * URL-safe base64 decoding\n *\n * NOTE: DO NOT use the global atob() function - it does NOT support the\n * base64Url variant encoding.\n *\n * @param {string} str To be decoded\n * @return {?string} Decoded result, if possible\n */\nexports.base64Decode = function (str) {\n  try {\n    return exports.base64.decodeString(str, true);\n  } catch (e) {\n    console.error('base64Decode failed: ', e);\n  }\n  return null;\n};","map":{"version":3,"mappings":"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","names":["stringToByteArray","str","output","p","i","length","c","charCodeAt","byteArrayToString","bytes","CHUNK_SIZE","String","fromCharCode","apply","chunk","slice","exports","byteToCharMap_","charToByteMap_","byteToCharMapWebSafe_","charToByteMapWebSafe_","ENCODED_VALS_BASE","ENCODED_VALS","ENCODED_VALS_WEBSAFE","HAS_NATIVE_SUPPORT","atob","encodeByteArray","input","opt_webSafe","Array","isArray","Error","init_","byteToCharMap","byte1","haveByte2","byte2","haveByte3","byte3","outByte1","outByte2","outByte3","outByte4","push","join","encodeString","btoa","decodeString","decodeStringToByteArray","charToByteMap","charAt","haveByte4","byte4","utf8Bytes","e","console","error"],"sources":["../src/crypt.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst stringToByteArray = function(str) {\n  var output = [],\n    p = 0;\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n    while (c > 255) {\n      output[p++] = c & 255;\n      c >>= 8;\n    }\n    output[p++] = c;\n  }\n  return output;\n};\n\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param {Array<number>} bytes Array of numbers representing characters.\n * @return {string} Stringification of the array.\n */\nconst byteArrayToString = function(bytes) {\n  var CHUNK_SIZE = 8192;\n\n  // Special-case the simple case for speed's sake.\n  if (bytes.length < CHUNK_SIZE) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n\n  // The remaining logic splits conversion by chunks since\n  // Function#apply() has a maximum parameter count.\n  // See discussion: http://goo.gl/LrWmZ9\n\n  var str = '';\n  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n    var chunk = bytes.slice(i, i + CHUNK_SIZE);\n    str += String.fromCharCode.apply(null, chunk);\n  }\n  return str;\n};\n\n// Static lookup maps, lazily populated by init_()\nexport const base64 = {\n  /**\n   * Maps bytes to characters.\n   * @type {Object}\n   * @private\n   */\n  byteToCharMap_: null,\n\n  /**\n   * Maps characters to bytes.\n   * @type {Object}\n   * @private\n   */\n  charToByteMap_: null,\n\n  /**\n   * Maps bytes to websafe characters.\n   * @type {Object}\n   * @private\n   */\n  byteToCharMapWebSafe_: null,\n\n  /**\n   * Maps websafe characters to bytes.\n   * @type {Object}\n   * @private\n   */\n  charToByteMapWebSafe_: null,\n\n  /**\n   * Our default alphabet, shared between\n   * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n   * @type {string}\n   */\n  ENCODED_VALS_BASE:\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n\n  /**\n   * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n   * @type {string}\n   */\n  get ENCODED_VALS() {\n    return this.ENCODED_VALS_BASE + '+/=';\n  },\n\n  /**\n   * Our websafe alphabet.\n   * @type {string}\n   */\n  get ENCODED_VALS_WEBSAFE() {\n    return this.ENCODED_VALS_BASE + '-_.';\n  },\n\n  /**\n   * Whether this browser supports the atob and btoa functions. This extension\n   * started at Mozilla but is now implemented by many browsers. We use the\n   * ASSUME_* variables to avoid pulling in the full useragent detection library\n   * but still allowing the standard per-browser compilations.\n   *\n   * @type {boolean}\n   */\n  HAS_NATIVE_SUPPORT: typeof atob === 'function',\n\n  /**\n   * Base64-encode an array of bytes.\n   *\n   * @param {Array<number>|Uint8Array} input An array of bytes (numbers with\n   *     value in [0, 255]) to encode.\n   * @param {boolean=} opt_webSafe Boolean indicating we should use the\n   *     alternative alphabet.\n   * @return {string} The base64 encoded string.\n   */\n  encodeByteArray(input, opt_webSafe?) {\n    if (!Array.isArray(input)) {\n      throw Error('encodeByteArray takes an array as a parameter');\n    }\n\n    this.init_();\n\n    var byteToCharMap = opt_webSafe\n      ? this.byteToCharMapWebSafe_\n      : this.byteToCharMap_;\n\n    var output = [];\n\n    for (var i = 0; i < input.length; i += 3) {\n      var byte1 = input[i];\n      var haveByte2 = i + 1 < input.length;\n      var byte2 = haveByte2 ? input[i + 1] : 0;\n      var haveByte3 = i + 2 < input.length;\n      var byte3 = haveByte3 ? input[i + 2] : 0;\n\n      var outByte1 = byte1 >> 2;\n      var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n      var outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n      var outByte4 = byte3 & 0x3f;\n\n      if (!haveByte3) {\n        outByte4 = 64;\n\n        if (!haveByte2) {\n          outByte3 = 64;\n        }\n      }\n\n      output.push(\n        byteToCharMap[outByte1],\n        byteToCharMap[outByte2],\n        byteToCharMap[outByte3],\n        byteToCharMap[outByte4]\n      );\n    }\n\n    return output.join('');\n  },\n\n  /**\n   * Base64-encode a string.\n   *\n   * @param {string} input A string to encode.\n   * @param {boolean=} opt_webSafe If true, we should use the\n   *     alternative alphabet.\n   * @return {string} The base64 encoded string.\n   */\n  encodeString(input, opt_webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {\n      return btoa(input);\n    }\n    return this.encodeByteArray(stringToByteArray(input), opt_webSafe);\n  },\n\n  /**\n   * Base64-decode a string.\n   *\n   * @param {string} input to decode.\n   * @param {boolean=} opt_webSafe True if we should use the\n   *     alternative alphabet.\n   * @return {string} string representing the decoded value.\n   */\n  decodeString(input, opt_webSafe) {\n    // Shortcut for Mozilla browsers that implement\n    // a native base64 encoder in the form of \"btoa/atob\"\n    if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {\n      return atob(input);\n    }\n    return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));\n  },\n\n  /**\n   * Base64-decode a string.\n   *\n   * In base-64 decoding, groups of four characters are converted into three\n   * bytes.  If the encoder did not apply padding, the input length may not\n   * be a multiple of 4.\n   *\n   * In this case, the last group will have fewer than 4 characters, and\n   * padding will be inferred.  If the group has one or two characters, it decodes\n   * to one byte.  If the group has three characters, it decodes to two bytes.\n   *\n   * @param {string} input Input to decode.\n   * @param {boolean=} opt_webSafe True if we should use the web-safe alphabet.\n   * @return {!Array<number>} bytes representing the decoded value.\n   */\n  decodeStringToByteArray(input, opt_webSafe) {\n    this.init_();\n\n    var charToByteMap = opt_webSafe\n      ? this.charToByteMapWebSafe_\n      : this.charToByteMap_;\n\n    var output = [];\n\n    for (var i = 0; i < input.length; ) {\n      var byte1 = charToByteMap[input.charAt(i++)];\n\n      var haveByte2 = i < input.length;\n      var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n      ++i;\n\n      var haveByte3 = i < input.length;\n      var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n\n      var haveByte4 = i < input.length;\n      var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n\n      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n        throw Error();\n      }\n\n      var outByte1 = (byte1 << 2) | (byte2 >> 4);\n      output.push(outByte1);\n\n      if (byte3 != 64) {\n        var outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\n        output.push(outByte2);\n\n        if (byte4 != 64) {\n          var outByte3 = ((byte3 << 6) & 0xc0) | byte4;\n          output.push(outByte3);\n        }\n      }\n    }\n\n    return output;\n  },\n\n  /**\n   * Lazy static initialization function. Called before\n   * accessing any of the static map variables.\n   * @private\n   */\n  init_() {\n    if (!this.byteToCharMap_) {\n      this.byteToCharMap_ = {};\n      this.charToByteMap_ = {};\n      this.byteToCharMapWebSafe_ = {};\n      this.charToByteMapWebSafe_ = {};\n\n      // We want quick mappings back and forth, so we precompute two maps.\n      for (var i = 0; i < this.ENCODED_VALS.length; i++) {\n        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n        this.charToByteMap_[this.byteToCharMap_[i]] = i;\n        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n\n        // Be forgiving when decoding and correctly decode both encodings.\n        if (i >= this.ENCODED_VALS_BASE.length) {\n          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n        }\n      }\n    }\n  }\n};\n\n/**\n * URL-safe base64 encoding\n * @param {!string} str\n * @return {!string}\n */\nexport const base64Encode = function(str: string): string {\n  const utf8Bytes = stringToByteArray(str);\n  return base64.encodeByteArray(utf8Bytes, true);\n};\n\n/**\n * URL-safe base64 decoding\n *\n * NOTE: DO NOT use the global atob() function - it does NOT support the\n * base64Url variant encoding.\n *\n * @param {string} str To be decoded\n * @return {?string} Decoded result, if possible\n */\nexport const base64Decode = function(str: string): string | null {\n  try {\n    return base64.decodeString(str, true);\n  } catch (e) {\n    console.error('base64Decode failed: ', e);\n  }\n  return null;\n};\n"]},"metadata":{},"sourceType":"script"}