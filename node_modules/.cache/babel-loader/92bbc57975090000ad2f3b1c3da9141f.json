{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Defines types for interacting with blob transfer tasks.\n */\nimport { InternalTaskState } from './implementation/taskenums';\nimport { Observer } from './implementation/observer';\nimport { TaskEvent, TaskState } from './implementation/taskenums';\nimport { UploadTaskSnapshot } from './tasksnapshot';\nimport * as fbsArgs from './implementation/args';\nimport * as fbsArray from './implementation/array';\nimport { async as fbsAsync } from './implementation/async';\nimport * as errors from './implementation/error';\nimport * as fbsPromiseimpl from './implementation/promise_external';\nimport * as fbsRequests from './implementation/requests';\nimport * as fbsTaskEnums from './implementation/taskenums';\nimport * as typeUtils from './implementation/type';\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n */\nvar UploadTask = /** @class */function () {\n  /**\n   * @param ref The firebaseStorage.Reference object this task came\n   *     from, untyped to avoid cyclic dependencies.\n   * @param blob The blob to upload.\n   */\n  function UploadTask(ref, authWrapper, location, mappings, blob, metadata) {\n    if (metadata === void 0) {\n      metadata = null;\n    }\n    var _this = this;\n    this.transferred_ = 0;\n    this.needToFetchStatus_ = false;\n    this.needToFetchMetadata_ = false;\n    this.observers_ = [];\n    this.error_ = null;\n    this.uploadUrl_ = null;\n    this.request_ = null;\n    this.chunkMultiplier_ = 1;\n    this.resolve_ = null;\n    this.reject_ = null;\n    this.ref_ = ref;\n    this.authWrapper_ = authWrapper;\n    this.location_ = location;\n    this.blob_ = blob;\n    this.metadata_ = metadata;\n    this.mappings_ = mappings;\n    this.resumable_ = this.shouldDoResumable_(this.blob_);\n    this.state_ = InternalTaskState.RUNNING;\n    this.errorHandler_ = function (error) {\n      _this.request_ = null;\n      _this.chunkMultiplier_ = 1;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        _this.needToFetchStatus_ = true;\n        _this.completeTransitions_();\n      } else {\n        _this.error_ = error;\n        _this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.metadataErrorHandler_ = function (error) {\n      _this.request_ = null;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        _this.completeTransitions_();\n      } else {\n        _this.error_ = error;\n        _this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.promise_ = fbsPromiseimpl.make(function (resolve, reject) {\n      _this.resolve_ = resolve;\n      _this.reject_ = reject;\n      _this.start_();\n    });\n    // Prevent uncaught rejections on the internal promise from bubbling out\n    // to the top level with a dummy handler.\n    this.promise_.then(null, function () {});\n  }\n  UploadTask.prototype.makeProgressCallback_ = function () {\n    var _this = this;\n    var sizeBefore = this.transferred_;\n    return function (loaded, total) {\n      _this.updateProgress_(sizeBefore + loaded);\n    };\n  };\n  UploadTask.prototype.shouldDoResumable_ = function (blob) {\n    return blob.size() > 256 * 1024;\n  };\n  UploadTask.prototype.start_ = function () {\n    if (this.state_ !== InternalTaskState.RUNNING) {\n      // This can happen if someone pauses us in a resume callback, for example.\n      return;\n    }\n    if (this.request_ !== null) {\n      return;\n    }\n    if (this.resumable_) {\n      if (this.uploadUrl_ === null) {\n        this.createResumable_();\n      } else {\n        if (this.needToFetchStatus_) {\n          this.fetchStatus_();\n        } else {\n          if (this.needToFetchMetadata_) {\n            // Happens if we miss the metadata on upload completion.\n            this.fetchMetadata_();\n          } else {\n            this.continueUpload_();\n          }\n        }\n      }\n    } else {\n      this.oneShotUpload_();\n    }\n  };\n  UploadTask.prototype.resolveToken_ = function (callback) {\n    var _this = this;\n    this.authWrapper_.getAuthToken().then(function (authToken) {\n      switch (_this.state_) {\n        case InternalTaskState.RUNNING:\n          callback(authToken);\n          break;\n        case InternalTaskState.CANCELING:\n          _this.transition_(InternalTaskState.CANCELED);\n          break;\n        case InternalTaskState.PAUSING:\n          _this.transition_(InternalTaskState.PAUSED);\n          break;\n        default:\n      }\n    });\n  };\n  // TODO(andysoto): assert false\n  UploadTask.prototype.createResumable_ = function () {\n    var _this = this;\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.createResumableUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);\n      var createRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n      _this.request_ = createRequest;\n      createRequest.getPromise().then(function (url) {\n        _this.request_ = null;\n        _this.uploadUrl_ = url;\n        _this.needToFetchStatus_ = false;\n        _this.completeTransitions_();\n      }, _this.errorHandler_);\n    });\n  };\n  UploadTask.prototype.fetchStatus_ = function () {\n    var _this = this;\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    var url = this.uploadUrl_;\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.getResumableUploadStatus(_this.authWrapper_, _this.location_, url, _this.blob_);\n      var statusRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n      _this.request_ = statusRequest;\n      statusRequest.getPromise().then(function (status) {\n        status = status;\n        _this.request_ = null;\n        _this.updateProgress_(status.current);\n        _this.needToFetchStatus_ = false;\n        if (status.finalized) {\n          _this.needToFetchMetadata_ = true;\n        }\n        _this.completeTransitions_();\n      }, _this.errorHandler_);\n    });\n  };\n  UploadTask.prototype.continueUpload_ = function () {\n    var _this = this;\n    var chunkSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n    var status = new fbsRequests.ResumableUploadStatus(this.transferred_, this.blob_.size());\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    var url = this.uploadUrl_;\n    this.resolveToken_(function (authToken) {\n      var requestInfo;\n      try {\n        requestInfo = fbsRequests.continueResumableUpload(_this.location_, _this.authWrapper_, url, _this.blob_, chunkSize, _this.mappings_, status, _this.makeProgressCallback_());\n      } catch (e) {\n        _this.error_ = e;\n        _this.transition_(InternalTaskState.ERROR);\n        return;\n      }\n      var uploadRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n      _this.request_ = uploadRequest;\n      uploadRequest.getPromise().then(function (newStatus) {\n        _this.increaseMultiplier_();\n        _this.request_ = null;\n        _this.updateProgress_(newStatus.current);\n        if (newStatus.finalized) {\n          _this.metadata_ = newStatus.metadata;\n          _this.transition_(InternalTaskState.SUCCESS);\n        } else {\n          _this.completeTransitions_();\n        }\n      }, _this.errorHandler_);\n    });\n  };\n  UploadTask.prototype.increaseMultiplier_ = function () {\n    var currentSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n    // Max chunk size is 32M.\n    if (currentSize < 32 * 1024 * 1024) {\n      this.chunkMultiplier_ *= 2;\n    }\n  };\n  UploadTask.prototype.fetchMetadata_ = function () {\n    var _this = this;\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.getMetadata(_this.authWrapper_, _this.location_, _this.mappings_);\n      var metadataRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n      _this.request_ = metadataRequest;\n      metadataRequest.getPromise().then(function (metadata) {\n        _this.request_ = null;\n        _this.metadata_ = metadata;\n        _this.transition_(InternalTaskState.SUCCESS);\n      }, _this.metadataErrorHandler_);\n    });\n  };\n  UploadTask.prototype.oneShotUpload_ = function () {\n    var _this = this;\n    this.resolveToken_(function (authToken) {\n      var requestInfo = fbsRequests.multipartUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);\n      var multipartRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n      _this.request_ = multipartRequest;\n      multipartRequest.getPromise().then(function (metadata) {\n        _this.request_ = null;\n        _this.metadata_ = metadata;\n        _this.updateProgress_(_this.blob_.size());\n        _this.transition_(InternalTaskState.SUCCESS);\n      }, _this.errorHandler_);\n    });\n  };\n  UploadTask.prototype.updateProgress_ = function (transferred) {\n    var old = this.transferred_;\n    this.transferred_ = transferred;\n    // A progress update can make the \"transferred\" value smaller (e.g. a\n    // partial upload not completed by server, after which the \"transferred\"\n    // value may reset to the value at the beginning of the request).\n    if (this.transferred_ !== old) {\n      this.notifyObservers_();\n    }\n  };\n  UploadTask.prototype.transition_ = function (state) {\n    if (this.state_ === state) {\n      return;\n    }\n    switch (state) {\n      case InternalTaskState.CANCELING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.PAUSING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.RUNNING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        var wasPaused = this.state_ === InternalTaskState.PAUSED;\n        this.state_ = state;\n        if (wasPaused) {\n          this.notifyObservers_();\n          this.start_();\n        }\n        break;\n      case InternalTaskState.PAUSED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.CANCELED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.error_ = errors.canceled();\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.ERROR:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.SUCCESS:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n    }\n  };\n  UploadTask.prototype.completeTransitions_ = function () {\n    switch (this.state_) {\n      case InternalTaskState.PAUSING:\n        this.transition_(InternalTaskState.PAUSED);\n        break;\n      case InternalTaskState.CANCELING:\n        this.transition_(InternalTaskState.CANCELED);\n        break;\n      case InternalTaskState.RUNNING:\n        this.start_();\n        break;\n      default:\n        // TODO(andysoto): assert(false);\n        break;\n    }\n  };\n  Object.defineProperty(UploadTask.prototype, \"snapshot\", {\n    get: function () {\n      var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n      return new UploadTaskSnapshot(this.transferred_, this.blob_.size(), externalState, this.metadata_, this, this.ref_);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Adds a callback for an event.\n   * @param type The type of event to listen for.\n   */\n  UploadTask.prototype.on = function (type, nextOrObserver, error, completed) {\n    if (nextOrObserver === void 0) {\n      nextOrObserver = undefined;\n    }\n    if (error === void 0) {\n      error = undefined;\n    }\n    if (completed === void 0) {\n      completed = undefined;\n    }\n    function typeValidator(_p) {\n      if (type !== TaskEvent.STATE_CHANGED) {\n        throw \"Expected one of the event types: [\" + TaskEvent.STATE_CHANGED + \"].\";\n      }\n    }\n    var nextOrObserverMessage = 'Expected a function or an Object with one of ' + '`next`, `error`, `complete` properties.';\n    var nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n    var observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n    function nextOrObserverValidator(p) {\n      try {\n        nextValidator(p);\n        return;\n      } catch (e) {}\n      try {\n        observerValidator(p);\n        var anyDefined = typeUtils.isJustDef(p['next']) || typeUtils.isJustDef(p['error']) || typeUtils.isJustDef(p['complete']);\n        if (!anyDefined) {\n          throw '';\n        }\n        return;\n      } catch (e) {\n        throw nextOrObserverMessage;\n      }\n    }\n    var specs = [fbsArgs.stringSpec(typeValidator), fbsArgs.looseObjectSpec(nextOrObserverValidator, true), fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)];\n    fbsArgs.validate('on', specs, arguments);\n    var self = this;\n    function makeBinder(specs) {\n      function binder(nextOrObserver, error, opt_complete) {\n        if (specs !== null) {\n          fbsArgs.validate('on', specs, arguments);\n        }\n        var observer = new Observer(nextOrObserver, error, completed);\n        self.addObserver_(observer);\n        return function () {\n          self.removeObserver_(observer);\n        };\n      }\n      return binder;\n    }\n    function binderNextOrObserverValidator(p) {\n      if (p === null) {\n        throw nextOrObserverMessage;\n      }\n      nextOrObserverValidator(p);\n    }\n    var binderSpecs = [fbsArgs.looseObjectSpec(binderNextOrObserverValidator), fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)];\n    var typeOnly = !(typeUtils.isJustDef(nextOrObserver) || typeUtils.isJustDef(error) || typeUtils.isJustDef(completed));\n    if (typeOnly) {\n      return makeBinder(binderSpecs);\n    } else {\n      return makeBinder(null)(nextOrObserver, error, completed);\n    }\n  };\n  /**\n   * This object behaves like a Promise, and resolves with its snapshot data\n   * when the upload completes.\n   * @param onFulfilled The fulfillment callback. Promise chaining works as normal.\n   * @param onRejected The rejection callback.\n   */\n  UploadTask.prototype.then = function (onFulfilled, onRejected) {\n    // These casts are needed so that TypeScript can infer the types of the\n    // resulting Promise.\n    return this.promise_.then(onFulfilled, onRejected);\n  };\n  /**\n   * Equivalent to calling `then(null, onRejected)`.\n   */\n  UploadTask.prototype.catch = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n  /**\n   * Adds the given observer.\n   */\n  UploadTask.prototype.addObserver_ = function (observer) {\n    this.observers_.push(observer);\n    this.notifyObserver_(observer);\n  };\n  /**\n   * Removes the given observer.\n   */\n  UploadTask.prototype.removeObserver_ = function (observer) {\n    fbsArray.remove(this.observers_, observer);\n  };\n  UploadTask.prototype.notifyObservers_ = function () {\n    var _this = this;\n    this.finishPromise_();\n    var observers = fbsArray.clone(this.observers_);\n    observers.forEach(function (observer) {\n      _this.notifyObserver_(observer);\n    });\n  };\n  UploadTask.prototype.finishPromise_ = function () {\n    if (this.resolve_ !== null) {\n      var triggered = true;\n      switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n        case TaskState.SUCCESS:\n          fbsAsync(this.resolve_.bind(null, this.snapshot))();\n          break;\n        case TaskState.CANCELED:\n        case TaskState.ERROR:\n          var toCall = this.reject_;\n          fbsAsync(toCall.bind(null, this.error_))();\n          break;\n        default:\n          triggered = false;\n          break;\n      }\n      if (triggered) {\n        this.resolve_ = null;\n        this.reject_ = null;\n      }\n    }\n  };\n  UploadTask.prototype.notifyObserver_ = function (observer) {\n    var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n    switch (externalState) {\n      case TaskState.RUNNING:\n      case TaskState.PAUSED:\n        if (observer.next !== null) {\n          fbsAsync(observer.next.bind(observer, this.snapshot))();\n        }\n        break;\n      case TaskState.SUCCESS:\n        if (observer.complete !== null) {\n          fbsAsync(observer.complete.bind(observer))();\n        }\n        break;\n      case TaskState.CANCELED:\n      case TaskState.ERROR:\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_))();\n        }\n        break;\n      default:\n        // TODO(andysoto): assert(false);\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_))();\n        }\n    }\n  };\n  /**\n   * Resumes a paused task. Has no effect on a currently running or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  UploadTask.prototype.resume = function () {\n    fbsArgs.validate('resume', [], arguments);\n    var valid = this.state_ === InternalTaskState.PAUSED || this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.RUNNING);\n    }\n    return valid;\n  };\n  /**\n   * Pauses a currently running task. Has no effect on a paused or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  UploadTask.prototype.pause = function () {\n    fbsArgs.validate('pause', [], arguments);\n    var valid = this.state_ === InternalTaskState.RUNNING;\n    if (valid) {\n      this.transition_(InternalTaskState.PAUSING);\n    }\n    return valid;\n  };\n  /**\n   * Cancels a currently running or paused task. Has no effect on a complete or\n   * failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  UploadTask.prototype.cancel = function () {\n    fbsArgs.validate('cancel', [], arguments);\n    var valid = this.state_ === InternalTaskState.RUNNING || this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.CANCELING);\n    }\n    return valid;\n  };\n  return UploadTask;\n}();\nexport { UploadTask };","map":{"version":3,"mappings":"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","names":["InternalTaskState","Observer","TaskEvent","TaskState","UploadTaskSnapshot","fbsArgs","fbsArray","async","fbsAsync","errors","fbsPromiseimpl","fbsRequests","fbsTaskEnums","typeUtils","ref","authWrapper","location","mappings","blob","metadata","ref_","authWrapper_","location_","blob_","metadata_","mappings_","resumable_","shouldDoResumable_","state_","RUNNING","errorHandler_","_this","request_","chunkMultiplier_","error","codeEquals","Code","CANCELED","needToFetchStatus_","completeTransitions_","error_","transition_","ERROR","metadataErrorHandler_","promise_","make","resolve","reject","resolve_","reject_","start_","then","UploadTask","sizeBefore","transferred_","loaded","total","updateProgress_","size","uploadUrl_","createResumable_","fetchStatus_","needToFetchMetadata_","fetchMetadata_","continueUpload_","oneShotUpload_","callback","getAuthToken","authToken","CANCELING","PAUSING","PAUSED","resolveToken_","requestInfo","createResumableUpload","createRequest","makeRequest","getPromise","url","getResumableUploadStatus","statusRequest","status","current","finalized","chunkSize","resumableUploadChunkSize","ResumableUploadStatus","continueResumableUpload","makeProgressCallback_","e","uploadRequest","newStatus","increaseMultiplier_","SUCCESS","currentSize","getMetadata","metadataRequest","multipartUpload","multipartRequest","transferred","old","notifyObservers_","state","cancel","wasPaused","canceled","Object","externalState","taskStateFromInternalTaskState","type","nextOrObserver","completed","_p","STATE_CHANGED","nextOrObserverMessage","nextValidator","nullFunctionSpec","validator","observerValidator","looseObjectSpec","p","anyDefined","isJustDef","specs","stringSpec","typeValidator","nextOrObserverValidator","validate","arguments","self","opt_complete","observer","addObserver_","removeObserver_","binder","binderSpecs","binderNextOrObserverValidator","typeOnly","makeBinder","onFulfilled","onRejected","observers_","push","notifyObserver_","remove","finishPromise_","observers","clone","forEach","triggered","bind","snapshot","toCall","next","complete","valid"],"sources":["../src/task.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Defines types for interacting with blob transfer tasks.\n */\n\nimport { AuthWrapper } from './implementation/authwrapper';\nimport { FbsBlob } from './implementation/blob';\nimport { FirebaseStorageError } from './implementation/error';\nimport { InternalTaskState } from './implementation/taskenums';\nimport { Metadata } from './metadata';\nimport {\n  NextFn,\n  ErrorFn,\n  CompleteFn,\n  Unsubscribe,\n  Observer\n} from './implementation/observer';\nimport { Request } from './implementation/request';\nimport * as RequestExports from './implementation/request';\nimport { Subscribe } from './implementation/observer';\nimport { TaskEvent, TaskState } from './implementation/taskenums';\nimport { UploadTaskSnapshot } from './tasksnapshot';\nimport * as fbsArgs from './implementation/args';\nimport { ArgSpec } from './implementation/args';\nimport * as fbsArray from './implementation/array';\nimport { async as fbsAsync } from './implementation/async';\nimport { errors as fbsErrors } from './implementation/error';\nimport * as errors from './implementation/error';\nimport { Location } from './implementation/location';\nimport * as fbsMetadata from './implementation/metadata';\nimport * as fbsPromiseimpl from './implementation/promise_external';\nimport { RequestInfo } from './implementation/requestinfo';\nimport * as fbsRequests from './implementation/requests';\nimport * as fbsTaskEnums from './implementation/taskenums';\nimport * as typeUtils from './implementation/type';\nimport { Reference } from './reference';\n\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n */\nexport class UploadTask {\n  private ref_: Reference;\n  private authWrapper_: AuthWrapper;\n  private location_: Location;\n  private blob_: FbsBlob;\n  private metadata_: Metadata | null;\n  private mappings_: fbsMetadata.Mappings;\n  private transferred_: number = 0;\n  private needToFetchStatus_: boolean = false;\n  private needToFetchMetadata_: boolean = false;\n  private observers_: Observer<UploadTaskSnapshot>[] = [];\n  private resumable_: boolean;\n  private state_: InternalTaskState;\n  private error_: Error | null = null;\n  private uploadUrl_: string | null = null;\n  private request_: Request<any> | null = null;\n  private chunkMultiplier_: number = 1;\n  private errorHandler_: (p1: FirebaseStorageError) => void;\n  private metadataErrorHandler_: (p1: FirebaseStorageError) => void;\n  private resolve_: ((p1: UploadTaskSnapshot) => void) | null = null;\n  private reject_: ((p1: Error) => void) | null = null;\n  private promise_: Promise<UploadTaskSnapshot>;\n\n  /**\n   * @param ref The firebaseStorage.Reference object this task came\n   *     from, untyped to avoid cyclic dependencies.\n   * @param blob The blob to upload.\n   */\n  constructor(\n    ref: Reference,\n    authWrapper: AuthWrapper,\n    location: Location,\n    mappings: fbsMetadata.Mappings,\n    blob: FbsBlob,\n    metadata: Metadata | null = null\n  ) {\n    this.ref_ = ref;\n    this.authWrapper_ = authWrapper;\n    this.location_ = location;\n    this.blob_ = blob;\n    this.metadata_ = metadata;\n    this.mappings_ = mappings;\n    this.resumable_ = this.shouldDoResumable_(this.blob_);\n    this.state_ = InternalTaskState.RUNNING;\n    this.errorHandler_ = error => {\n      this.request_ = null;\n      this.chunkMultiplier_ = 1;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.needToFetchStatus_ = true;\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.metadataErrorHandler_ = error => {\n      this.request_ = null;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.promise_ = fbsPromiseimpl.make((resolve, reject) => {\n      this.resolve_ = resolve;\n      this.reject_ = reject;\n      this.start_();\n    });\n\n    // Prevent uncaught rejections on the internal promise from bubbling out\n    // to the top level with a dummy handler.\n    this.promise_.then(null, () => {});\n  }\n\n  private makeProgressCallback_(): (p1: number, p2: number) => void {\n    const sizeBefore = this.transferred_;\n    return (loaded, total) => {\n      this.updateProgress_(sizeBefore + loaded);\n    };\n  }\n\n  private shouldDoResumable_(blob: FbsBlob): boolean {\n    return blob.size() > 256 * 1024;\n  }\n\n  private start_() {\n    if (this.state_ !== InternalTaskState.RUNNING) {\n      // This can happen if someone pauses us in a resume callback, for example.\n      return;\n    }\n    if (this.request_ !== null) {\n      return;\n    }\n    if (this.resumable_) {\n      if (this.uploadUrl_ === null) {\n        this.createResumable_();\n      } else {\n        if (this.needToFetchStatus_) {\n          this.fetchStatus_();\n        } else {\n          if (this.needToFetchMetadata_) {\n            // Happens if we miss the metadata on upload completion.\n            this.fetchMetadata_();\n          } else {\n            this.continueUpload_();\n          }\n        }\n      }\n    } else {\n      this.oneShotUpload_();\n    }\n  }\n\n  private resolveToken_(callback: (p1: string | null) => void) {\n    this.authWrapper_.getAuthToken().then(authToken => {\n      switch (this.state_) {\n        case InternalTaskState.RUNNING:\n          callback(authToken);\n          break;\n        case InternalTaskState.CANCELING:\n          this.transition_(InternalTaskState.CANCELED);\n          break;\n        case InternalTaskState.PAUSING:\n          this.transition_(InternalTaskState.PAUSED);\n          break;\n        default:\n      }\n    });\n  }\n\n  // TODO(andysoto): assert false\n\n  private createResumable_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.createResumableUpload(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_,\n        this.blob_,\n        this.metadata_\n      );\n      const createRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = createRequest;\n      createRequest.getPromise().then((url: string) => {\n        this.request_ = null;\n        this.uploadUrl_ = url;\n        this.needToFetchStatus_ = false;\n        this.completeTransitions_();\n      }, this.errorHandler_);\n    });\n  }\n\n  private fetchStatus_() {\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = this.uploadUrl_ as string;\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.getResumableUploadStatus(\n        this.authWrapper_,\n        this.location_,\n        url,\n        this.blob_\n      );\n      const statusRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = statusRequest;\n      statusRequest.getPromise().then(status => {\n        status = status as fbsRequests.ResumableUploadStatus;\n        this.request_ = null;\n        this.updateProgress_(status.current);\n        this.needToFetchStatus_ = false;\n        if (status.finalized) {\n          this.needToFetchMetadata_ = true;\n        }\n        this.completeTransitions_();\n      }, this.errorHandler_);\n    });\n  }\n\n  private continueUpload_() {\n    const chunkSize =\n      fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n    const status = new fbsRequests.ResumableUploadStatus(\n      this.transferred_,\n      this.blob_.size()\n    );\n\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = this.uploadUrl_ as string;\n    this.resolveToken_(authToken => {\n      let requestInfo;\n      try {\n        requestInfo = fbsRequests.continueResumableUpload(\n          this.location_,\n          this.authWrapper_,\n          url,\n          this.blob_,\n          chunkSize,\n          this.mappings_,\n          status,\n          this.makeProgressCallback_()\n        );\n      } catch (e) {\n        this.error_ = e;\n        this.transition_(InternalTaskState.ERROR);\n        return;\n      }\n      const uploadRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = uploadRequest;\n      uploadRequest\n        .getPromise()\n        .then((newStatus: fbsRequests.ResumableUploadStatus) => {\n          this.increaseMultiplier_();\n          this.request_ = null;\n          this.updateProgress_(newStatus.current);\n          if (newStatus.finalized) {\n            this.metadata_ = newStatus.metadata;\n            this.transition_(InternalTaskState.SUCCESS);\n          } else {\n            this.completeTransitions_();\n          }\n        }, this.errorHandler_);\n    });\n  }\n\n  private increaseMultiplier_() {\n    const currentSize =\n      fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n\n    // Max chunk size is 32M.\n    if (currentSize < 32 * 1024 * 1024) {\n      this.chunkMultiplier_ *= 2;\n    }\n  }\n\n  private fetchMetadata_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.getMetadata(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_\n      );\n      const metadataRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = metadataRequest;\n      metadataRequest.getPromise().then(metadata => {\n        this.request_ = null;\n        this.metadata_ = metadata;\n        this.transition_(InternalTaskState.SUCCESS);\n      }, this.metadataErrorHandler_);\n    });\n  }\n\n  private oneShotUpload_() {\n    this.resolveToken_(authToken => {\n      const requestInfo = fbsRequests.multipartUpload(\n        this.authWrapper_,\n        this.location_,\n        this.mappings_,\n        this.blob_,\n        this.metadata_\n      );\n      const multipartRequest = this.authWrapper_.makeRequest(\n        requestInfo,\n        authToken\n      );\n      this.request_ = multipartRequest;\n      multipartRequest.getPromise().then(metadata => {\n        this.request_ = null;\n        this.metadata_ = metadata;\n        this.updateProgress_(this.blob_.size());\n        this.transition_(InternalTaskState.SUCCESS);\n      }, this.errorHandler_);\n    });\n  }\n\n  private updateProgress_(transferred: number) {\n    const old = this.transferred_;\n    this.transferred_ = transferred;\n\n    // A progress update can make the \"transferred\" value smaller (e.g. a\n    // partial upload not completed by server, after which the \"transferred\"\n    // value may reset to the value at the beginning of the request).\n    if (this.transferred_ !== old) {\n      this.notifyObservers_();\n    }\n  }\n\n  private transition_(state: InternalTaskState) {\n    if (this.state_ === state) {\n      return;\n    }\n    switch (state) {\n      case InternalTaskState.CANCELING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.PAUSING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.RUNNING:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        const wasPaused = this.state_ === InternalTaskState.PAUSED;\n        this.state_ = state;\n        if (wasPaused) {\n          this.notifyObservers_();\n          this.start_();\n        }\n        break;\n      case InternalTaskState.PAUSED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.CANCELED:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.error_ = errors.canceled();\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.ERROR:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.SUCCESS:\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n    }\n  }\n\n  private completeTransitions_() {\n    switch (this.state_) {\n      case InternalTaskState.PAUSING:\n        this.transition_(InternalTaskState.PAUSED);\n        break;\n      case InternalTaskState.CANCELING:\n        this.transition_(InternalTaskState.CANCELED);\n        break;\n      case InternalTaskState.RUNNING:\n        this.start_();\n        break;\n      default:\n        // TODO(andysoto): assert(false);\n        break;\n    }\n  }\n\n  get snapshot(): UploadTaskSnapshot {\n    const externalState = fbsTaskEnums.taskStateFromInternalTaskState(\n      this.state_\n    );\n    return new UploadTaskSnapshot(\n      this.transferred_,\n      this.blob_.size(),\n      externalState,\n      this.metadata_,\n      this,\n      this.ref_\n    );\n  }\n\n  /**\n   * Adds a callback for an event.\n   * @param type The type of event to listen for.\n   */\n  on(\n    type: TaskEvent,\n    nextOrObserver = undefined,\n    error = undefined,\n    completed = undefined\n  ): Unsubscribe | Subscribe<UploadTaskSnapshot> {\n    function typeValidator(_p: any) {\n      if (type !== TaskEvent.STATE_CHANGED) {\n        throw `Expected one of the event types: [${TaskEvent.STATE_CHANGED}].`;\n      }\n    }\n    const nextOrObserverMessage =\n      'Expected a function or an Object with one of ' +\n      '`next`, `error`, `complete` properties.';\n    const nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n    const observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n\n    function nextOrObserverValidator(p: any) {\n      try {\n        nextValidator(p);\n        return;\n      } catch (e) {}\n      try {\n        observerValidator(p);\n        const anyDefined =\n          typeUtils.isJustDef(p['next']) ||\n          typeUtils.isJustDef(p['error']) ||\n          typeUtils.isJustDef(p['complete']);\n        if (!anyDefined) {\n          throw '';\n        }\n        return;\n      } catch (e) {\n        throw nextOrObserverMessage;\n      }\n    }\n    const specs = [\n      fbsArgs.stringSpec(typeValidator),\n      fbsArgs.looseObjectSpec(nextOrObserverValidator, true),\n      fbsArgs.nullFunctionSpec(true),\n      fbsArgs.nullFunctionSpec(true)\n    ];\n    fbsArgs.validate('on', specs, arguments);\n    const self = this;\n\n    function makeBinder(\n      specs: ArgSpec[] | null\n    ): Subscribe<UploadTaskSnapshot> {\n      function binder(\n        nextOrObserver:\n          | NextFn<UploadTaskSnapshot>\n          | { [name: string]: string | null }\n          | null,\n        error?: ErrorFn | null,\n        opt_complete?: CompleteFn | null\n      ) {\n        if (specs !== null) {\n          fbsArgs.validate('on', specs, arguments);\n        }\n        const observer = new Observer(nextOrObserver, error, completed);\n        self.addObserver_(observer);\n        return () => {\n          self.removeObserver_(observer);\n        };\n      }\n      return binder;\n    }\n\n    function binderNextOrObserverValidator(p: any) {\n      if (p === null) {\n        throw nextOrObserverMessage;\n      }\n      nextOrObserverValidator(p);\n    }\n    const binderSpecs = [\n      fbsArgs.looseObjectSpec(binderNextOrObserverValidator),\n      fbsArgs.nullFunctionSpec(true),\n      fbsArgs.nullFunctionSpec(true)\n    ];\n    const typeOnly = !(\n      typeUtils.isJustDef(nextOrObserver) ||\n      typeUtils.isJustDef(error) ||\n      typeUtils.isJustDef(completed)\n    );\n    if (typeOnly) {\n      return makeBinder(binderSpecs);\n    } else {\n      return makeBinder(null)(nextOrObserver, error, completed);\n    }\n  }\n\n  /**\n   * This object behaves like a Promise, and resolves with its snapshot data\n   * when the upload completes.\n   * @param onFulfilled The fulfillment callback. Promise chaining works as normal.\n   * @param onRejected The rejection callback.\n   */\n  then<U>(\n    onFulfilled?: ((value: UploadTaskSnapshot) => U | Promise<U>) | null,\n    onRejected?: ((error: any) => U | Promise<U>) | null\n  ): Promise<U> {\n    // These casts are needed so that TypeScript can infer the types of the\n    // resulting Promise.\n    return this.promise_.then<U>(\n      onFulfilled as (value: UploadTaskSnapshot) => U | Promise<U>,\n      onRejected as ((error: any) => Promise<never>) | null\n    );\n  }\n\n  /**\n   * Equivalent to calling `then(null, onRejected)`.\n   */\n  catch<T>(onRejected: (p1: Error) => T | Promise<T>): Promise<T> {\n    return this.then(null, onRejected);\n  }\n\n  /**\n   * Adds the given observer.\n   */\n  private addObserver_(observer: Observer<UploadTaskSnapshot>) {\n    this.observers_.push(observer);\n    this.notifyObserver_(observer);\n  }\n\n  /**\n   * Removes the given observer.\n   */\n  private removeObserver_(observer: Observer<UploadTaskSnapshot>) {\n    fbsArray.remove(this.observers_, observer);\n  }\n\n  private notifyObservers_() {\n    this.finishPromise_();\n    const observers = fbsArray.clone(this.observers_);\n    observers.forEach(observer => {\n      this.notifyObserver_(observer);\n    });\n  }\n\n  private finishPromise_() {\n    if (this.resolve_ !== null) {\n      let triggered = true;\n      switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n        case TaskState.SUCCESS:\n          fbsAsync(this.resolve_.bind(null, this.snapshot))();\n          break;\n        case TaskState.CANCELED:\n        case TaskState.ERROR:\n          const toCall = this.reject_ as ((p1: Error) => void);\n          fbsAsync(toCall.bind(null, this.error_ as Error))();\n          break;\n        default:\n          triggered = false;\n          break;\n      }\n      if (triggered) {\n        this.resolve_ = null;\n        this.reject_ = null;\n      }\n    }\n  }\n\n  private notifyObserver_(observer: Observer<UploadTaskSnapshot>) {\n    const externalState = fbsTaskEnums.taskStateFromInternalTaskState(\n      this.state_\n    );\n    switch (externalState) {\n      case TaskState.RUNNING:\n      case TaskState.PAUSED:\n        if (observer.next !== null) {\n          fbsAsync(observer.next.bind(observer, this.snapshot))();\n        }\n        break;\n      case TaskState.SUCCESS:\n        if (observer.complete !== null) {\n          fbsAsync(observer.complete.bind(observer))();\n        }\n        break;\n      case TaskState.CANCELED:\n      case TaskState.ERROR:\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_ as Error))();\n        }\n        break;\n      default:\n        // TODO(andysoto): assert(false);\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, this.error_ as Error))();\n        }\n    }\n  }\n\n  /**\n   * Resumes a paused task. Has no effect on a currently running or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  resume(): boolean {\n    fbsArgs.validate('resume', [], arguments);\n    const valid =\n      this.state_ === InternalTaskState.PAUSED ||\n      this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.RUNNING);\n    }\n    return valid;\n  }\n\n  /**\n   * Pauses a currently running task. Has no effect on a paused or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  pause(): boolean {\n    fbsArgs.validate('pause', [], arguments);\n    const valid = this.state_ === InternalTaskState.RUNNING;\n    if (valid) {\n      this.transition_(InternalTaskState.PAUSING);\n    }\n    return valid;\n  }\n\n  /**\n   * Cancels a currently running or paused task. Has no effect on a complete or\n   * failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  cancel(): boolean {\n    fbsArgs.validate('cancel', [], arguments);\n    const valid =\n      this.state_ === InternalTaskState.RUNNING ||\n      this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.CANCELING);\n    }\n    return valid;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}