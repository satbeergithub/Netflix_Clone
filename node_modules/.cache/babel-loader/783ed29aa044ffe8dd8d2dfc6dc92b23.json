{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar onDisconnect_1 = require(\"./onDisconnect\");\nvar TransactionResult_1 = require(\"./TransactionResult\");\nvar util_1 = require(\"../core/util/util\");\nvar NextPushId_1 = require(\"../core/util/NextPushId\");\nvar Query_1 = require(\"./Query\");\nvar Repo_1 = require(\"../core/Repo\");\nvar Path_1 = require(\"../core/util/Path\");\nvar QueryParams_1 = require(\"../core/view/QueryParams\");\nvar validation_1 = require(\"../core/util/validation\");\nvar util_2 = require(\"@firebase/util\");\nvar util_3 = require(\"@firebase/util\");\nvar SyncPoint_1 = require(\"../core/SyncPoint\");\nvar Reference = /** @class */function (_super) {\n  __extends(Reference, _super);\n  /**\n   * Call options:\n   *   new Reference(Repo, Path) or\n   *   new Reference(url: string, string|RepoManager)\n   *\n   * Externally - this is the firebase.database.Reference type.\n   *\n   * @param {!Repo} repo\n   * @param {(!Path)} path\n   * @extends {Query}\n   */\n  function Reference(repo, path) {\n    var _this = this;\n    if (!(repo instanceof Repo_1.Repo)) {\n      throw new Error('new Reference() no longer supported - use app.database().');\n    }\n    // call Query's constructor, passing in the repo and path.\n    _this = _super.call(this, repo, path, QueryParams_1.QueryParams.DEFAULT, false) || this;\n    return _this;\n  }\n  /** @return {?string} */\n  Reference.prototype.getKey = function () {\n    util_2.validateArgCount('Reference.key', 0, 0, arguments.length);\n    if (this.path.isEmpty()) return null;else return this.path.getBack();\n  };\n  /**\n   * @param {!(string|Path)} pathString\n   * @return {!Reference}\n   */\n  Reference.prototype.child = function (pathString) {\n    util_2.validateArgCount('Reference.child', 1, 1, arguments.length);\n    if (typeof pathString === 'number') {\n      pathString = String(pathString);\n    } else if (!(pathString instanceof Path_1.Path)) {\n      if (this.path.getFront() === null) validation_1.validateRootPathString('Reference.child', 1, pathString, false);else validation_1.validatePathString('Reference.child', 1, pathString, false);\n    }\n    return new Reference(this.repo, this.path.child(pathString));\n  };\n  /** @return {?Reference} */\n  Reference.prototype.getParent = function () {\n    util_2.validateArgCount('Reference.parent', 0, 0, arguments.length);\n    var parentPath = this.path.parent();\n    return parentPath === null ? null : new Reference(this.repo, parentPath);\n  };\n  /** @return {!Reference} */\n  Reference.prototype.getRoot = function () {\n    util_2.validateArgCount('Reference.root', 0, 0, arguments.length);\n    var ref = this;\n    while (ref.getParent() !== null) {\n      ref = ref.getParent();\n    }\n    return ref;\n  };\n  /** @return {!Database} */\n  Reference.prototype.databaseProp = function () {\n    return this.repo.database;\n  };\n  /**\n   * @param {*} newVal\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  Reference.prototype.set = function (newVal, onComplete) {\n    util_2.validateArgCount('Reference.set', 1, 2, arguments.length);\n    validation_1.validateWritablePath('Reference.set', this.path);\n    validation_1.validateFirebaseDataArg('Reference.set', 1, newVal, this.path, false);\n    util_2.validateCallback('Reference.set', 2, onComplete, true);\n    var deferred = new util_3.Deferred();\n    this.repo.setWithPriority(this.path, newVal, /*priority=*/null, deferred.wrapCallback(onComplete));\n    return deferred.promise;\n  };\n  /**\n   * @param {!Object} objectToMerge\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  Reference.prototype.update = function (objectToMerge, onComplete) {\n    util_2.validateArgCount('Reference.update', 1, 2, arguments.length);\n    validation_1.validateWritablePath('Reference.update', this.path);\n    if (Array.isArray(objectToMerge)) {\n      var newObjectToMerge = {};\n      for (var i = 0; i < objectToMerge.length; ++i) {\n        newObjectToMerge['' + i] = objectToMerge[i];\n      }\n      objectToMerge = newObjectToMerge;\n      util_1.warn('Passing an Array to Firebase.update() is deprecated. ' + 'Use set() if you want to overwrite the existing data, or ' + 'an Object with integer keys if you really do want to ' + 'only update some of the children.');\n    }\n    validation_1.validateFirebaseMergeDataArg('Reference.update', 1, objectToMerge, this.path, false);\n    util_2.validateCallback('Reference.update', 2, onComplete, true);\n    var deferred = new util_3.Deferred();\n    this.repo.update(this.path, objectToMerge, deferred.wrapCallback(onComplete));\n    return deferred.promise;\n  };\n  /**\n   * @param {*} newVal\n   * @param {string|number|null} newPriority\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  Reference.prototype.setWithPriority = function (newVal, newPriority, onComplete) {\n    util_2.validateArgCount('Reference.setWithPriority', 2, 3, arguments.length);\n    validation_1.validateWritablePath('Reference.setWithPriority', this.path);\n    validation_1.validateFirebaseDataArg('Reference.setWithPriority', 1, newVal, this.path, false);\n    validation_1.validatePriority('Reference.setWithPriority', 2, newPriority, false);\n    util_2.validateCallback('Reference.setWithPriority', 3, onComplete, true);\n    if (this.getKey() === '.length' || this.getKey() === '.keys') throw 'Reference.setWithPriority failed: ' + this.getKey() + ' is a read-only object.';\n    var deferred = new util_3.Deferred();\n    this.repo.setWithPriority(this.path, newVal, newPriority, deferred.wrapCallback(onComplete));\n    return deferred.promise;\n  };\n  /**\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  Reference.prototype.remove = function (onComplete) {\n    util_2.validateArgCount('Reference.remove', 0, 1, arguments.length);\n    validation_1.validateWritablePath('Reference.remove', this.path);\n    util_2.validateCallback('Reference.remove', 1, onComplete, true);\n    return this.set(null, onComplete);\n  };\n  /**\n   * @param {function(*):*} transactionUpdate\n   * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete\n   * @param {boolean=} applyLocally\n   * @return {!Promise}\n   */\n  Reference.prototype.transaction = function (transactionUpdate, onComplete, applyLocally) {\n    util_2.validateArgCount('Reference.transaction', 1, 3, arguments.length);\n    validation_1.validateWritablePath('Reference.transaction', this.path);\n    util_2.validateCallback('Reference.transaction', 1, transactionUpdate, false);\n    util_2.validateCallback('Reference.transaction', 2, onComplete, true);\n    // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how\n    // to expose it.\n    validation_1.validateBoolean('Reference.transaction', 3, applyLocally, true);\n    if (this.getKey() === '.length' || this.getKey() === '.keys') throw 'Reference.transaction failed: ' + this.getKey() + ' is a read-only object.';\n    if (applyLocally === undefined) applyLocally = true;\n    var deferred = new util_3.Deferred();\n    if (typeof onComplete === 'function') {\n      deferred.promise.catch(function () {});\n    }\n    var promiseComplete = function (error, committed, snapshot) {\n      if (error) {\n        deferred.reject(error);\n      } else {\n        deferred.resolve(new TransactionResult_1.TransactionResult(committed, snapshot));\n      }\n      if (typeof onComplete === 'function') {\n        onComplete(error, committed, snapshot);\n      }\n    };\n    this.repo.startTransaction(this.path, transactionUpdate, promiseComplete, applyLocally);\n    return deferred.promise;\n  };\n  /**\n   * @param {string|number|null} priority\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  Reference.prototype.setPriority = function (priority, onComplete) {\n    util_2.validateArgCount('Reference.setPriority', 1, 2, arguments.length);\n    validation_1.validateWritablePath('Reference.setPriority', this.path);\n    validation_1.validatePriority('Reference.setPriority', 1, priority, false);\n    util_2.validateCallback('Reference.setPriority', 2, onComplete, true);\n    var deferred = new util_3.Deferred();\n    this.repo.setWithPriority(this.path.child('.priority'), priority, null, deferred.wrapCallback(onComplete));\n    return deferred.promise;\n  };\n  /**\n   * @param {*=} value\n   * @param {function(?Error)=} onComplete\n   * @return {!Reference}\n   */\n  Reference.prototype.push = function (value, onComplete) {\n    util_2.validateArgCount('Reference.push', 0, 2, arguments.length);\n    validation_1.validateWritablePath('Reference.push', this.path);\n    validation_1.validateFirebaseDataArg('Reference.push', 1, value, this.path, true);\n    util_2.validateCallback('Reference.push', 2, onComplete, true);\n    var now = this.repo.serverTime();\n    var name = NextPushId_1.nextPushId(now);\n    // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.\n    // We use child() to create handles to two different references. The first is turned into a\n    // ThennableReference below by adding then() and catch() methods and is used as the\n    // return value of push(). The second remains a regular Reference and is used as the fulfilled\n    // value of the first ThennableReference.\n    var thennablePushRef = this.child(name);\n    var pushRef = this.child(name);\n    var promise;\n    if (value != null) {\n      promise = thennablePushRef.set(value, onComplete).then(function () {\n        return pushRef;\n      });\n    } else {\n      promise = Promise.resolve(pushRef);\n    }\n    thennablePushRef.then = promise.then.bind(promise);\n    thennablePushRef.catch = promise.then.bind(promise, undefined);\n    if (typeof onComplete === 'function') {\n      promise.catch(function () {});\n    }\n    return thennablePushRef;\n  };\n  /**\n   * @return {!OnDisconnect}\n   */\n  Reference.prototype.onDisconnect = function () {\n    validation_1.validateWritablePath('Reference.onDisconnect', this.path);\n    return new onDisconnect_1.OnDisconnect(this.repo, this.path);\n  };\n  Object.defineProperty(Reference.prototype, \"database\", {\n    get: function () {\n      return this.databaseProp();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reference.prototype, \"key\", {\n    get: function () {\n      return this.getKey();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reference.prototype, \"parent\", {\n    get: function () {\n      return this.getParent();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Reference.prototype, \"root\", {\n    get: function () {\n      return this.getRoot();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Reference;\n}(Query_1.Query);\nexports.Reference = Reference;\n/**\n * Define reference constructor in various modules\n *\n * We are doing this here to avoid several circular\n * dependency issues\n */\nQuery_1.Query.__referenceConstructor = Reference;\nSyncPoint_1.SyncPoint.__referenceConstructor = Reference;","map":{"version":3,"mappings":"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","names":["__extends","repo","path","Repo_1","Error","_this","QueryParams_1","DEFAULT","Reference","util_2","arguments","length","isEmpty","getBack","pathString","String","Path_1","getFront","validation_1","child","parentPath","parent","ref","getParent","database","newVal","onComplete","deferred","util_3","setWithPriority","wrapCallback","promise","objectToMerge","Array","isArray","newObjectToMerge","i","util_1","update","newPriority","getKey","set","transactionUpdate","applyLocally","undefined","catch","promiseComplete","error","committed","snapshot","reject","resolve","TransactionResult_1","startTransaction","priority","value","now","serverTime","name","NextPushId_1","thennablePushRef","pushRef","then","Promise","bind","onDisconnect_1","Object","databaseProp","getRoot","Query_1","exports","__referenceConstructor","SyncPoint_1"],"sources":["../src/api/Reference.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OnDisconnect } from './onDisconnect';\nimport { TransactionResult } from './TransactionResult';\nimport { warn } from '../core/util/util';\nimport { nextPushId } from '../core/util/NextPushId';\nimport { Query } from './Query';\nimport { Repo } from '../core/Repo';\nimport { Path } from '../core/util/Path';\nimport { QueryParams } from '../core/view/QueryParams';\nimport {\n  validateRootPathString,\n  validatePathString,\n  validateFirebaseMergeDataArg,\n  validateBoolean,\n  validatePriority,\n  validateFirebaseDataArg,\n  validateWritablePath\n} from '../core/util/validation';\nimport { validateArgCount, validateCallback } from '@firebase/util';\nimport { Deferred } from '@firebase/util';\nimport { SyncPoint } from '../core/SyncPoint';\nimport { Database } from './Database';\nimport { DataSnapshot } from './DataSnapshot';\n\nexport interface ReferenceConstructor {\n  new (repo: Repo, path: Path): Reference;\n}\n\nexport class Reference extends Query {\n  public then: (a?: any) => Promise<any>;\n  public catch: (a?: Error) => Promise<any>;\n\n  /**\n   * Call options:\n   *   new Reference(Repo, Path) or\n   *   new Reference(url: string, string|RepoManager)\n   *\n   * Externally - this is the firebase.database.Reference type.\n   *\n   * @param {!Repo} repo\n   * @param {(!Path)} path\n   * @extends {Query}\n   */\n  constructor(repo: Repo, path: Path) {\n    if (!(repo instanceof Repo)) {\n      throw new Error(\n        'new Reference() no longer supported - use app.database().'\n      );\n    }\n\n    // call Query's constructor, passing in the repo and path.\n    super(repo, path, QueryParams.DEFAULT, false);\n  }\n\n  /** @return {?string} */\n  getKey(): string | null {\n    validateArgCount('Reference.key', 0, 0, arguments.length);\n\n    if (this.path.isEmpty()) return null;\n    else return this.path.getBack();\n  }\n\n  /**\n   * @param {!(string|Path)} pathString\n   * @return {!Reference}\n   */\n  child(pathString: string | Path): Reference {\n    validateArgCount('Reference.child', 1, 1, arguments.length);\n    if (typeof pathString === 'number') {\n      pathString = String(pathString);\n    } else if (!(pathString instanceof Path)) {\n      if (this.path.getFront() === null)\n        validateRootPathString('Reference.child', 1, pathString, false);\n      else validatePathString('Reference.child', 1, pathString, false);\n    }\n\n    return new Reference(this.repo, this.path.child(pathString));\n  }\n\n  /** @return {?Reference} */\n  getParent(): Reference | null {\n    validateArgCount('Reference.parent', 0, 0, arguments.length);\n\n    const parentPath = this.path.parent();\n    return parentPath === null ? null : new Reference(this.repo, parentPath);\n  }\n\n  /** @return {!Reference} */\n  getRoot(): Reference {\n    validateArgCount('Reference.root', 0, 0, arguments.length);\n\n    let ref = this as any;\n    while (ref.getParent() !== null) {\n      ref = ref.getParent();\n    }\n    return ref;\n  }\n\n  /** @return {!Database} */\n  databaseProp(): Database {\n    return this.repo.database;\n  }\n\n  /**\n   * @param {*} newVal\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  set(newVal: any, onComplete?: (a: Error | null) => void): Promise<any> {\n    validateArgCount('Reference.set', 1, 2, arguments.length);\n    validateWritablePath('Reference.set', this.path);\n    validateFirebaseDataArg('Reference.set', 1, newVal, this.path, false);\n    validateCallback('Reference.set', 2, onComplete, true);\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path,\n      newVal,\n      /*priority=*/ null,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {!Object} objectToMerge\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  update(\n    objectToMerge: Object,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.update', 1, 2, arguments.length);\n    validateWritablePath('Reference.update', this.path);\n\n    if (Array.isArray(objectToMerge)) {\n      const newObjectToMerge: { [k: string]: any } = {};\n      for (let i = 0; i < objectToMerge.length; ++i) {\n        newObjectToMerge['' + i] = objectToMerge[i];\n      }\n      objectToMerge = newObjectToMerge;\n      warn(\n        'Passing an Array to Firebase.update() is deprecated. ' +\n          'Use set() if you want to overwrite the existing data, or ' +\n          'an Object with integer keys if you really do want to ' +\n          'only update some of the children.'\n      );\n    }\n    validateFirebaseMergeDataArg(\n      'Reference.update',\n      1,\n      objectToMerge,\n      this.path,\n      false\n    );\n    validateCallback('Reference.update', 2, onComplete, true);\n    const deferred = new Deferred();\n    this.repo.update(\n      this.path,\n      objectToMerge,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {*} newVal\n   * @param {string|number|null} newPriority\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  setWithPriority(\n    newVal: any,\n    newPriority: string | number | null,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.setWithPriority', 2, 3, arguments.length);\n    validateWritablePath('Reference.setWithPriority', this.path);\n    validateFirebaseDataArg(\n      'Reference.setWithPriority',\n      1,\n      newVal,\n      this.path,\n      false\n    );\n    validatePriority('Reference.setWithPriority', 2, newPriority, false);\n    validateCallback('Reference.setWithPriority', 3, onComplete, true);\n\n    if (this.getKey() === '.length' || this.getKey() === '.keys')\n      throw 'Reference.setWithPriority failed: ' +\n        this.getKey() +\n        ' is a read-only object.';\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path,\n      newVal,\n      newPriority,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  remove(onComplete?: (a: Error | null) => void): Promise<any> {\n    validateArgCount('Reference.remove', 0, 1, arguments.length);\n    validateWritablePath('Reference.remove', this.path);\n    validateCallback('Reference.remove', 1, onComplete, true);\n\n    return this.set(null, onComplete);\n  }\n\n  /**\n   * @param {function(*):*} transactionUpdate\n   * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete\n   * @param {boolean=} applyLocally\n   * @return {!Promise}\n   */\n  transaction(\n    transactionUpdate: (a: any) => any,\n    onComplete?: (a: Error | null, b: boolean, c: DataSnapshot | null) => void,\n    applyLocally?: boolean\n  ): Promise<TransactionResult> {\n    validateArgCount('Reference.transaction', 1, 3, arguments.length);\n    validateWritablePath('Reference.transaction', this.path);\n    validateCallback('Reference.transaction', 1, transactionUpdate, false);\n    validateCallback('Reference.transaction', 2, onComplete, true);\n    // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how\n    // to expose it.\n    validateBoolean('Reference.transaction', 3, applyLocally, true);\n\n    if (this.getKey() === '.length' || this.getKey() === '.keys')\n      throw 'Reference.transaction failed: ' +\n        this.getKey() +\n        ' is a read-only object.';\n\n    if (applyLocally === undefined) applyLocally = true;\n\n    const deferred = new Deferred<TransactionResult>();\n    if (typeof onComplete === 'function') {\n      deferred.promise.catch(() => {});\n    }\n\n    const promiseComplete = function(\n      error: Error,\n      committed: boolean,\n      snapshot: DataSnapshot\n    ) {\n      if (error) {\n        deferred.reject(error);\n      } else {\n        deferred.resolve(new TransactionResult(committed, snapshot));\n      }\n      if (typeof onComplete === 'function') {\n        onComplete(error, committed, snapshot);\n      }\n    };\n    this.repo.startTransaction(\n      this.path,\n      transactionUpdate,\n      promiseComplete,\n      applyLocally\n    );\n\n    return deferred.promise;\n  }\n\n  /**\n   * @param {string|number|null} priority\n   * @param {function(?Error)=} onComplete\n   * @return {!Promise}\n   */\n  setPriority(\n    priority: string | number | null,\n    onComplete?: (a: Error | null) => void\n  ): Promise<any> {\n    validateArgCount('Reference.setPriority', 1, 2, arguments.length);\n    validateWritablePath('Reference.setPriority', this.path);\n    validatePriority('Reference.setPriority', 1, priority, false);\n    validateCallback('Reference.setPriority', 2, onComplete, true);\n\n    const deferred = new Deferred();\n    this.repo.setWithPriority(\n      this.path.child('.priority'),\n      priority,\n      null,\n      deferred.wrapCallback(onComplete)\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * @param {*=} value\n   * @param {function(?Error)=} onComplete\n   * @return {!Reference}\n   */\n  push(value?: any, onComplete?: (a: Error | null) => void): Reference {\n    validateArgCount('Reference.push', 0, 2, arguments.length);\n    validateWritablePath('Reference.push', this.path);\n    validateFirebaseDataArg('Reference.push', 1, value, this.path, true);\n    validateCallback('Reference.push', 2, onComplete, true);\n\n    const now = this.repo.serverTime();\n    const name = nextPushId(now);\n\n    // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.\n    // We use child() to create handles to two different references. The first is turned into a\n    // ThennableReference below by adding then() and catch() methods and is used as the\n    // return value of push(). The second remains a regular Reference and is used as the fulfilled\n    // value of the first ThennableReference.\n    const thennablePushRef = this.child(name);\n    const pushRef = this.child(name);\n\n    let promise;\n    if (value != null) {\n      promise = thennablePushRef.set(value, onComplete).then(() => pushRef);\n    } else {\n      promise = Promise.resolve(pushRef);\n    }\n\n    thennablePushRef.then = promise.then.bind(promise);\n    thennablePushRef.catch = promise.then.bind(promise, undefined);\n\n    if (typeof onComplete === 'function') {\n      promise.catch(() => {});\n    }\n\n    return thennablePushRef;\n  }\n\n  /**\n   * @return {!OnDisconnect}\n   */\n  onDisconnect(): OnDisconnect {\n    validateWritablePath('Reference.onDisconnect', this.path);\n    return new OnDisconnect(this.repo, this.path);\n  }\n\n  get database(): Database {\n    return this.databaseProp();\n  }\n\n  get key(): string | null {\n    return this.getKey();\n  }\n\n  get parent(): Reference | null {\n    return this.getParent();\n  }\n\n  get root(): Reference {\n    return this.getRoot();\n  }\n}\n\n/**\n * Define reference constructor in various modules\n *\n * We are doing this here to avoid several circular\n * dependency issues\n */\nQuery.__referenceConstructor = Reference;\nSyncPoint.__referenceConstructor = Reference;\n"]},"metadata":{},"sourceType":"script"}