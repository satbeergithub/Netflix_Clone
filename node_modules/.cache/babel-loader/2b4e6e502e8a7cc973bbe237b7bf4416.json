{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createSubscribe } from '@firebase/util';\nimport { patchProperty, deepCopy, deepExtend, ErrorFactory } from '@firebase/util';\nvar contains = function contains(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n// An array to capture listeners before the true auth functions\n// exist\nvar tokenListeners = [];\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\nvar FirebaseAppImpl = /** @class */function () {\n  function FirebaseAppImpl(options, name, firebase_) {\n    this.firebase_ = firebase_;\n    this.isDeleted_ = false;\n    this.services_ = {};\n    this.name_ = name;\n    this.options_ = deepCopy(options);\n    this.INTERNAL = {\n      getUid: function getUid() {\n        return null;\n      },\n      getToken: function getToken() {\n        return Promise.resolve(null);\n      },\n      addAuthTokenListener: function addAuthTokenListener(callback) {\n        tokenListeners.push(callback);\n        // Make sure callback is called, asynchronously, in the absence of the auth module\n        setTimeout(function () {\n          return callback(null);\n        }, 0);\n      },\n      removeAuthTokenListener: function removeAuthTokenListener(callback) {\n        tokenListeners = tokenListeners.filter(function (listener) {\n          return listener !== callback;\n        });\n      }\n    };\n  }\n  Object.defineProperty(FirebaseAppImpl.prototype, \"name\", {\n    get: function get() {\n      this.checkDestroyed_();\n      return this.name_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FirebaseAppImpl.prototype, \"options\", {\n    get: function get() {\n      this.checkDestroyed_();\n      return this.options_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  FirebaseAppImpl.prototype.delete = function () {\n    var _this = this;\n    return new Promise(function (resolve) {\n      _this.checkDestroyed_();\n      resolve();\n    }).then(function () {\n      _this.firebase_.INTERNAL.removeApp(_this.name_);\n      var services = [];\n      Object.keys(_this.services_).forEach(function (serviceKey) {\n        Object.keys(_this.services_[serviceKey]).forEach(function (instanceKey) {\n          services.push(_this.services_[serviceKey][instanceKey]);\n        });\n      });\n      return Promise.all(services.map(function (service) {\n        return service.INTERNAL.delete();\n      }));\n    }).then(function () {\n      _this.isDeleted_ = true;\n      _this.services_ = {};\n    });\n  };\n  /**\n   * Return a service instance associated with this app (creating it\n   * on demand), identified by the passed instanceIdentifier.\n   *\n   * NOTE: Currently storage is the only one that is leveraging this\n   * functionality. They invoke it by calling:\n   *\n   * ```javascript\n   * firebase.app().storage('STORAGE BUCKET ID')\n   * ```\n   *\n   * The service name is passed to this already\n   * @internal\n   */\n  FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {\n    if (instanceIdentifier === void 0) {\n      instanceIdentifier = DEFAULT_ENTRY_NAME;\n    }\n    this.checkDestroyed_();\n    if (!this.services_[name]) {\n      this.services_[name] = {};\n    }\n    if (!this.services_[name][instanceIdentifier]) {\n      /**\n       * If a custom instance has been defined (i.e. not '[DEFAULT]')\n       * then we will pass that instance on, otherwise we pass `null`\n       */\n      var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME ? instanceIdentifier : undefined;\n      var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);\n      this.services_[name][instanceIdentifier] = service;\n    }\n    return this.services_[name][instanceIdentifier];\n  };\n  /**\n   * Callback function used to extend an App instance at the time\n   * of service instance creation.\n   */\n  FirebaseAppImpl.prototype.extendApp = function (props) {\n    var _this = this;\n    // Copy the object onto the FirebaseAppImpl prototype\n    deepExtend(this, props);\n    /**\n     * If the app has overwritten the addAuthTokenListener stub, forward\n     * the active token listeners on to the true fxn.\n     *\n     * TODO: This function is required due to our current module\n     * structure. Once we are able to rely strictly upon a single module\n     * implementation, this code should be refactored and Auth should\n     * provide these stubs and the upgrade logic\n     */\n    if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n      tokenListeners.forEach(function (listener) {\n        _this.INTERNAL.addAuthTokenListener(listener);\n      });\n      tokenListeners = [];\n    }\n  };\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  FirebaseAppImpl.prototype.checkDestroyed_ = function () {\n    if (this.isDeleted_) {\n      error('app-deleted', {\n        name: this.name_\n      });\n    }\n  };\n  return FirebaseAppImpl;\n}();\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\nFirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options || FirebaseAppImpl.prototype.delete || console.log('dc');\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\nexport function createFirebaseNamespace() {\n  var apps_ = {};\n  var factories = {};\n  var appHooks = {};\n  // A namespace is a plain JavaScript Object.\n  var namespace = {\n    // Hack to prevent Babel from modifying the object returned\n    // as the firebase namespace.\n    __esModule: true,\n    initializeApp: initializeApp,\n    app: app,\n    apps: null,\n    Promise: Promise,\n    SDK_VERSION: '4.8.0',\n    INTERNAL: {\n      registerService: registerService,\n      createFirebaseNamespace: createFirebaseNamespace,\n      extendNamespace: extendNamespace,\n      createSubscribe: createSubscribe,\n      ErrorFactory: ErrorFactory,\n      removeApp: removeApp,\n      factories: factories,\n      useAsService: useAsService,\n      Promise: Promise,\n      deepExtend: deepExtend\n    }\n  };\n  // Inject a circular default export to allow Babel users who were previously\n  // using:\n  //\n  //   import firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase').default;\n  //\n  // instead of\n  //\n  //   import * as firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase');\n  patchProperty(namespace, 'default', namespace);\n  // firebase.apps is a read-only getter.\n  Object.defineProperty(namespace, 'apps', {\n    get: getApps\n  });\n  /**\n   * Called by App.delete() - but before any services associated with the App\n   * are deleted.\n   */\n  function removeApp(name) {\n    var app = apps_[name];\n    callAppHooks(app, 'delete');\n    delete apps_[name];\n  }\n  /**\n   * Get the App object for a given name (or DEFAULT).\n   */\n  function app(name) {\n    name = name || DEFAULT_ENTRY_NAME;\n    if (!contains(apps_, name)) {\n      error('no-app', {\n        name: name\n      });\n    }\n    return apps_[name];\n  }\n  patchProperty(app, 'App', FirebaseAppImpl);\n  /**\n   * Create a new App instance (name must be unique).\n   */\n  function initializeApp(options, name) {\n    if (name === undefined) {\n      name = DEFAULT_ENTRY_NAME;\n    } else {\n      if (typeof name !== 'string' || name === '') {\n        error('bad-app-name', {\n          name: name + ''\n        });\n      }\n    }\n    if (contains(apps_, name)) {\n      error('duplicate-app', {\n        name: name\n      });\n    }\n    var app = new FirebaseAppImpl(options, name, namespace);\n    apps_[name] = app;\n    callAppHooks(app, 'create');\n    return app;\n  }\n  /*\n   * Return an array of all the non-deleted FirebaseApps.\n   */\n  function getApps() {\n    // Make a copy so caller cannot mutate the apps list.\n    return Object.keys(apps_).map(function (name) {\n      return apps_[name];\n    });\n  }\n  /*\n   * Register a Firebase Service.\n   *\n   * firebase.INTERNAL.registerService()\n   *\n   * TODO: Implement serviceProperties.\n   */\n  function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {\n    // Cannot re-register a service that already exists\n    if (factories[name]) {\n      error('duplicate-service', {\n        name: name\n      });\n    }\n    // Capture the service factory for later service instantiation\n    factories[name] = createService;\n    // Capture the appHook, if passed\n    if (appHook) {\n      appHooks[name] = appHook;\n      // Run the **new** app hook on all existing apps\n      getApps().forEach(function (app) {\n        appHook('create', app);\n      });\n    }\n    // The Service namespace is an accessor function ...\n    var serviceNamespace = function serviceNamespace(appArg) {\n      if (appArg === void 0) {\n        appArg = app();\n      }\n      if (typeof appArg[name] !== 'function') {\n        // Invalid argument.\n        // This happens in the following case: firebase.storage('gs:/')\n        error('invalid-app-argument', {\n          name: name\n        });\n      }\n      // Forward service instance lookup to the FirebaseApp.\n      return appArg[name]();\n    };\n    // ... and a container for service-level properties.\n    if (serviceProperties !== undefined) {\n      deepExtend(serviceNamespace, serviceProperties);\n    }\n    // Monkey-patch the serviceNamespace onto the firebase namespace\n    namespace[name] = serviceNamespace;\n    // Patch the FirebaseAppImpl prototype\n    FirebaseAppImpl.prototype[name] = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var serviceFxn = this._getService.bind(this, name);\n      return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n    };\n    return serviceNamespace;\n  }\n  /**\n   * Patch the top-level firebase namespace with additional properties.\n   *\n   * firebase.INTERNAL.extendNamespace()\n   */\n  function extendNamespace(props) {\n    deepExtend(namespace, props);\n  }\n  function callAppHooks(app, eventName) {\n    Object.keys(factories).forEach(function (serviceName) {\n      // Ignore virtual services\n      var factoryName = useAsService(app, serviceName);\n      if (factoryName === null) {\n        return;\n      }\n      if (appHooks[factoryName]) {\n        appHooks[factoryName](eventName, app);\n      }\n    });\n  }\n  // Map the requested service to a registered service name\n  // (used to map auth to serverAuth service when needed).\n  function useAsService(app, name) {\n    if (name === 'serverAuth') {\n      return null;\n    }\n    var useService = name;\n    var options = app.options;\n    return useService;\n  }\n  return namespace;\n}\nfunction error(code, args) {\n  throw appErrors.create(code, args);\n}\n// TypeScript does not support non-string indexes!\n// let errors: {[code: AppError: string} = {\nvar errors = {\n  'no-app': \"No Firebase App '{$name}' has been created - \" + 'call Firebase App.initializeApp()',\n  'bad-app-name': \"Illegal App name: '{$name}\",\n  'duplicate-app': \"Firebase App named '{$name}' already exists\",\n  'app-deleted': \"Firebase App named '{$name}' already deleted\",\n  'duplicate-service': \"Firebase service named '{$name}' already registered\",\n  'sa-not-supported': 'Initializing the Firebase SDK with a service ' + 'account is only allowed in a Node.js environment. On client ' + 'devices, you should instead initialize the SDK with an api key and ' + 'auth domain',\n  'invalid-app-argument': 'firebase.{$name}() takes either no argument or a ' + 'Firebase App instance.'\n};\nvar appErrors = new ErrorFactory('app', 'Firebase', errors);","map":{"version":3,"mappings":"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","names":["createSubscribe","patchProperty","deepCopy","deepExtend","ErrorFactory","contains","obj","key","Object","prototype","hasOwnProperty","call","DEFAULT_ENTRY_NAME","tokenListeners","options","name","firebase_","name_","options_","INTERNAL","getUid","getToken","resolve","addAuthTokenListener","callback","push","setTimeout","removeAuthTokenListener","filter","FirebaseAppImpl","checkDestroyed_","Promise","_this","then","removeApp","services","keys","services_","forEach","serviceKey","instanceKey","all","map","service","delete","isDeleted_","instanceIdentifier","instanceSpecifier","undefined","factories","extendApp","bind","props","listener","error","console","log","apps_","appHooks","namespace","__esModule","initializeApp","app","apps","SDK_VERSION","registerService","createFirebaseNamespace","extendNamespace","useAsService","defineProperty","get","getApps","callAppHooks","createService","serviceProperties","appHook","allowMultipleInstances","serviceNamespace","appArg","_i","args","serviceFxn","_getService","apply","eventName","factoryName","serviceName","useService","code","appErrors","create","errors"],"sources":["dist/esm/src/firebaseApp.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createSubscribe, Observer, Subscribe } from '@firebase/util';\nimport {\n  patchProperty,\n  deepCopy,\n  deepExtend,\n  ErrorFactory,\n  FirebaseError\n} from '@firebase/util';\n\nexport interface FirebaseAuthTokenData {\n  accessToken: string;\n}\n\nexport interface FirebaseAppInternals {\n  getToken(refreshToken?: boolean): Promise<FirebaseAuthTokenData | null>;\n  getUid(): string | null;\n  addAuthTokenListener(fn: (token: string | null) => void): void;\n  removeAuthTokenListener(fn: (token: string | null) => void): void;\n}\n\nexport type FirebaseOptions = {\n  apiKey?: string;\n  authDomain?: string;\n  databaseURL?: string;\n  projectId?: string;\n  storageBucket?: string;\n  messagingSenderId?: string;\n  [name: string]: any;\n};\n\n// An instance of the firebase.App\nexport interface FirebaseApp {\n  /**\n   * The (read-only) name (identifier) for this App. '[DEFAULT]' is the default\n   * App.\n   */\n  name: string;\n\n  /**\n   * The (read-only) configuration options from the app initialization.\n   */\n  options: FirebaseOptions;\n\n  /**\n   * Make the given App unusable and free resources.\n   */\n  delete(): Promise<void>;\n\n  INTERNAL: FirebaseAppInternals;\n}\n\nexport interface FirebaseServiceInternals {\n  /**\n   * Delete the service and free it's resources - called from\n   * app.delete().\n   */\n  delete(): Promise<void>;\n}\n\n// Services are exposed through instances - each of which is associated with a\n// FirebaseApp.\nexport interface FirebaseService {\n  app: FirebaseApp;\n  INTERNAL?: FirebaseServiceInternals;\n}\n\nexport type AppHook = (event: string, app: FirebaseApp) => void;\n\n/**\n * Firebase Services create instances given a Firebase App instance and can\n * optionally add properties and methods to each FirebaseApp via the extendApp()\n * function.\n */\nexport interface FirebaseServiceFactory {\n  (\n    app: FirebaseApp,\n    extendApp?: (props: { [prop: string]: any }) => void,\n    instanceString?: string\n  ): FirebaseService;\n}\n\n/**\n * All ServiceNamespaces extend from FirebaseServiceNamespace\n */\nexport interface FirebaseServiceNamespace<T extends FirebaseService> {\n  (app?: FirebaseApp): T;\n}\n\nexport interface FirebaseErrorFactory<T> {\n  create(code: T, data?: { [prop: string]: any }): FirebaseError;\n}\n\nexport interface FirebaseErrorFactoryClass {\n  new (\n    service: string,\n    serviceName: string,\n    errors: { [code: string]: string }\n  ): FirebaseErrorFactory<any>;\n}\n\nexport interface FirebaseNamespace {\n  /**\n   * Create (and intialize) a FirebaseApp.\n   *\n   * @param options Options to configure the services use in the App.\n   * @param name The optional name of the app to initialize ('[DEFAULT]' if\n   *   none)\n   */\n  initializeApp(options: FirebaseOptions, name?: string): FirebaseApp;\n\n  app: {\n    /**\n     * Retrieve an instance of a FirebaseApp.\n     *\n     * Usage: firebase.app()\n     *\n     * @param name The optional name of the app to return ('[DEFAULT]' if none)\n     */\n    (name?: string): FirebaseApp;\n\n    /**\n     * For testing FirebaseApp instances:\n     *   app() instanceof firebase.app.App\n     * DO NOT call this constuctor directly (use firebase.app() instead).\n     */\n    App: Function;\n  };\n\n  /**\n   * A (read-only) array of all the initialized Apps.\n   */\n  apps: FirebaseApp[];\n\n  // Inherit the type information of our exported Promise implementation from\n  // es6-promises.\n  Promise: typeof Promise;\n\n  // The current SDK version ('${JSCORE_VERSION}').\n  SDK_VERSION: string;\n\n  // TODO: Migrate to firebase-app-internal.d.ts\n  INTERNAL: {\n    /**\n     * Internal API to register a Firebase Service into the firebase namespace.\n     *\n     * Each service will create a child namespace (firease.name) which acts as\n     * both a namespace for service specific properties, and also as a service\n     * accessor function (firebase.name() or firebase.name(app)).\n     *\n     * @param name The Firebase Service being registered.\n     * @param createService Factory function to create a service instance.\n     * @param serviceProperties Properties to copy to the service's namespace.\n     * @param appHook All appHooks called before intializeApp returns to caller.\n     * @param allowMultipleInstances Whether the registered service supports\n     *   multiple instances per app. If not specified, the default is false.\n     */\n    registerService(\n      name: string,\n      createService: FirebaseServiceFactory,\n      serviceProperties?: { [prop: string]: any },\n      appHook?: AppHook,\n      allowMultipleInstances?: boolean\n    ): FirebaseServiceNamespace<FirebaseService>;\n\n    /**\n     * Just used for testing to start from a fresh namespace.\n     */\n    createFirebaseNamespace(): FirebaseNamespace;\n\n    /**\n     * Internal API to install properties on the top-level firebase namespace.\n     * @prop props The top level properties of this object are copied to the\n     *   namespace.\n     */\n    extendNamespace(props: { [prop: string]: any }): void;\n\n    /**\n     * Create a Subscribe function.  A proxy Observer is created so that\n     * events can be sent to single Observer to be fanned out automatically.\n     */\n    createSubscribe<T>(\n      executor: (observer: Observer<T>) => void,\n      onNoObservers?: (observer: Observer<T>) => void\n    ): Subscribe<T>;\n\n    /**\n     * Utility exposed for internal testing.\n     */\n    deepExtend(target: any, source: any): any;\n\n    /**\n     * Internal API to remove an app from the list of registered apps.\n     */\n    removeApp(name: string): void;\n\n    /**\n     * Service factories for each registered service.\n     */\n    factories: { [name: string]: FirebaseServiceFactory };\n\n    /*\n     * Convert service name to factory name to use.\n     */\n    useAsService(app: FirebaseApp, serviceName: string): string | null;\n\n    /**\n     * Use to construct all thrown FirebaseError's.\n     */\n    ErrorFactory: FirebaseErrorFactoryClass;\n  };\n}\n\nconst contains = function(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n// An array to capture listeners before the true auth functions\n// exist\nlet tokenListeners = [];\n\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\nclass FirebaseAppImpl implements FirebaseApp {\n  private options_: FirebaseOptions;\n  private name_: string;\n  private isDeleted_ = false;\n  private services_: {\n    [name: string]: {\n      [serviceName: string]: FirebaseService;\n    };\n  } = {};\n\n  public INTERNAL;\n\n  constructor(\n    options: FirebaseOptions,\n    name: string,\n    private firebase_: FirebaseNamespace\n  ) {\n    this.name_ = name;\n    this.options_ = deepCopy<FirebaseOptions>(options);\n    this.INTERNAL = {\n      getUid: () => null,\n      getToken: () => Promise.resolve(null),\n      addAuthTokenListener: (callback: (token: string | null) => void) => {\n        tokenListeners.push(callback);\n        // Make sure callback is called, asynchronously, in the absence of the auth module\n        setTimeout(() => callback(null), 0);\n      },\n      removeAuthTokenListener: callback => {\n        tokenListeners = tokenListeners.filter(\n          listener => listener !== callback\n        );\n      }\n    };\n  }\n\n  get name(): string {\n    this.checkDestroyed_();\n    return this.name_;\n  }\n\n  get options(): FirebaseOptions {\n    this.checkDestroyed_();\n    return this.options_;\n  }\n\n  delete(): Promise<void> {\n    return new Promise(resolve => {\n      this.checkDestroyed_();\n      resolve();\n    })\n      .then(() => {\n        this.firebase_.INTERNAL.removeApp(this.name_);\n        let services: FirebaseService[] = [];\n        Object.keys(this.services_).forEach(serviceKey => {\n          Object.keys(this.services_[serviceKey]).forEach(instanceKey => {\n            services.push(this.services_[serviceKey][instanceKey]);\n          });\n        });\n        return Promise.all(\n          services.map(service => {\n            return service.INTERNAL!.delete();\n          })\n        );\n      })\n      .then((): void => {\n        this.isDeleted_ = true;\n        this.services_ = {};\n      });\n  }\n\n  /**\n   * Return a service instance associated with this app (creating it\n   * on demand), identified by the passed instanceIdentifier.\n   *\n   * NOTE: Currently storage is the only one that is leveraging this\n   * functionality. They invoke it by calling:\n   *\n   * ```javascript\n   * firebase.app().storage('STORAGE BUCKET ID')\n   * ```\n   *\n   * The service name is passed to this already\n   * @internal\n   */\n  _getService(\n    name: string,\n    instanceIdentifier: string = DEFAULT_ENTRY_NAME\n  ): FirebaseService {\n    this.checkDestroyed_();\n\n    if (!this.services_[name]) {\n      this.services_[name] = {};\n    }\n\n    if (!this.services_[name][instanceIdentifier]) {\n      /**\n       * If a custom instance has been defined (i.e. not '[DEFAULT]')\n       * then we will pass that instance on, otherwise we pass `null`\n       */\n      const instanceSpecifier =\n        instanceIdentifier !== DEFAULT_ENTRY_NAME\n          ? instanceIdentifier\n          : undefined;\n      const service = this.firebase_.INTERNAL.factories[name](\n        this,\n        this.extendApp.bind(this),\n        instanceSpecifier\n      );\n      this.services_[name][instanceIdentifier] = service;\n    }\n\n    return this.services_[name][instanceIdentifier];\n  }\n\n  /**\n   * Callback function used to extend an App instance at the time\n   * of service instance creation.\n   */\n  private extendApp(props: { [name: string]: any }): void {\n    // Copy the object onto the FirebaseAppImpl prototype\n    deepExtend(this, props);\n\n    /**\n     * If the app has overwritten the addAuthTokenListener stub, forward\n     * the active token listeners on to the true fxn.\n     *\n     * TODO: This function is required due to our current module\n     * structure. Once we are able to rely strictly upon a single module\n     * implementation, this code should be refactored and Auth should\n     * provide these stubs and the upgrade logic\n     */\n    if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n      tokenListeners.forEach(listener => {\n        this.INTERNAL.addAuthTokenListener(listener);\n      });\n      tokenListeners = [];\n    }\n  }\n\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  private checkDestroyed_(): void {\n    if (this.isDeleted_) {\n      error('app-deleted', { name: this.name_ });\n    }\n  }\n}\n\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\n(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||\n  FirebaseAppImpl.prototype.delete ||\n  console.log('dc');\n\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\nexport function createFirebaseNamespace(): FirebaseNamespace {\n  let apps_: { [name: string]: FirebaseApp } = {};\n  let factories: { [service: string]: FirebaseServiceFactory } = {};\n  let appHooks: { [service: string]: AppHook } = {};\n\n  // A namespace is a plain JavaScript Object.\n  let namespace = {\n    // Hack to prevent Babel from modifying the object returned\n    // as the firebase namespace.\n    __esModule: true,\n    initializeApp: initializeApp,\n    app: app as any,\n    apps: null as any,\n    Promise: Promise,\n    SDK_VERSION: '${JSCORE_VERSION}',\n    INTERNAL: {\n      registerService: registerService,\n      createFirebaseNamespace: createFirebaseNamespace,\n      extendNamespace: extendNamespace,\n      createSubscribe: createSubscribe,\n      ErrorFactory: ErrorFactory,\n      removeApp: removeApp,\n      factories: factories,\n      useAsService: useAsService,\n      Promise: Promise,\n      deepExtend: deepExtend\n    }\n  };\n\n  // Inject a circular default export to allow Babel users who were previously\n  // using:\n  //\n  //   import firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase').default;\n  //\n  // instead of\n  //\n  //   import * as firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase');\n  patchProperty(namespace, 'default', namespace);\n\n  // firebase.apps is a read-only getter.\n  Object.defineProperty(namespace, 'apps', {\n    get: getApps\n  });\n\n  /**\n   * Called by App.delete() - but before any services associated with the App\n   * are deleted.\n   */\n  function removeApp(name: string): void {\n    let app = apps_[name];\n    callAppHooks(app, 'delete');\n    delete apps_[name];\n  }\n\n  /**\n   * Get the App object for a given name (or DEFAULT).\n   */\n  function app(name?: string): FirebaseApp {\n    name = name || DEFAULT_ENTRY_NAME;\n    if (!contains(apps_, name)) {\n      error('no-app', { name: name });\n    }\n    return apps_[name];\n  }\n\n  patchProperty(app, 'App', FirebaseAppImpl);\n\n  /**\n   * Create a new App instance (name must be unique).\n   */\n  function initializeApp(options: FirebaseOptions, name?: string): FirebaseApp {\n    if (name === undefined) {\n      name = DEFAULT_ENTRY_NAME;\n    } else {\n      if (typeof name !== 'string' || name === '') {\n        error('bad-app-name', { name: name + '' });\n      }\n    }\n    if (contains(apps_, name)) {\n      error('duplicate-app', { name: name });\n    }\n\n    let app = new FirebaseAppImpl(\n      options,\n      name!,\n      namespace as FirebaseNamespace\n    );\n\n    apps_[name!] = app;\n    callAppHooks(app, 'create');\n\n    return app;\n  }\n\n  /*\n   * Return an array of all the non-deleted FirebaseApps.\n   */\n  function getApps(): FirebaseApp[] {\n    // Make a copy so caller cannot mutate the apps list.\n    return Object.keys(apps_).map(name => apps_[name]);\n  }\n\n  /*\n   * Register a Firebase Service.\n   *\n   * firebase.INTERNAL.registerService()\n   *\n   * TODO: Implement serviceProperties.\n   */\n  function registerService(\n    name: string,\n    createService: FirebaseServiceFactory,\n    serviceProperties?: { [prop: string]: any },\n    appHook?: AppHook,\n    allowMultipleInstances?: boolean\n  ): FirebaseServiceNamespace<FirebaseService> {\n    // Cannot re-register a service that already exists\n    if (factories[name]) {\n      error('duplicate-service', { name: name });\n    }\n\n    // Capture the service factory for later service instantiation\n    factories[name] = createService;\n\n    // Capture the appHook, if passed\n    if (appHook) {\n      appHooks[name] = appHook;\n\n      // Run the **new** app hook on all existing apps\n      getApps().forEach(app => {\n        appHook('create', app);\n      });\n    }\n\n    // The Service namespace is an accessor function ...\n    const serviceNamespace = (appArg: FirebaseApp = app()) => {\n      if (typeof (appArg as any)[name] !== 'function') {\n        // Invalid argument.\n        // This happens in the following case: firebase.storage('gs:/')\n        error('invalid-app-argument', { name: name });\n      }\n\n      // Forward service instance lookup to the FirebaseApp.\n      return (appArg as any)[name]();\n    };\n\n    // ... and a container for service-level properties.\n    if (serviceProperties !== undefined) {\n      deepExtend(serviceNamespace, serviceProperties);\n    }\n\n    // Monkey-patch the serviceNamespace onto the firebase namespace\n    (namespace as any)[name] = serviceNamespace;\n\n    // Patch the FirebaseAppImpl prototype\n    FirebaseAppImpl.prototype[name] = function(...args) {\n      const serviceFxn = this._getService.bind(this, name);\n      return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n    };\n\n    return serviceNamespace;\n  }\n\n  /**\n   * Patch the top-level firebase namespace with additional properties.\n   *\n   * firebase.INTERNAL.extendNamespace()\n   */\n  function extendNamespace(props: { [prop: string]: any }): void {\n    deepExtend(namespace, props);\n  }\n\n  function callAppHooks(app: FirebaseApp, eventName: string) {\n    Object.keys(factories).forEach(serviceName => {\n      // Ignore virtual services\n      let factoryName = useAsService(app, serviceName);\n      if (factoryName === null) {\n        return;\n      }\n\n      if (appHooks[factoryName]) {\n        appHooks[factoryName](eventName, app);\n      }\n    });\n  }\n\n  // Map the requested service to a registered service name\n  // (used to map auth to serverAuth service when needed).\n  function useAsService(app: FirebaseApp, name: string): string | null {\n    if (name === 'serverAuth') {\n      return null;\n    }\n\n    let useService = name;\n    let options = app.options;\n\n    return useService;\n  }\n\n  return (namespace as any) as FirebaseNamespace;\n}\n\ntype AppError =\n  | 'no-app'\n  | 'bad-app-name'\n  | 'duplicate-app'\n  | 'app-deleted'\n  | 'duplicate-service'\n  | 'sa-not-supported'\n  | 'invalid-app-argument';\n\nfunction error(code: AppError, args?: { [name: string]: any }) {\n  throw appErrors.create(code, args);\n}\n\n// TypeScript does not support non-string indexes!\n// let errors: {[code: AppError: string} = {\nlet errors: { [code: string]: string } = {\n  'no-app':\n    \"No Firebase App '{$name}' has been created - \" +\n    'call Firebase App.initializeApp()',\n  'bad-app-name': \"Illegal App name: '{$name}\",\n  'duplicate-app': \"Firebase App named '{$name}' already exists\",\n  'app-deleted': \"Firebase App named '{$name}' already deleted\",\n  'duplicate-service': \"Firebase service named '{$name}' already registered\",\n  'sa-not-supported':\n    'Initializing the Firebase SDK with a service ' +\n    'account is only allowed in a Node.js environment. On client ' +\n    'devices, you should instead initialize the SDK with an api key and ' +\n    'auth domain',\n  'invalid-app-argument':\n    'firebase.{$name}() takes either no argument or a ' +\n    'Firebase App instance.'\n};\n\nlet appErrors = new ErrorFactory<AppError>('app', 'Firebase', errors);\n"]},"metadata":{},"sourceType":"module"}