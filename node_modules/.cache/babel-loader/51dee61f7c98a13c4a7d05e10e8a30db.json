{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"./util/util\");\nvar util_3 = require(\"@firebase/util\");\nvar util_4 = require(\"@firebase/util\");\nvar util_5 = require(\"@firebase/util\");\nvar ServerActions_1 = require(\"./ServerActions\");\n/**\n * An implementation of ServerActions that communicates with the server via REST requests.\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\n * persistent connection (using WebSockets or long-polling)\n */\nvar ReadonlyRestClient = /** @class */function (_super) {\n  __extends(ReadonlyRestClient, _super);\n  /**\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param {AuthTokenProvider} authTokenProvider_\n   * @implements {ServerActions}\n   */\n  function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_) {\n    var _this = _super.call(this) || this;\n    _this.repoInfo_ = repoInfo_;\n    _this.onDataUpdate_ = onDataUpdate_;\n    _this.authTokenProvider_ = authTokenProvider_;\n    /** @private {function(...[*])} */\n    _this.log_ = util_2.logWrapper('p:rest:');\n    /**\n     * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\n     * that's been removed. :-/\n     *\n     * @private {!Object.<string, !Object>}\n     */\n    _this.listens_ = {};\n    return _this;\n  }\n  ReadonlyRestClient.prototype.reportStats = function (stats) {\n    throw new Error('Method not implemented.');\n  };\n  /**\n   * @param {!Query} query\n   * @param {?number=} tag\n   * @return {string}\n   * @private\n   */\n  ReadonlyRestClient.getListenId_ = function (query, tag) {\n    if (tag !== undefined) {\n      return 'tag$' + tag;\n    } else {\n      util_1.assert(query.getQueryParams().isDefault(), \"should have a tag if it's not a default query.\");\n      return query.path.toString();\n    }\n  };\n  /** @inheritDoc */\n  ReadonlyRestClient.prototype.listen = function (query, currentHashFn, tag, onComplete) {\n    var _this = this;\n    var pathString = query.path.toString();\n    this.log_('Listen called for ' + pathString + ' ' + query.queryIdentifier());\n    // Mark this listener so we can tell if it's removed.\n    var listenId = ReadonlyRestClient.getListenId_(query, tag);\n    var thisListen = {};\n    this.listens_[listenId] = thisListen;\n    var queryStringParamaters = query.getQueryParams().toRestQueryStringParameters();\n    this.restRequest_(pathString + '.json', queryStringParamaters, function (error, result) {\n      var data = result;\n      if (error === 404) {\n        data = null;\n        error = null;\n      }\n      if (error === null) {\n        _this.onDataUpdate_(pathString, data, /*isMerge=*/false, tag);\n      }\n      if (util_4.safeGet(_this.listens_, listenId) === thisListen) {\n        var status_1;\n        if (!error) {\n          status_1 = 'ok';\n        } else if (error == 401) {\n          status_1 = 'permission_denied';\n        } else {\n          status_1 = 'rest_error:' + error;\n        }\n        onComplete(status_1, null);\n      }\n    });\n  };\n  /** @inheritDoc */\n  ReadonlyRestClient.prototype.unlisten = function (query, tag) {\n    var listenId = ReadonlyRestClient.getListenId_(query, tag);\n    delete this.listens_[listenId];\n  };\n  /** @inheritDoc */\n  ReadonlyRestClient.prototype.refreshAuthToken = function (token) {\n    // no-op since we just always call getToken.\n  };\n  /**\n   * Performs a REST request to the given path, with the provided query string parameters,\n   * and any auth credentials we have.\n   *\n   * @param {!string} pathString\n   * @param {!Object.<string, *>} queryStringParameters\n   * @param {?function(?number, *=)} callback\n   * @private\n   */\n  ReadonlyRestClient.prototype.restRequest_ = function (pathString, queryStringParameters, callback) {\n    var _this = this;\n    if (queryStringParameters === void 0) {\n      queryStringParameters = {};\n    }\n    queryStringParameters['format'] = 'export';\n    this.authTokenProvider_.getToken( /*forceRefresh=*/false).then(function (authTokenData) {\n      var authToken = authTokenData && authTokenData.accessToken;\n      if (authToken) {\n        queryStringParameters['auth'] = authToken;\n      }\n      var url = (_this.repoInfo_.secure ? 'https://' : 'http://') + _this.repoInfo_.host + pathString + '?' + util_5.querystring(queryStringParameters);\n      _this.log_('Sending REST request for ' + url);\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function () {\n        if (callback && xhr.readyState === 4) {\n          _this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);\n          var res = null;\n          if (xhr.status >= 200 && xhr.status < 300) {\n            try {\n              res = util_3.jsonEval(xhr.responseText);\n            } catch (e) {\n              util_2.warn('Failed to parse JSON response for ' + url + ': ' + xhr.responseText);\n            }\n            callback(null, res);\n          } else {\n            // 401 and 404 are expected.\n            if (xhr.status !== 401 && xhr.status !== 404) {\n              util_2.warn('Got unsuccessful REST response for ' + url + ' Status: ' + xhr.status);\n            }\n            callback(xhr.status);\n          }\n          callback = null;\n        }\n      };\n      xhr.open('GET', url, /*asynchronous=*/true);\n      xhr.send();\n    });\n  };\n  return ReadonlyRestClient;\n}(ServerActions_1.ServerActions);\nexports.ReadonlyRestClient = ReadonlyRestClient;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AAKA;;;;;AAKA;EAAwCA;EAkCtC;;;;;;EAMA,4BACUC,SAAmB,EACnBC,aAKC,EACDC,kBAAqC;IAR/C,YAUEC,iBAAO;IATCC,eAAS,GAATJ,SAAS;IACTI,mBAAa,GAAbH,aAAa;IAMbG,wBAAkB,GAAlBF,kBAAkB;IA3C5B;IACQE,UAAI,GAA6BC,iBAAU,CAAC,SAAS,CAAC;IAE9D;;;;;;IAMQD,cAAQ,GAA4B,EAAE;;EAqC9C;EAlDAE,wCAAW,GAAX,UAAYC,KAA2B;IACrC,MAAM,IAAIC,KAAK,CAAC,yBAAyB,CAAC;EAC5C,CAAC;EAaD;;;;;;EAMOF,+BAAY,GAAnB,UAAoBG,KAAY,EAAEC,GAAmB;IACnD,IAAIA,GAAG,KAAKC,SAAS,EAAE;MACrB,OAAO,MAAM,GAAGD,GAAG;IACrB,CAAC,MAAM;MACLE,aAAM,CACJH,KAAK,CAACI,cAAc,EAAE,CAACC,SAAS,EAAE,EAClC,gDAAgD,CACjD;MACD,OAAOL,KAAK,CAACM,IAAI,CAACC,QAAQ,EAAE;IAC9B;EACF,CAAC;EAqBD;EACAV,mCAAM,GAAN,UACEG,KAAY,EACZQ,aAA2B,EAC3BP,GAAkB,EAClBQ,UAAuC;IAJzC;IAME,IAAMC,UAAU,GAAGV,KAAK,CAACM,IAAI,CAACC,QAAQ,EAAE;IACxC,IAAI,CAACI,IAAI,CACP,oBAAoB,GAAGD,UAAU,GAAG,GAAG,GAAGV,KAAK,CAACY,eAAe,EAAE,CAClE;IAED;IACA,IAAMC,QAAQ,GAAGhB,kBAAkB,CAACiB,YAAY,CAACd,KAAK,EAAEC,GAAG,CAAC;IAC5D,IAAMc,UAAU,GAAG,EAAE;IACrB,IAAI,CAACC,QAAQ,CAACH,QAAQ,CAAC,GAAGE,UAAU;IAEpC,IAAME,qBAAqB,GAAGjB,KAAK,CAChCI,cAAc,EAAE,CAChBc,2BAA2B,EAAE;IAEhC,IAAI,CAACC,YAAY,CACfT,UAAU,GAAG,OAAO,EACpBO,qBAAqB,EACrB,UAACG,KAAK,EAAEC,MAAM;MACZ,IAAIC,IAAI,GAAGD,MAAM;MAEjB,IAAID,KAAK,KAAK,GAAG,EAAE;QACjBE,IAAI,GAAG,IAAI;QACXF,KAAK,GAAG,IAAI;MACd;MAEA,IAAIA,KAAK,KAAK,IAAI,EAAE;QAClBzB,KAAI,CAACH,aAAa,CAACkB,UAAU,EAAEY,IAAI,EAAE,YAAa,KAAK,EAAErB,GAAG,CAAC;MAC/D;MAEA,IAAIsB,cAAO,CAAC5B,KAAI,CAACqB,QAAQ,EAAEH,QAAQ,CAAC,KAAKE,UAAU,EAAE;QACnD,IAAIS,QAAM;QACV,IAAI,CAACJ,KAAK,EAAE;UACVI,QAAM,GAAG,IAAI;QACf,CAAC,MAAM,IAAIJ,KAAK,IAAI,GAAG,EAAE;UACvBI,QAAM,GAAG,mBAAmB;QAC9B,CAAC,MAAM;UACLA,QAAM,GAAG,aAAa,GAAGJ,KAAK;QAChC;QAEAX,UAAU,CAACe,QAAM,EAAE,IAAI,CAAC;MAC1B;IACF,CAAC,CACF;EACH,CAAC;EAED;EACA3B,qCAAQ,GAAR,UAASG,KAAY,EAAEC,GAAkB;IACvC,IAAMY,QAAQ,GAAGhB,kBAAkB,CAACiB,YAAY,CAACd,KAAK,EAAEC,GAAG,CAAC;IAC5D,OAAO,IAAI,CAACe,QAAQ,CAACH,QAAQ,CAAC;EAChC,CAAC;EAED;EACAhB,6CAAgB,GAAhB,UAAiB4B,KAAa;IAC5B;EAAA,CACD;EAED;;;;;;;;;EASQ5B,yCAAY,GAApB,UACEa,UAAkB,EAClBgB,qBAAgD,EAChDC,QAAsD;IAHxD;IAEE;MAAAD,0BAAgD;IAAA;IAGhDA,qBAAqB,CAAC,QAAQ,CAAC,GAAG,QAAQ;IAE1C,IAAI,CAACjC,kBAAkB,CACpBmC,QAAQ,EAAC,iBAAkB,KAAK,CAAC,CACjCC,IAAI,CAAC,uBAAa;MACjB,IAAMC,SAAS,GAAGC,aAAa,IAAIA,aAAa,CAACC,WAAW;MAC5D,IAAIF,SAAS,EAAE;QACbJ,qBAAqB,CAAC,MAAM,CAAC,GAAGI,SAAS;MAC3C;MAEA,IAAMG,GAAG,GACP,CAACtC,KAAI,CAACJ,SAAS,CAAC2C,MAAM,GAAG,UAAU,GAAG,SAAS,IAC/CvC,KAAI,CAACJ,SAAS,CAAC4C,IAAI,GACnBzB,UAAU,GACV,GAAG,GACH0B,kBAAW,CAACV,qBAAqB,CAAC;MAEpC/B,KAAI,CAACgB,IAAI,CAAC,2BAA2B,GAAGsB,GAAG,CAAC;MAC5C,IAAMI,GAAG,GAAG,IAAIC,cAAc,EAAE;MAChCD,GAAG,CAACE,kBAAkB,GAAG;QACvB,IAAIZ,QAAQ,IAAIU,GAAG,CAACG,UAAU,KAAK,CAAC,EAAE;UACpC7C,KAAI,CAACgB,IAAI,CACP,oBAAoB,GAAGsB,GAAG,GAAG,oBAAoB,EACjDI,GAAG,CAACI,MAAM,EACV,WAAW,EACXJ,GAAG,CAACK,YAAY,CACjB;UACD,IAAIC,GAAG,GAAG,IAAI;UACd,IAAIN,GAAG,CAACI,MAAM,IAAI,GAAG,IAAIJ,GAAG,CAACI,MAAM,GAAG,GAAG,EAAE;YACzC,IAAI;cACFE,GAAG,GAAGC,eAAQ,CAACP,GAAG,CAACK,YAAY,CAAC;YAClC,CAAC,CAAC,OAAOG,CAAC,EAAE;cACVjD,WAAI,CACF,oCAAoC,GAClCqC,GAAG,GACH,IAAI,GACJI,GAAG,CAACK,YAAY,CACnB;YACH;YACAf,QAAQ,CAAC,IAAI,EAAEgB,GAAG,CAAC;UACrB,CAAC,MAAM;YACL;YACA,IAAIN,GAAG,CAACI,MAAM,KAAK,GAAG,IAAIJ,GAAG,CAACI,MAAM,KAAK,GAAG,EAAE;cAC5C7C,WAAI,CACF,qCAAqC,GACnCqC,GAAG,GACH,WAAW,GACXI,GAAG,CAACI,MAAM,CACb;YACH;YACAd,QAAQ,CAACU,GAAG,CAACI,MAAM,CAAC;UACtB;UACAd,QAAQ,GAAG,IAAI;QACjB;MACF,CAAC;MAEDU,GAAG,CAACS,IAAI,CAAC,KAAK,EAAEb,GAAG,EAAE,iBAAkB,IAAI,CAAC;MAC5CI,GAAG,CAACU,IAAI,EAAE;IACZ,CAAC,CAAC;EACN,CAAC;EACH,yBAAC;AAAD,CA9LA,CAAwCC,6BAAa;AAAxCC","names":["__extends","repoInfo_","onDataUpdate_","authTokenProvider_","_super","_this","util_2","ReadonlyRestClient","stats","Error","query","tag","undefined","util_1","getQueryParams","isDefault","path","toString","currentHashFn","onComplete","pathString","log_","queryIdentifier","listenId","getListenId_","thisListen","listens_","queryStringParamaters","toRestQueryStringParameters","restRequest_","error","result","data","util_4","status_1","token","queryStringParameters","callback","getToken","then","authToken","authTokenData","accessToken","url","secure","host","util_5","xhr","XMLHttpRequest","onreadystatechange","readyState","status","responseText","res","util_3","e","open","send","ServerActions_1","exports"],"sources":["../src/core/ReadonlyRestClient.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { logWrapper, warn } from './util/util';\nimport { jsonEval } from '@firebase/util';\nimport { safeGet } from '@firebase/util';\nimport { querystring } from '@firebase/util';\nimport { ServerActions } from './ServerActions';\nimport { RepoInfo } from './RepoInfo';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { Query } from '../api/Query';\n\n/**\n * An implementation of ServerActions that communicates with the server via REST requests.\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\n * persistent connection (using WebSockets or long-polling)\n */\nexport class ReadonlyRestClient extends ServerActions {\n  reportStats(stats: { [k: string]: any }): void {\n    throw new Error('Method not implemented.');\n  }\n\n  /** @private {function(...[*])} */\n  private log_: (...args: any[]) => void = logWrapper('p:rest:');\n\n  /**\n   * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\n   * that's been removed. :-/\n   *\n   * @private {!Object.<string, !Object>}\n   */\n  private listens_: { [k: string]: Object } = {};\n\n  /**\n   * @param {!Query} query\n   * @param {?number=} tag\n   * @return {string}\n   * @private\n   */\n  static getListenId_(query: Query, tag?: number | null): string {\n    if (tag !== undefined) {\n      return 'tag$' + tag;\n    } else {\n      assert(\n        query.getQueryParams().isDefault(),\n        \"should have a tag if it's not a default query.\"\n      );\n      return query.path.toString();\n    }\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param {AuthTokenProvider} authTokenProvider_\n   * @implements {ServerActions}\n   */\n  constructor(\n    private repoInfo_: RepoInfo,\n    private onDataUpdate_: (\n      a: string,\n      b: any,\n      c: boolean,\n      d: number | null\n    ) => void,\n    private authTokenProvider_: AuthTokenProvider\n  ) {\n    super();\n  }\n\n  /** @inheritDoc */\n  listen(\n    query: Query,\n    currentHashFn: () => string,\n    tag: number | null,\n    onComplete: (a: string, b: any) => void\n  ) {\n    const pathString = query.path.toString();\n    this.log_(\n      'Listen called for ' + pathString + ' ' + query.queryIdentifier()\n    );\n\n    // Mark this listener so we can tell if it's removed.\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    const thisListen = {};\n    this.listens_[listenId] = thisListen;\n\n    const queryStringParamaters = query\n      .getQueryParams()\n      .toRestQueryStringParameters();\n\n    this.restRequest_(\n      pathString + '.json',\n      queryStringParamaters,\n      (error, result) => {\n        let data = result;\n\n        if (error === 404) {\n          data = null;\n          error = null;\n        }\n\n        if (error === null) {\n          this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\n        }\n\n        if (safeGet(this.listens_, listenId) === thisListen) {\n          let status;\n          if (!error) {\n            status = 'ok';\n          } else if (error == 401) {\n            status = 'permission_denied';\n          } else {\n            status = 'rest_error:' + error;\n          }\n\n          onComplete(status, null);\n        }\n      }\n    );\n  }\n\n  /** @inheritDoc */\n  unlisten(query: Query, tag: number | null) {\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    delete this.listens_[listenId];\n  }\n\n  /** @inheritDoc */\n  refreshAuthToken(token: string) {\n    // no-op since we just always call getToken.\n  }\n\n  /**\n   * Performs a REST request to the given path, with the provided query string parameters,\n   * and any auth credentials we have.\n   *\n   * @param {!string} pathString\n   * @param {!Object.<string, *>} queryStringParameters\n   * @param {?function(?number, *=)} callback\n   * @private\n   */\n  private restRequest_(\n    pathString: string,\n    queryStringParameters: { [k: string]: any } = {},\n    callback: ((a: number | null, b?: any) => void) | null\n  ) {\n    queryStringParameters['format'] = 'export';\n\n    this.authTokenProvider_\n      .getToken(/*forceRefresh=*/ false)\n      .then(authTokenData => {\n        const authToken = authTokenData && authTokenData.accessToken;\n        if (authToken) {\n          queryStringParameters['auth'] = authToken;\n        }\n\n        const url =\n          (this.repoInfo_.secure ? 'https://' : 'http://') +\n          this.repoInfo_.host +\n          pathString +\n          '?' +\n          querystring(queryStringParameters);\n\n        this.log_('Sending REST request for ' + url);\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n          if (callback && xhr.readyState === 4) {\n            this.log_(\n              'REST Response for ' + url + ' received. status:',\n              xhr.status,\n              'response:',\n              xhr.responseText\n            );\n            let res = null;\n            if (xhr.status >= 200 && xhr.status < 300) {\n              try {\n                res = jsonEval(xhr.responseText);\n              } catch (e) {\n                warn(\n                  'Failed to parse JSON response for ' +\n                    url +\n                    ': ' +\n                    xhr.responseText\n                );\n              }\n              callback(null, res);\n            } else {\n              // 401 and 404 are expected.\n              if (xhr.status !== 401 && xhr.status !== 404) {\n                warn(\n                  'Got unsuccessful REST response for ' +\n                    url +\n                    ' Status: ' +\n                    xhr.status\n                );\n              }\n              callback(xhr.status);\n            }\n            callback = null;\n          }\n        };\n\n        xhr.open('GET', url, /*asynchronous=*/ true);\n        xhr.send();\n      });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}