{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"../util/util\");\n/**\n * The event queue serves a few purposes:\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\n *    events being queued.\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\n *    left off, ensuring that the events are still raised synchronously and in order.\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\n *    events are raised synchronously.\n *\n * NOTE: This can all go away if/when we move to async events.\n *\n * @constructor\n */\nvar EventQueue = /** @class */function () {\n  function EventQueue() {\n    /**\n     * @private\n     * @type {!Array.<EventList>}\n     */\n    this.eventLists_ = [];\n    /**\n     * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\n     * @private\n     * @type {!number}\n     */\n    this.recursionDepth_ = 0;\n  }\n  /**\n   * @param {!Array.<Event>} eventDataList The new events to queue.\n   */\n  EventQueue.prototype.queueEvents = function (eventDataList) {\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n    var currList = null;\n    for (var i = 0; i < eventDataList.length; i++) {\n      var eventData = eventDataList[i];\n      var eventPath = eventData.getPath();\n      if (currList !== null && !eventPath.equals(currList.getPath())) {\n        this.eventLists_.push(currList);\n        currList = null;\n      }\n      if (currList === null) {\n        currList = new EventList(eventPath);\n      }\n      currList.add(eventData);\n    }\n    if (currList) {\n      this.eventLists_.push(currList);\n    }\n  };\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones)\n   * for the specified path.\n   *\n   * It is assumed that the new events are all for the specified path.\n   *\n   * @param {!Path} path The path to raise events for.\n   * @param {!Array.<Event>} eventDataList The new events to raise.\n   */\n  EventQueue.prototype.raiseEventsAtPath = function (path, eventDataList) {\n    this.queueEvents(eventDataList);\n    this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {\n      return eventPath.equals(path);\n    });\n  };\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones) for\n   * locations related to the specified change path (i.e. all ancestors and descendants).\n   *\n   * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\n   *\n   * @param {!Path} changedPath The path to raise events for.\n   * @param {!Array.<!Event>} eventDataList The events to raise\n   */\n  EventQueue.prototype.raiseEventsForChangedPath = function (changedPath, eventDataList) {\n    this.queueEvents(eventDataList);\n    this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {\n      return eventPath.contains(changedPath) || changedPath.contains(eventPath);\n    });\n  };\n  /**\n   * @param {!function(!Path):boolean} predicate\n   * @private\n   */\n  EventQueue.prototype.raiseQueuedEventsMatchingPredicate_ = function (predicate) {\n    this.recursionDepth_++;\n    var sentAll = true;\n    for (var i = 0; i < this.eventLists_.length; i++) {\n      var eventList = this.eventLists_[i];\n      if (eventList) {\n        var eventPath = eventList.getPath();\n        if (predicate(eventPath)) {\n          this.eventLists_[i].raise();\n          this.eventLists_[i] = null;\n        } else {\n          sentAll = false;\n        }\n      }\n    }\n    if (sentAll) {\n      this.eventLists_ = [];\n    }\n    this.recursionDepth_--;\n  };\n  return EventQueue;\n}();\nexports.EventQueue = EventQueue;\n/**\n * @param {!Path} path\n * @constructor\n */\nvar EventList = /** @class */function () {\n  function EventList(path_) {\n    this.path_ = path_;\n    /**\n     * @type {!Array.<Event>}\n     * @private\n     */\n    this.events_ = [];\n  }\n  /**\n   * @param {!Event} eventData\n   */\n  EventList.prototype.add = function (eventData) {\n    this.events_.push(eventData);\n  };\n  /**\n   * Iterates through the list and raises each event\n   */\n  EventList.prototype.raise = function () {\n    for (var i = 0; i < this.events_.length; i++) {\n      var eventData = this.events_[i];\n      if (eventData !== null) {\n        this.events_[i] = null;\n        var eventFn = eventData.getEventRunner();\n        if (util_1.logger) {\n          util_1.log('event: ' + eventData.toString());\n        }\n        util_1.exceptionGuard(eventFn);\n      }\n    }\n  };\n  /**\n   * @return {!Path}\n   */\n  EventList.prototype.getPath = function () {\n    return this.path_;\n  };\n  return EventList;\n}();\nexports.EventList = EventList;","map":{"version":3,"mappings":"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","names":["EventQueue","eventDataList","currList","i","length","eventData","eventPath","getPath","equals","eventLists_","push","EventList","add","path","queueEvents","raiseQueuedEventsMatchingPredicate_","changedPath","contains","predicate","recursionDepth_","sentAll","eventList","raise","exports","path_","events_","eventFn","getEventRunner","util_1","toString"],"sources":["../src/core/view/EventQueue.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from '../util/Path';\nimport { log, logger, exceptionGuard } from '../util/util';\nimport { Event } from './Event';\n\n/**\n * The event queue serves a few purposes:\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\n *    events being queued.\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\n *    left off, ensuring that the events are still raised synchronously and in order.\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\n *    events are raised synchronously.\n *\n * NOTE: This can all go away if/when we move to async events.\n *\n * @constructor\n */\nexport class EventQueue {\n  /**\n   * @private\n   * @type {!Array.<EventList>}\n   */\n  private eventLists_: EventList[] = [];\n\n  /**\n   * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\n   * @private\n   * @type {!number}\n   */\n  private recursionDepth_ = 0;\n\n  /**\n   * @param {!Array.<Event>} eventDataList The new events to queue.\n   */\n  queueEvents(eventDataList: Event[]) {\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n    let currList = null;\n    for (let i = 0; i < eventDataList.length; i++) {\n      const eventData = eventDataList[i];\n      const eventPath = eventData.getPath();\n      if (currList !== null && !eventPath.equals(currList.getPath())) {\n        this.eventLists_.push(currList);\n        currList = null;\n      }\n\n      if (currList === null) {\n        currList = new EventList(eventPath);\n      }\n\n      currList.add(eventData);\n    }\n    if (currList) {\n      this.eventLists_.push(currList);\n    }\n  }\n\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones)\n   * for the specified path.\n   *\n   * It is assumed that the new events are all for the specified path.\n   *\n   * @param {!Path} path The path to raise events for.\n   * @param {!Array.<Event>} eventDataList The new events to raise.\n   */\n  raiseEventsAtPath(path: Path, eventDataList: Event[]) {\n    this.queueEvents(eventDataList);\n    this.raiseQueuedEventsMatchingPredicate_((eventPath: Path) =>\n      eventPath.equals(path)\n    );\n  }\n\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones) for\n   * locations related to the specified change path (i.e. all ancestors and descendants).\n   *\n   * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\n   *\n   * @param {!Path} changedPath The path to raise events for.\n   * @param {!Array.<!Event>} eventDataList The events to raise\n   */\n  raiseEventsForChangedPath(changedPath: Path, eventDataList: Event[]) {\n    this.queueEvents(eventDataList);\n\n    this.raiseQueuedEventsMatchingPredicate_((eventPath: Path) => {\n      return eventPath.contains(changedPath) || changedPath.contains(eventPath);\n    });\n  }\n\n  /**\n   * @param {!function(!Path):boolean} predicate\n   * @private\n   */\n  private raiseQueuedEventsMatchingPredicate_(\n    predicate: (path: Path) => boolean\n  ) {\n    this.recursionDepth_++;\n\n    let sentAll = true;\n    for (let i = 0; i < this.eventLists_.length; i++) {\n      const eventList = this.eventLists_[i];\n      if (eventList) {\n        const eventPath = eventList.getPath();\n        if (predicate(eventPath)) {\n          this.eventLists_[i].raise();\n          this.eventLists_[i] = null;\n        } else {\n          sentAll = false;\n        }\n      }\n    }\n\n    if (sentAll) {\n      this.eventLists_ = [];\n    }\n\n    this.recursionDepth_--;\n  }\n}\n\n/**\n * @param {!Path} path\n * @constructor\n */\nexport class EventList {\n  /**\n   * @type {!Array.<Event>}\n   * @private\n   */\n  private events_: Event[] = [];\n\n  constructor(private readonly path_: Path) {}\n\n  /**\n   * @param {!Event} eventData\n   */\n  add(eventData: Event) {\n    this.events_.push(eventData);\n  }\n\n  /**\n   * Iterates through the list and raises each event\n   */\n  raise() {\n    for (let i = 0; i < this.events_.length; i++) {\n      const eventData = this.events_[i];\n      if (eventData !== null) {\n        this.events_[i] = null;\n        const eventFn = eventData.getEventRunner();\n        if (logger) {\n          log('event: ' + eventData.toString());\n        }\n        exceptionGuard(eventFn);\n      }\n    }\n  }\n\n  /**\n   * @return {!Path}\n   */\n  getPath(): Path {\n    return this.path_;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}