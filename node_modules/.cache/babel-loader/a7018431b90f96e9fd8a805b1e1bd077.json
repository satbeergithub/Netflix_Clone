{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * An iterator over an LLRBNode.\n */\nvar SortedMapIterator = /** @class */function () {\n  /**\n   * @template K, V, T\n   * @param {LLRBNode|LLRBEmptyNode} node Node to iterate.\n   * @param {?K} startKey\n   * @param {function(K, K): number} comparator\n   * @param {boolean} isReverse_ Whether or not to iterate in reverse\n   * @param {(function(K, V):T)=} resultGenerator_\n   */\n  function SortedMapIterator(node, startKey, comparator, isReverse_, resultGenerator_) {\n    if (resultGenerator_ === void 0) {\n      resultGenerator_ = null;\n    }\n    this.isReverse_ = isReverse_;\n    this.resultGenerator_ = resultGenerator_;\n    /** @private\n     * @type {Array.<!LLRBNode>}\n     */\n    this.nodeStack_ = [];\n    var cmp = 1;\n    while (!node.isEmpty()) {\n      node = node;\n      cmp = startKey ? comparator(node.key, startKey) : 1;\n      // flip the comparison if we're going in reverse\n      if (isReverse_) cmp *= -1;\n      if (cmp < 0) {\n        // This node is less than our start key. ignore it\n        if (this.isReverse_) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      } else if (cmp === 0) {\n        // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\n        this.nodeStack_.push(node);\n        break;\n      } else {\n        // This node is greater than our start key, add it to the stack and move to the next one\n        this.nodeStack_.push(node);\n        if (this.isReverse_) {\n          node = node.right;\n        } else {\n          node = node.left;\n        }\n      }\n    }\n  }\n  SortedMapIterator.prototype.getNext = function () {\n    if (this.nodeStack_.length === 0) return null;\n    var node = this.nodeStack_.pop();\n    var result;\n    if (this.resultGenerator_) result = this.resultGenerator_(node.key, node.value);else result = {\n      key: node.key,\n      value: node.value\n    };\n    if (this.isReverse_) {\n      node = node.left;\n      while (!node.isEmpty()) {\n        this.nodeStack_.push(node);\n        node = node.right;\n      }\n    } else {\n      node = node.right;\n      while (!node.isEmpty()) {\n        this.nodeStack_.push(node);\n        node = node.left;\n      }\n    }\n    return result;\n  };\n  SortedMapIterator.prototype.hasNext = function () {\n    return this.nodeStack_.length > 0;\n  };\n  SortedMapIterator.prototype.peek = function () {\n    if (this.nodeStack_.length === 0) return null;\n    var node = this.nodeStack_[this.nodeStack_.length - 1];\n    if (this.resultGenerator_) {\n      return this.resultGenerator_(node.key, node.value);\n    } else {\n      return {\n        key: node.key,\n        value: node.value\n      };\n    }\n  };\n  return SortedMapIterator;\n}();\nexports.SortedMapIterator = SortedMapIterator;\n/**\n * Represents a node in a Left-leaning Red-Black tree.\n */\nvar LLRBNode = /** @class */function () {\n  /**\n   * @template K, V\n   * @param {!K} key Key associated with this node.\n   * @param {!V} value Value associated with this node.\n   * @param {?boolean} color Whether this node is red.\n   * @param {?(LLRBNode|LLRBEmptyNode)=} left Left child.\n   * @param {?(LLRBNode|LLRBEmptyNode)=} right Right child.\n   */\n  function LLRBNode(key, value, color, left, right) {\n    this.key = key;\n    this.value = value;\n    this.color = color != null ? color : LLRBNode.RED;\n    this.left = left != null ? left : SortedMap.EMPTY_NODE;\n    this.right = right != null ? right : SortedMap.EMPTY_NODE;\n  }\n  /**\n   * Returns a copy of the current node, optionally replacing pieces of it.\n   *\n   * @param {?K} key New key for the node, or null.\n   * @param {?V} value New value for the node, or null.\n   * @param {?boolean} color New color for the node, or null.\n   * @param {?LLRBNode|LLRBEmptyNode} left New left child for the node, or null.\n   * @param {?LLRBNode|LLRBEmptyNode} right New right child for the node, or null.\n   * @return {!LLRBNode} The node copy.\n   */\n  LLRBNode.prototype.copy = function (key, value, color, left, right) {\n    return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n  };\n  /**\n   * @return {number} The total number of nodes in the tree.\n   */\n  LLRBNode.prototype.count = function () {\n    return this.left.count() + 1 + this.right.count();\n  };\n  /**\n   * @return {boolean} True if the tree is empty.\n   */\n  LLRBNode.prototype.isEmpty = function () {\n    return false;\n  };\n  /**\n   * Traverses the tree in key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called for each\n   *   node.  If it returns true, traversal is aborted.\n   * @return {*} The first truthy value returned by action, or the last falsey\n   *   value returned by action\n   */\n  LLRBNode.prototype.inorderTraversal = function (action) {\n    return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);\n  };\n  /**\n   * Traverses the tree in reverse key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!Object, !Object)} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {*} True if traversal was aborted.\n   */\n  LLRBNode.prototype.reverseTraversal = function (action) {\n    return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);\n  };\n  /**\n   * @return {!Object} The minimum node in the tree.\n   * @private\n   */\n  LLRBNode.prototype.min_ = function () {\n    if (this.left.isEmpty()) {\n      return this;\n    } else {\n      return this.left.min_();\n    }\n  };\n  /**\n   * @return {!K} The maximum key in the tree.\n   */\n  LLRBNode.prototype.minKey = function () {\n    return this.min_().key;\n  };\n  /**\n   * @return {!K} The maximum key in the tree.\n   */\n  LLRBNode.prototype.maxKey = function () {\n    if (this.right.isEmpty()) {\n      return this.key;\n    } else {\n      return this.right.maxKey();\n    }\n  };\n  /**\n   *\n   * @param {!Object} key Key to insert.\n   * @param {!Object} value Value to insert.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode} New tree, with the key/value added.\n   */\n  LLRBNode.prototype.insert = function (key, value, comparator) {\n    var cmp, n;\n    n = this;\n    cmp = comparator(key, n.key);\n    if (cmp < 0) {\n      n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n    } else if (cmp === 0) {\n      n = n.copy(null, value, null, null, null);\n    } else {\n      n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n    }\n    return n.fixUp_();\n  };\n  /**\n   * @private\n   * @return {!LLRBNode|LLRBEmptyNode} New tree, with the minimum key removed.\n   */\n  LLRBNode.prototype.removeMin_ = function () {\n    if (this.left.isEmpty()) {\n      return SortedMap.EMPTY_NODE;\n    }\n    var n = this;\n    if (!n.left.isRed_() && !n.left.left.isRed_()) n = n.moveRedLeft_();\n    n = n.copy(null, null, null, n.left.removeMin_(), null);\n    return n.fixUp_();\n  };\n  /**\n   * @param {!Object} key The key of the item to remove.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode|LLRBEmptyNode} New tree, with the specified item removed.\n   */\n  LLRBNode.prototype.remove = function (key, comparator) {\n    var n, smallest;\n    n = this;\n    if (comparator(key, n.key) < 0) {\n      if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\n        n = n.moveRedLeft_();\n      }\n      n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n    } else {\n      if (n.left.isRed_()) n = n.rotateRight_();\n      if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\n        n = n.moveRedRight_();\n      }\n      if (comparator(key, n.key) === 0) {\n        if (n.right.isEmpty()) {\n          return SortedMap.EMPTY_NODE;\n        } else {\n          smallest = n.right.min_();\n          n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());\n        }\n      }\n      n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n    }\n    return n.fixUp_();\n  };\n  /**\n   * @private\n   * @return {boolean} Whether this is a RED node.\n   */\n  LLRBNode.prototype.isRed_ = function () {\n    return this.color;\n  };\n  /**\n   * @private\n   * @return {!LLRBNode} New tree after performing any needed rotations.\n   */\n  LLRBNode.prototype.fixUp_ = function () {\n    var n = this;\n    if (n.right.isRed_() && !n.left.isRed_()) n = n.rotateLeft_();\n    if (n.left.isRed_() && n.left.left.isRed_()) n = n.rotateRight_();\n    if (n.left.isRed_() && n.right.isRed_()) n = n.colorFlip_();\n    return n;\n  };\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after moveRedLeft.\n   */\n  LLRBNode.prototype.moveRedLeft_ = function () {\n    var n = this.colorFlip_();\n    if (n.right.left.isRed_()) {\n      n = n.copy(null, null, null, null, n.right.rotateRight_());\n      n = n.rotateLeft_();\n      n = n.colorFlip_();\n    }\n    return n;\n  };\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after moveRedRight.\n   */\n  LLRBNode.prototype.moveRedRight_ = function () {\n    var n = this.colorFlip_();\n    if (n.left.left.isRed_()) {\n      n = n.rotateRight_();\n      n = n.colorFlip_();\n    }\n    return n;\n  };\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after rotateLeft.\n   */\n  LLRBNode.prototype.rotateLeft_ = function () {\n    var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n    return this.right.copy(null, null, this.color, nl, null);\n  };\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after rotateRight.\n   */\n  LLRBNode.prototype.rotateRight_ = function () {\n    var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n    return this.left.copy(null, null, this.color, null, nr);\n  };\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after colorFlip.\n   */\n  LLRBNode.prototype.colorFlip_ = function () {\n    var left = this.left.copy(null, null, !this.left.color, null, null);\n    var right = this.right.copy(null, null, !this.right.color, null, null);\n    return this.copy(null, null, !this.color, left, right);\n  };\n  /**\n   * For testing.\n   *\n   * @private\n   * @return {boolean} True if all is well.\n   */\n  LLRBNode.prototype.checkMaxDepth_ = function () {\n    var blackDepth = this.check_();\n    return Math.pow(2.0, blackDepth) <= this.count() + 1;\n  };\n  /**\n   * @private\n   * @return {number} Not sure what this returns exactly. :-).\n   */\n  LLRBNode.prototype.check_ = function () {\n    var blackDepth;\n    if (this.isRed_() && this.left.isRed_()) {\n      throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');\n    }\n    if (this.right.isRed_()) {\n      throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');\n    }\n    blackDepth = this.left.check_();\n    if (blackDepth !== this.right.check_()) {\n      throw new Error('Black depths differ');\n    } else {\n      return blackDepth + (this.isRed_() ? 0 : 1);\n    }\n  };\n  LLRBNode.RED = true;\n  LLRBNode.BLACK = false;\n  return LLRBNode;\n}();\nexports.LLRBNode = LLRBNode;\n/**\n * Represents an empty node (a leaf node in the Red-Black Tree).\n */\nvar LLRBEmptyNode = /** @class */function () {\n  function LLRBEmptyNode() {}\n  /**\n   * Returns a copy of the current node.\n   *\n   * @return {!LLRBEmptyNode} The node copy.\n   */\n  LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {\n    return this;\n  };\n  /**\n   * Returns a copy of the tree, with the specified key/value added.\n   *\n   * @param {!K} key Key to be added.\n   * @param {!V} value Value to be added.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode} New tree, with item added.\n   */\n  LLRBEmptyNode.prototype.insert = function (key, value, comparator) {\n    return new LLRBNode(key, value, null);\n  };\n  /**\n   * Returns a copy of the tree, with the specified key removed.\n   *\n   * @param {!K} key The key to remove.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBEmptyNode} New tree, with item removed.\n   */\n  LLRBEmptyNode.prototype.remove = function (key, comparator) {\n    return this;\n  };\n  /**\n   * @return {number} The total number of nodes in the tree.\n   */\n  LLRBEmptyNode.prototype.count = function () {\n    return 0;\n  };\n  /**\n   * @return {boolean} True if the tree is empty.\n   */\n  LLRBEmptyNode.prototype.isEmpty = function () {\n    return true;\n  };\n  /**\n   * Traverses the tree in key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {boolean} True if traversal was aborted.\n   */\n  LLRBEmptyNode.prototype.inorderTraversal = function (action) {\n    return false;\n  };\n  /**\n   * Traverses the tree in reverse key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V)} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {boolean} True if traversal was aborted.\n   */\n  LLRBEmptyNode.prototype.reverseTraversal = function (action) {\n    return false;\n  };\n  /**\n   * @return {null}\n   */\n  LLRBEmptyNode.prototype.minKey = function () {\n    return null;\n  };\n  /**\n   * @return {null}\n   */\n  LLRBEmptyNode.prototype.maxKey = function () {\n    return null;\n  };\n  /**\n   * @private\n   * @return {number} Not sure what this returns exactly. :-).\n   */\n  LLRBEmptyNode.prototype.check_ = function () {\n    return 0;\n  };\n  /**\n   * @private\n   * @return {boolean} Whether this node is red.\n   */\n  LLRBEmptyNode.prototype.isRed_ = function () {\n    return false;\n  };\n  return LLRBEmptyNode;\n}();\nexports.LLRBEmptyNode = LLRBEmptyNode;\n/**\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\n * tree.\n */\nvar SortedMap = /** @class */function () {\n  /**\n   * @template K, V\n   * @param {function(K, K):number} comparator_ Key comparator.\n   * @param {LLRBNode=} root_ (Optional) Root node for the map.\n   */\n  function SortedMap(comparator_, root_) {\n    if (root_ === void 0) {\n      root_ = SortedMap.EMPTY_NODE;\n    }\n    this.comparator_ = comparator_;\n    this.root_ = root_;\n  }\n  /**\n   * Returns a copy of the map, with the specified key/value added or replaced.\n   * (TODO: We should perhaps rename this method to 'put')\n   *\n   * @param {!K} key Key to be added.\n   * @param {!V} value Value to be added.\n   * @return {!SortedMap.<K, V>} New map, with item added.\n   */\n  SortedMap.prototype.insert = function (key, value) {\n    return new SortedMap(this.comparator_, this.root_.insert(key, value, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));\n  };\n  /**\n   * Returns a copy of the map, with the specified key removed.\n   *\n   * @param {!K} key The key to remove.\n   * @return {!SortedMap.<K, V>} New map, with item removed.\n   */\n  SortedMap.prototype.remove = function (key) {\n    return new SortedMap(this.comparator_, this.root_.remove(key, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));\n  };\n  /**\n   * Returns the value of the node with the given key, or null.\n   *\n   * @param {!K} key The key to look up.\n   * @return {?V} The value of the node with the given key, or null if the\n   * key doesn't exist.\n   */\n  SortedMap.prototype.get = function (key) {\n    var cmp;\n    var node = this.root_;\n    while (!node.isEmpty()) {\n      cmp = this.comparator_(key, node.key);\n      if (cmp === 0) {\n        return node.value;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        node = node.right;\n      }\n    }\n    return null;\n  };\n  /**\n   * Returns the key of the item *before* the specified key, or null if key is the first item.\n   * @param {K} key The key to find the predecessor of\n   * @return {?K} The predecessor key.\n   */\n  SortedMap.prototype.getPredecessorKey = function (key) {\n    var cmp,\n      node = this.root_,\n      rightParent = null;\n    while (!node.isEmpty()) {\n      cmp = this.comparator_(key, node.key);\n      if (cmp === 0) {\n        if (!node.left.isEmpty()) {\n          node = node.left;\n          while (!node.right.isEmpty()) {\n            node = node.right;\n          }\n          return node.key;\n        } else if (rightParent) {\n          return rightParent.key;\n        } else {\n          return null; // first item.\n        }\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        rightParent = node;\n        node = node.right;\n      }\n    }\n    throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');\n  };\n  /**\n   * @return {boolean} True if the map is empty.\n   */\n  SortedMap.prototype.isEmpty = function () {\n    return this.root_.isEmpty();\n  };\n  /**\n   * @return {number} The total number of nodes in the map.\n   */\n  SortedMap.prototype.count = function () {\n    return this.root_.count();\n  };\n  /**\n   * @return {?K} The minimum key in the map.\n   */\n  SortedMap.prototype.minKey = function () {\n    return this.root_.minKey();\n  };\n  /**\n   * @return {?K} The maximum key in the map.\n   */\n  SortedMap.prototype.maxKey = function () {\n    return this.root_.maxKey();\n  };\n  /**\n   * Traverses the map in key order and calls the specified action function\n   * for each key/value pair.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called\n   * for each key/value pair.  If action returns true, traversal is aborted.\n   * @return {*} The first truthy value returned by action, or the last falsey\n   *   value returned by action\n   */\n  SortedMap.prototype.inorderTraversal = function (action) {\n    return this.root_.inorderTraversal(action);\n  };\n  /**\n   * Traverses the map in reverse key order and calls the specified action function\n   * for each key/value pair.\n   *\n   * @param {function(!Object, !Object)} action Callback function to be called\n   * for each key/value pair.  If action returns true, traversal is aborted.\n   * @return {*} True if the traversal was aborted.\n   */\n  SortedMap.prototype.reverseTraversal = function (action) {\n    return this.root_.reverseTraversal(action);\n  };\n  /**\n   * Returns an iterator over the SortedMap.\n   * @template T\n   * @param {(function(K, V):T)=} resultGenerator\n   * @return {SortedMapIterator.<K, V, T>} The iterator.\n   */\n  SortedMap.prototype.getIterator = function (resultGenerator) {\n    return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);\n  };\n  SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {\n    return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);\n  };\n  SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {\n    return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);\n  };\n  SortedMap.prototype.getReverseIterator = function (resultGenerator) {\n    return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);\n  };\n  /**\n   * Always use the same empty node, to reduce memory.\n   * @const\n   */\n  SortedMap.EMPTY_NODE = new LLRBEmptyNode();\n  return SortedMap;\n}();\nexports.SortedMap = SortedMap;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;AAsCA;;;AAGA;EAME;;;;;;;;EAQA,2BACEA,IAA0C,EAC1CC,QAAkB,EAClBC,UAAyB,EACjBC,UAAmB,EACnBC,gBAAmD;IAAnD;MAAAA,uBAAmD;IAAA;IADnD,eAAU,GAAVD,UAAU;IACV,qBAAgB,GAAhBC,gBAAgB;IAlB1B;;;IAGQ,eAAU,GAA6C,EAAE;IAiB/D,IAAIC,GAAG,GAAG,CAAC;IACX,OAAO,CAACL,IAAI,CAACM,OAAO,EAAE,EAAE;MACtBN,IAAI,GAAGA,IAAsB;MAC7BK,GAAG,GAAGJ,QAAQ,GAAGC,UAAU,CAACF,IAAI,CAACO,GAAG,EAAEN,QAAQ,CAAC,GAAG,CAAC;MACnD;MACA,IAAIE,UAAU,EAAEE,GAAG,IAAI,CAAC,CAAC;MAEzB,IAAIA,GAAG,GAAG,CAAC,EAAE;QACX;QACA,IAAI,IAAI,CAACF,UAAU,EAAE;UACnBH,IAAI,GAAGA,IAAI,CAACQ,IAAI;QAClB,CAAC,MAAM;UACLR,IAAI,GAAGA,IAAI,CAACS,KAAK;QACnB;MACF,CAAC,MAAM,IAAIJ,GAAG,KAAK,CAAC,EAAE;QACpB;QACA,IAAI,CAACK,UAAU,CAACC,IAAI,CAACX,IAAI,CAAC;QAC1B;MACF,CAAC,MAAM;QACL;QACA,IAAI,CAACU,UAAU,CAACC,IAAI,CAACX,IAAI,CAAC;QAC1B,IAAI,IAAI,CAACG,UAAU,EAAE;UACnBH,IAAI,GAAGA,IAAI,CAACS,KAAK;QACnB,CAAC,MAAM;UACLT,IAAI,GAAGA,IAAI,CAACQ,IAAI;QAClB;MACF;IACF;EACF;EAEAI,mCAAO,GAAP;IACE,IAAI,IAAI,CAACF,UAAU,CAACG,MAAM,KAAK,CAAC,EAAE,OAAO,IAAI;IAE7C,IAAIb,IAAI,GAAG,IAAI,CAACU,UAAU,CAACI,GAAG,EAAE;IAChC,IAAIC,MAAS;IACb,IAAI,IAAI,CAACX,gBAAgB,EACvBW,MAAM,GAAG,IAAI,CAACX,gBAAgB,CAACJ,IAAI,CAACO,GAAG,EAAEP,IAAI,CAACgB,KAAK,CAAC,CAAC,KAClDD,MAAM,GAAG;MAAER,GAAG,EAAEP,IAAI,CAACO,GAAG;MAAES,KAAK,EAAEhB,IAAI,CAACgB;IAAK,CAAS;IAEzD,IAAI,IAAI,CAACb,UAAU,EAAE;MACnBH,IAAI,GAAGA,IAAI,CAACQ,IAAI;MAChB,OAAO,CAACR,IAAI,CAACM,OAAO,EAAE,EAAE;QACtB,IAAI,CAACI,UAAU,CAACC,IAAI,CAACX,IAAI,CAAC;QAC1BA,IAAI,GAAGA,IAAI,CAACS,KAAK;MACnB;IACF,CAAC,MAAM;MACLT,IAAI,GAAGA,IAAI,CAACS,KAAK;MACjB,OAAO,CAACT,IAAI,CAACM,OAAO,EAAE,EAAE;QACtB,IAAI,CAACI,UAAU,CAACC,IAAI,CAACX,IAAI,CAAC;QAC1BA,IAAI,GAAGA,IAAI,CAACQ,IAAI;MAClB;IACF;IAEA,OAAOO,MAAM;EACf,CAAC;EAEDH,mCAAO,GAAP;IACE,OAAO,IAAI,CAACF,UAAU,CAACG,MAAM,GAAG,CAAC;EACnC,CAAC;EAEDD,gCAAI,GAAJ;IACE,IAAI,IAAI,CAACF,UAAU,CAACG,MAAM,KAAK,CAAC,EAAE,OAAO,IAAI;IAE7C,IAAMb,IAAI,GAAG,IAAI,CAACU,UAAU,CAAC,IAAI,CAACA,UAAU,CAACG,MAAM,GAAG,CAAC,CAAC;IACxD,IAAI,IAAI,CAACT,gBAAgB,EAAE;MACzB,OAAO,IAAI,CAACA,gBAAgB,CAACJ,IAAI,CAACO,GAAG,EAAEP,IAAI,CAACgB,KAAK,CAAC;IACpD,CAAC,MAAM;MACL,OAAO;QAAET,GAAG,EAAEP,IAAI,CAACO,GAAG;QAAES,KAAK,EAAEhB,IAAI,CAACgB;MAAK,CAAS;IACpD;EACF,CAAC;EACH,wBAAC;AAAD,CA3FA,EA2FC;AA3FYC;AA6Fb;;;AAGA;EAKE;;;;;;;;EAQA,kBACSV,GAAM,EACNS,KAAQ,EACfE,KAAqB,EACrBV,IAAkD,EAClDC,KAAmD;IAJ5C,QAAG,GAAHF,GAAG;IACH,UAAK,GAALS,KAAK;IAKZ,IAAI,CAACE,KAAK,GAAGA,KAAK,IAAI,IAAI,GAAGA,KAAK,GAAGC,QAAQ,CAACC,GAAG;IACjD,IAAI,CAACZ,IAAI,GACPA,IAAI,IAAI,IAAI,GAAGA,IAAI,GAAIa,SAAS,CAACC,UAAkC;IACrE,IAAI,CAACb,KAAK,GACRA,KAAK,IAAI,IAAI,GAAGA,KAAK,GAAIY,SAAS,CAACC,UAAkC;EACzE;EAKA;;;;;;;;;;EAUAH,uBAAI,GAAJ,UACEZ,GAAa,EACbS,KAAe,EACfE,KAAqB,EACrBV,IAAiD,EACjDC,KAAkD;IAElD,OAAO,IAAIU,QAAQ,CACjBZ,GAAG,IAAI,IAAI,GAAGA,GAAG,GAAG,IAAI,CAACA,GAAG,EAC5BS,KAAK,IAAI,IAAI,GAAGA,KAAK,GAAG,IAAI,CAACA,KAAK,EAClCE,KAAK,IAAI,IAAI,GAAGA,KAAK,GAAG,IAAI,CAACA,KAAK,EAClCV,IAAI,IAAI,IAAI,GAAGA,IAAI,GAAG,IAAI,CAACA,IAAI,EAC/BC,KAAK,IAAI,IAAI,GAAGA,KAAK,GAAG,IAAI,CAACA,KAAK,CACnC;EACH,CAAC;EAED;;;EAGAU,wBAAK,GAAL;IACE,OAAO,IAAI,CAACX,IAAI,CAACe,KAAK,EAAE,GAAG,CAAC,GAAG,IAAI,CAACd,KAAK,CAACc,KAAK,EAAE;EACnD,CAAC;EAED;;;EAGAJ,0BAAO,GAAP;IACE,OAAO,KAAK;EACd,CAAC;EAED;;;;;;;;;EASAA,mCAAgB,GAAhB,UAAiBK,MAA2B;IAC1C,OACE,IAAI,CAAChB,IAAI,CAACiB,gBAAgB,CAACD,MAAM,CAAC,IAClCA,MAAM,CAAC,IAAI,CAACjB,GAAG,EAAE,IAAI,CAACS,KAAK,CAAC,IAC5B,IAAI,CAACP,KAAK,CAACgB,gBAAgB,CAACD,MAAM,CAAC;EAEvC,CAAC;EAED;;;;;;;;EAQAL,mCAAgB,GAAhB,UAAiBK,MAA4B;IAC3C,OACE,IAAI,CAACf,KAAK,CAACiB,gBAAgB,CAACF,MAAM,CAAC,IACnCA,MAAM,CAAC,IAAI,CAACjB,GAAG,EAAE,IAAI,CAACS,KAAK,CAAC,IAC5B,IAAI,CAACR,IAAI,CAACkB,gBAAgB,CAACF,MAAM,CAAC;EAEtC,CAAC;EAED;;;;EAIQL,uBAAI,GAAZ;IACE,IAAI,IAAI,CAACX,IAAI,CAACF,OAAO,EAAE,EAAE;MACvB,OAAO,IAAI;IACb,CAAC,MAAM;MACL,OAAQ,IAAI,CAACE,IAAuB,CAACmB,IAAI,EAAE;IAC7C;EACF,CAAC;EAED;;;EAGAR,yBAAM,GAAN;IACE,OAAO,IAAI,CAACQ,IAAI,EAAE,CAACpB,GAAG;EACxB,CAAC;EAED;;;EAGAY,yBAAM,GAAN;IACE,IAAI,IAAI,CAACV,KAAK,CAACH,OAAO,EAAE,EAAE;MACxB,OAAO,IAAI,CAACC,GAAG;IACjB,CAAC,MAAM;MACL,OAAO,IAAI,CAACE,KAAK,CAACmB,MAAM,EAAE;IAC5B;EACF,CAAC;EAED;;;;;;;EAOAT,yBAAM,GAAN,UAAOZ,GAAM,EAAES,KAAQ,EAAEd,UAAyB;IAChD,IAAIG,GAAG,EAAEwB,CAAC;IACVA,CAAC,GAAG,IAAI;IACRxB,GAAG,GAAGH,UAAU,CAACK,GAAG,EAAEsB,CAAC,CAACtB,GAAG,CAAC;IAC5B,IAAIF,GAAG,GAAG,CAAC,EAAE;MACXwB,CAAC,GAAGA,CAAC,CAACC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAED,CAAC,CAACrB,IAAI,CAACuB,MAAM,CAACxB,GAAG,EAAES,KAAK,EAAEd,UAAU,CAAC,EAAE,IAAI,CAAC;IAC3E,CAAC,MAAM,IAAIG,GAAG,KAAK,CAAC,EAAE;MACpBwB,CAAC,GAAGA,CAAC,CAACC,IAAI,CAAC,IAAI,EAAEd,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IAC3C,CAAC,MAAM;MACLa,CAAC,GAAGA,CAAC,CAACC,IAAI,CACR,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,IAAI,EACJD,CAAC,CAACpB,KAAK,CAACsB,MAAM,CAACxB,GAAG,EAAES,KAAK,EAAEd,UAAU,CAAC,CACvC;IACH;IACA,OAAO2B,CAAC,CAACG,MAAM,EAAE;EACnB,CAAC;EAED;;;;EAIQb,6BAAU,GAAlB;IACE,IAAI,IAAI,CAACX,IAAI,CAACF,OAAO,EAAE,EAAE;MACvB,OAAOe,SAAS,CAACC,UAAiC;IACpD;IACA,IAAIO,CAAC,GAAmB,IAAI;IAC5B,IAAI,CAACA,CAAC,CAACrB,IAAI,CAACyB,MAAM,EAAE,IAAI,CAACJ,CAAC,CAACrB,IAAI,CAACA,IAAI,CAACyB,MAAM,EAAE,EAAEJ,CAAC,GAAGA,CAAC,CAACK,YAAY,EAAE;IACnEL,CAAC,GAAGA,CAAC,CAACC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAGD,CAAC,CAACrB,IAAuB,CAAC2B,UAAU,EAAE,EAAE,IAAI,CAAC;IAC3E,OAAON,CAAC,CAACG,MAAM,EAAE;EACnB,CAAC;EAED;;;;;EAKAb,yBAAM,GAAN,UACEZ,GAAM,EACNL,UAAyB;IAEzB,IAAI2B,CAAC,EAAEO,QAAQ;IACfP,CAAC,GAAG,IAAI;IACR,IAAI3B,UAAU,CAACK,GAAG,EAAEsB,CAAC,CAACtB,GAAG,CAAC,GAAG,CAAC,EAAE;MAC9B,IAAI,CAACsB,CAAC,CAACrB,IAAI,CAACF,OAAO,EAAE,IAAI,CAACuB,CAAC,CAACrB,IAAI,CAACyB,MAAM,EAAE,IAAI,CAACJ,CAAC,CAACrB,IAAI,CAACA,IAAI,CAACyB,MAAM,EAAE,EAAE;QAClEJ,CAAC,GAAGA,CAAC,CAACK,YAAY,EAAE;MACtB;MACAL,CAAC,GAAGA,CAAC,CAACC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAED,CAAC,CAACrB,IAAI,CAAC6B,MAAM,CAAC9B,GAAG,EAAEL,UAAU,CAAC,EAAE,IAAI,CAAC;IACpE,CAAC,MAAM;MACL,IAAI2B,CAAC,CAACrB,IAAI,CAACyB,MAAM,EAAE,EAAEJ,CAAC,GAAGA,CAAC,CAACS,YAAY,EAAE;MACzC,IAAI,CAACT,CAAC,CAACpB,KAAK,CAACH,OAAO,EAAE,IAAI,CAACuB,CAAC,CAACpB,KAAK,CAACwB,MAAM,EAAE,IAAI,CAACJ,CAAC,CAACpB,KAAK,CAACD,IAAI,CAACyB,MAAM,EAAE,EAAE;QACrEJ,CAAC,GAAGA,CAAC,CAACU,aAAa,EAAE;MACvB;MACA,IAAIrC,UAAU,CAACK,GAAG,EAAEsB,CAAC,CAACtB,GAAG,CAAC,KAAK,CAAC,EAAE;QAChC,IAAIsB,CAAC,CAACpB,KAAK,CAACH,OAAO,EAAE,EAAE;UACrB,OAAOe,SAAS,CAACC,UAAiC;QACpD,CAAC,MAAM;UACLc,QAAQ,GAAIP,CAAC,CAACpB,KAAwB,CAACkB,IAAI,EAAE;UAC7CE,CAAC,GAAGA,CAAC,CAACC,IAAI,CACRM,QAAQ,CAAC7B,GAAG,EACZ6B,QAAQ,CAACpB,KAAK,EACd,IAAI,EACJ,IAAI,EACHa,CAAC,CAACpB,KAAwB,CAAC0B,UAAU,EAAE,CACzC;QACH;MACF;MACAN,CAAC,GAAGA,CAAC,CAACC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAED,CAAC,CAACpB,KAAK,CAAC4B,MAAM,CAAC9B,GAAG,EAAEL,UAAU,CAAC,CAAC;IACrE;IACA,OAAO2B,CAAC,CAACG,MAAM,EAAE;EACnB,CAAC;EAED;;;;EAIAb,yBAAM,GAAN;IACE,OAAO,IAAI,CAACD,KAAK;EACnB,CAAC;EAED;;;;EAIQC,yBAAM,GAAd;IACE,IAAIU,CAAC,GAAG,IAAW;IACnB,IAAIA,CAAC,CAACpB,KAAK,CAACwB,MAAM,EAAE,IAAI,CAACJ,CAAC,CAACrB,IAAI,CAACyB,MAAM,EAAE,EAAEJ,CAAC,GAAGA,CAAC,CAACW,WAAW,EAAE;IAC7D,IAAIX,CAAC,CAACrB,IAAI,CAACyB,MAAM,EAAE,IAAIJ,CAAC,CAACrB,IAAI,CAACA,IAAI,CAACyB,MAAM,EAAE,EAAEJ,CAAC,GAAGA,CAAC,CAACS,YAAY,EAAE;IACjE,IAAIT,CAAC,CAACrB,IAAI,CAACyB,MAAM,EAAE,IAAIJ,CAAC,CAACpB,KAAK,CAACwB,MAAM,EAAE,EAAEJ,CAAC,GAAGA,CAAC,CAACY,UAAU,EAAE;IAC3D,OAAOZ,CAAC;EACV,CAAC;EAED;;;;EAIQV,+BAAY,GAApB;IACE,IAAIU,CAAC,GAAG,IAAI,CAACY,UAAU,EAAE;IACzB,IAAIZ,CAAC,CAACpB,KAAK,CAACD,IAAI,CAACyB,MAAM,EAAE,EAAE;MACzBJ,CAAC,GAAGA,CAAC,CAACC,IAAI,CACR,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,IAAI,EACHD,CAAC,CAACpB,KAAwB,CAAC6B,YAAY,EAAE,CAC3C;MACDT,CAAC,GAAGA,CAAC,CAACW,WAAW,EAAE;MACnBX,CAAC,GAAGA,CAAC,CAACY,UAAU,EAAE;IACpB;IACA,OAAOZ,CAAC;EACV,CAAC;EAED;;;;EAIQV,gCAAa,GAArB;IACE,IAAIU,CAAC,GAAG,IAAI,CAACY,UAAU,EAAE;IACzB,IAAIZ,CAAC,CAACrB,IAAI,CAACA,IAAI,CAACyB,MAAM,EAAE,EAAE;MACxBJ,CAAC,GAAGA,CAAC,CAACS,YAAY,EAAE;MACpBT,CAAC,GAAGA,CAAC,CAACY,UAAU,EAAE;IACpB;IACA,OAAOZ,CAAC;EACV,CAAC;EAED;;;;EAIQV,8BAAW,GAAnB;IACE,IAAMuB,EAAE,GAAG,IAAI,CAACZ,IAAI,CAAC,IAAI,EAAE,IAAI,EAAEX,QAAQ,CAACC,GAAG,EAAE,IAAI,EAAE,IAAI,CAACX,KAAK,CAACD,IAAI,CAAC;IACrE,OAAO,IAAI,CAACC,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAACZ,KAAK,EAAEwB,EAAE,EAAE,IAAI,CAAmB;EAC5E,CAAC;EAED;;;;EAIQvB,+BAAY,GAApB;IACE,IAAMwB,EAAE,GAAG,IAAI,CAACb,IAAI,CAAC,IAAI,EAAE,IAAI,EAAEX,QAAQ,CAACC,GAAG,EAAE,IAAI,CAACZ,IAAI,CAACC,KAAK,EAAE,IAAI,CAAC;IACrE,OAAO,IAAI,CAACD,IAAI,CAACsB,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAACZ,KAAK,EAAE,IAAI,EAAEyB,EAAE,CAAmB;EAC3E,CAAC;EAED;;;;EAIQxB,6BAAU,GAAlB;IACE,IAAMX,IAAI,GAAG,IAAI,CAACA,IAAI,CAACsB,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,IAAI,CAACtB,IAAI,CAACU,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC;IACrE,IAAMT,KAAK,GAAG,IAAI,CAACA,KAAK,CAACqB,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,IAAI,CAACrB,KAAK,CAACS,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC;IACxE,OAAO,IAAI,CAACY,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,IAAI,CAACZ,KAAK,EAAEV,IAAI,EAAEC,KAAK,CAAC;EACxD,CAAC;EAED;;;;;;EAMQU,iCAAc,GAAtB;IACE,IAAMyB,UAAU,GAAG,IAAI,CAACC,MAAM,EAAE;IAChC,OAAOC,IAAI,CAACC,GAAG,CAAC,GAAG,EAAEH,UAAU,CAAC,IAAI,IAAI,CAACrB,KAAK,EAAE,GAAG,CAAC;EACtD,CAAC;EAED;;;;EAIAJ,yBAAM,GAAN;IACE,IAAIyB,UAAU;IACd,IAAI,IAAI,CAACX,MAAM,EAAE,IAAI,IAAI,CAACzB,IAAI,CAACyB,MAAM,EAAE,EAAE;MACvC,MAAM,IAAIe,KAAK,CACb,yBAAyB,GAAG,IAAI,CAACzC,GAAG,GAAG,GAAG,GAAG,IAAI,CAACS,KAAK,GAAG,GAAG,CAC9D;IACH;IACA,IAAI,IAAI,CAACP,KAAK,CAACwB,MAAM,EAAE,EAAE;MACvB,MAAM,IAAIe,KAAK,CACb,kBAAkB,GAAG,IAAI,CAACzC,GAAG,GAAG,GAAG,GAAG,IAAI,CAACS,KAAK,GAAG,UAAU,CAC9D;IACH;IACA4B,UAAU,GAAG,IAAI,CAACpC,IAAI,CAACqC,MAAM,EAAE;IAC/B,IAAID,UAAU,KAAK,IAAI,CAACnC,KAAK,CAACoC,MAAM,EAAE,EAAE;MACtC,MAAM,IAAIG,KAAK,CAAC,qBAAqB,CAAC;IACxC,CAAC,MAAM;MACL,OAAOJ,UAAU,IAAI,IAAI,CAACX,MAAM,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;IAC7C;EACF,CAAC;EA7SMd,YAAG,GAAG,IAAI;EACVA,cAAK,GAAG,KAAK;EA6StB,eAAC;CAzUD,EAyUC;AAzUYF;AA2Ub;;;AAGA;EAAA,0BAgHA;EAzGE;;;;;EAKAgC,4BAAI,GAAJ,UACE1C,GAAa,EACbS,KAAe,EACfE,KAAqB,EACrBV,IAAiD,EACjDC,KAAkD;IAElD,OAAO,IAAI;EACb,CAAC;EAED;;;;;;;;EAQAwC,8BAAM,GAAN,UAAO1C,GAAM,EAAES,KAAQ,EAAEd,UAAyB;IAChD,OAAO,IAAIiB,QAAQ,CAACZ,GAAG,EAAES,KAAK,EAAE,IAAI,CAAC;EACvC,CAAC;EAED;;;;;;;EAOAiC,8BAAM,GAAN,UAAO1C,GAAM,EAAEL,UAAyB;IACtC,OAAO,IAAI;EACb,CAAC;EAED;;;EAGA+C,6BAAK,GAAL;IACE,OAAO,CAAC;EACV,CAAC;EAED;;;EAGAA,+BAAO,GAAP;IACE,OAAO,IAAI;EACb,CAAC;EAED;;;;;;;;EAQAA,wCAAgB,GAAhB,UAAiBzB,MAA2B;IAC1C,OAAO,KAAK;EACd,CAAC;EAED;;;;;;;;EAQAyB,wCAAgB,GAAhB,UAAiBzB,MAA4B;IAC3C,OAAO,KAAK;EACd,CAAC;EAED;;;EAGAyB,8BAAM,GAAN;IACE,OAAO,IAAI;EACb,CAAC;EAED;;;EAGAA,8BAAM,GAAN;IACE,OAAO,IAAI;EACb,CAAC;EAED;;;;EAIAA,8BAAM,GAAN;IACE,OAAO,CAAC;EACV,CAAC;EAED;;;;EAIAA,8BAAM,GAAN;IACE,OAAO,KAAK;EACd,CAAC;EACH,oBAAC;AAAD,CAhHA,EAgHC;AAhHYhC;AAkHb;;;;AAIA;EAOE;;;;;EAKA,mBACUiC,WAA0B,EAC1BC,KAE6D;IAF7D;MAAAA,QAEkB9B,SAAS,CAACC,UAAiC;IAAA;IAH7D,gBAAW,GAAX4B,WAAW;IACX,UAAK,GAALC,KAAK;EAGZ;EAEH;;;;;;;;EAQA9B,0BAAM,GAAN,UAAOd,GAAM,EAAES,KAAQ;IACrB,OAAO,IAAIK,SAAS,CAClB,IAAI,CAAC6B,WAAW,EAChB,IAAI,CAACC,KAAK,CACPpB,MAAM,CAACxB,GAAG,EAAES,KAAK,EAAE,IAAI,CAACkC,WAAW,CAAC,CACpCpB,IAAI,CAAC,IAAI,EAAE,IAAI,EAAEX,QAAQ,CAACiC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAChD;EACH,CAAC;EAED;;;;;;EAMA/B,0BAAM,GAAN,UAAOd,GAAM;IACX,OAAO,IAAIc,SAAS,CAClB,IAAI,CAAC6B,WAAW,EAChB,IAAI,CAACC,KAAK,CACPd,MAAM,CAAC9B,GAAG,EAAE,IAAI,CAAC2C,WAAW,CAAC,CAC7BpB,IAAI,CAAC,IAAI,EAAE,IAAI,EAAEX,QAAQ,CAACiC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAChD;EACH,CAAC;EAED;;;;;;;EAOA/B,uBAAG,GAAH,UAAId,GAAM;IACR,IAAIF,GAAG;IACP,IAAIL,IAAI,GAAG,IAAI,CAACmD,KAAK;IACrB,OAAO,CAACnD,IAAI,CAACM,OAAO,EAAE,EAAE;MACtBD,GAAG,GAAG,IAAI,CAAC6C,WAAW,CAAC3C,GAAG,EAAEP,IAAI,CAACO,GAAG,CAAC;MACrC,IAAIF,GAAG,KAAK,CAAC,EAAE;QACb,OAAOL,IAAI,CAACgB,KAAK;MACnB,CAAC,MAAM,IAAIX,GAAG,GAAG,CAAC,EAAE;QAClBL,IAAI,GAAGA,IAAI,CAACQ,IAAI;MAClB,CAAC,MAAM,IAAIH,GAAG,GAAG,CAAC,EAAE;QAClBL,IAAI,GAAGA,IAAI,CAACS,KAAK;MACnB;IACF;IACA,OAAO,IAAI;EACb,CAAC;EAED;;;;;EAKAY,qCAAiB,GAAjB,UAAkBd,GAAM;IACtB,IAAIF,GAAG;MACLL,IAAI,GAAG,IAAI,CAACmD,KAAK;MACjBE,WAAW,GAAG,IAAI;IACpB,OAAO,CAACrD,IAAI,CAACM,OAAO,EAAE,EAAE;MACtBD,GAAG,GAAG,IAAI,CAAC6C,WAAW,CAAC3C,GAAG,EAAEP,IAAI,CAACO,GAAG,CAAC;MACrC,IAAIF,GAAG,KAAK,CAAC,EAAE;QACb,IAAI,CAACL,IAAI,CAACQ,IAAI,CAACF,OAAO,EAAE,EAAE;UACxBN,IAAI,GAAGA,IAAI,CAACQ,IAAI;UAChB,OAAO,CAACR,IAAI,CAACS,KAAK,CAACH,OAAO,EAAE;YAAEN,IAAI,GAAGA,IAAI,CAACS,KAAK;UAAC;UAChD,OAAOT,IAAI,CAACO,GAAG;QACjB,CAAC,MAAM,IAAI8C,WAAW,EAAE;UACtB,OAAOA,WAAW,CAAC9C,GAAG;QACxB,CAAC,MAAM;UACL,OAAO,IAAI,CAAC,CAAC;QACf;MACF,CAAC,MAAM,IAAIF,GAAG,GAAG,CAAC,EAAE;QAClBL,IAAI,GAAGA,IAAI,CAACQ,IAAI;MAClB,CAAC,MAAM,IAAIH,GAAG,GAAG,CAAC,EAAE;QAClBgD,WAAW,GAAGrD,IAAI;QAClBA,IAAI,GAAGA,IAAI,CAACS,KAAK;MACnB;IACF;IAEA,MAAM,IAAIuC,KAAK,CACb,uEAAuE,CACxE;EACH,CAAC;EAED;;;EAGA3B,2BAAO,GAAP;IACE,OAAO,IAAI,CAAC8B,KAAK,CAAC7C,OAAO,EAAE;EAC7B,CAAC;EAED;;;EAGAe,yBAAK,GAAL;IACE,OAAO,IAAI,CAAC8B,KAAK,CAAC5B,KAAK,EAAE;EAC3B,CAAC;EAED;;;EAGAF,0BAAM,GAAN;IACE,OAAO,IAAI,CAAC8B,KAAK,CAACG,MAAM,EAAE;EAC5B,CAAC;EAED;;;EAGAjC,0BAAM,GAAN;IACE,OAAO,IAAI,CAAC8B,KAAK,CAACvB,MAAM,EAAE;EAC5B,CAAC;EAED;;;;;;;;;EASAP,oCAAgB,GAAhB,UAAiBG,MAA2B;IAC1C,OAAO,IAAI,CAAC2B,KAAK,CAAC1B,gBAAgB,CAACD,MAAM,CAAC;EAC5C,CAAC;EAED;;;;;;;;EAQAH,oCAAgB,GAAhB,UAAiBG,MAA4B;IAC3C,OAAO,IAAI,CAAC2B,KAAK,CAACzB,gBAAgB,CAACF,MAAM,CAAC;EAC5C,CAAC;EAED;;;;;;EAMAH,+BAAW,GAAX,UACEkC,eAAmC;IAEnC,OAAO,IAAI3C,iBAAiB,CAC1B,IAAI,CAACuC,KAAK,EACV,IAAI,EACJ,IAAI,CAACD,WAAW,EAChB,KAAK,EACLK,eAAe,CAChB;EACH,CAAC;EAEDlC,mCAAe,GAAf,UACEd,GAAM,EACNgD,eAAmC;IAEnC,OAAO,IAAI3C,iBAAiB,CAC1B,IAAI,CAACuC,KAAK,EACV5C,GAAG,EACH,IAAI,CAAC2C,WAAW,EAChB,KAAK,EACLK,eAAe,CAChB;EACH,CAAC;EAEDlC,0CAAsB,GAAtB,UACEd,GAAM,EACNgD,eAAmC;IAEnC,OAAO,IAAI3C,iBAAiB,CAC1B,IAAI,CAACuC,KAAK,EACV5C,GAAG,EACH,IAAI,CAAC2C,WAAW,EAChB,IAAI,EACJK,eAAe,CAChB;EACH,CAAC;EAEDlC,sCAAkB,GAAlB,UACEkC,eAAmC;IAEnC,OAAO,IAAI3C,iBAAiB,CAC1B,IAAI,CAACuC,KAAK,EACV,IAAI,EACJ,IAAI,CAACD,WAAW,EAChB,IAAI,EACJK,eAAe,CAChB;EACH,CAAC;EAtND;;;;EAIOlC,oBAAU,GAAG,IAAI4B,aAAa,EAAE;EAmNzC,gBAAC;CAxND,EAwNC;AAxNYhC","names":["node","startKey","comparator","isReverse_","resultGenerator_","cmp","isEmpty","key","left","right","nodeStack_","push","SortedMapIterator","length","pop","result","value","exports","color","LLRBNode","RED","SortedMap","EMPTY_NODE","count","action","inorderTraversal","reverseTraversal","min_","maxKey","n","copy","insert","fixUp_","isRed_","moveRedLeft_","removeMin_","smallest","remove","rotateRight_","moveRedRight_","rotateLeft_","colorFlip_","nl","nr","blackDepth","check_","Math","pow","Error","LLRBEmptyNode","comparator_","root_","BLACK","rightParent","minKey","resultGenerator"],"sources":["../src/core/util/SortedMap.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Implementation of an immutable SortedMap using a Left-leaning\n * Red-Black Tree, adapted from the implementation in Mugs\n * (http://mads379.github.com/mugs/) by Mads Hartmann Jensen\n * (mads379@gmail.com).\n *\n * Original paper on Left-leaning Red-Black Trees:\n *   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n *\n * Invariant 1: No red node has a red child\n * Invariant 2: Every leaf path has the same number of black nodes\n * Invariant 3: Only the left child can be red (left leaning)\n */\n\n// TODO: There are some improvements I'd like to make to improve memory / perf:\n//  * Create two prototypes, LLRedNode and LLBlackNode, instead of storing a\n//    color property in every node.\n// TODO: It would also be good (and possibly necessary) to create a base\n// interface for LLRBNode and LLRBEmptyNode.\n\nexport type Comparator<K> = (key1: K, key2: K) => number;\n\n/**\n * An iterator over an LLRBNode.\n */\nexport class SortedMapIterator<K, V, T> {\n  /** @private\n   * @type {Array.<!LLRBNode>}\n   */\n  private nodeStack_: (LLRBNode<K, V> | LLRBEmptyNode<K, V>)[] = [];\n\n  /**\n   * @template K, V, T\n   * @param {LLRBNode|LLRBEmptyNode} node Node to iterate.\n   * @param {?K} startKey\n   * @param {function(K, K): number} comparator\n   * @param {boolean} isReverse_ Whether or not to iterate in reverse\n   * @param {(function(K, V):T)=} resultGenerator_\n   */\n  constructor(\n    node: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    startKey: K | null,\n    comparator: Comparator<K>,\n    private isReverse_: boolean,\n    private resultGenerator_: ((k: K, v: V) => T) | null = null\n  ) {\n    let cmp = 1;\n    while (!node.isEmpty()) {\n      node = node as LLRBNode<K, V>;\n      cmp = startKey ? comparator(node.key, startKey) : 1;\n      // flip the comparison if we're going in reverse\n      if (isReverse_) cmp *= -1;\n\n      if (cmp < 0) {\n        // This node is less than our start key. ignore it\n        if (this.isReverse_) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      } else if (cmp === 0) {\n        // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\n        this.nodeStack_.push(node);\n        break;\n      } else {\n        // This node is greater than our start key, add it to the stack and move to the next one\n        this.nodeStack_.push(node);\n        if (this.isReverse_) {\n          node = node.right;\n        } else {\n          node = node.left;\n        }\n      }\n    }\n  }\n\n  getNext(): T {\n    if (this.nodeStack_.length === 0) return null;\n\n    let node = this.nodeStack_.pop();\n    let result: T;\n    if (this.resultGenerator_)\n      result = this.resultGenerator_(node.key, node.value);\n    else result = { key: node.key, value: node.value } as any;\n\n    if (this.isReverse_) {\n      node = node.left;\n      while (!node.isEmpty()) {\n        this.nodeStack_.push(node);\n        node = node.right;\n      }\n    } else {\n      node = node.right;\n      while (!node.isEmpty()) {\n        this.nodeStack_.push(node);\n        node = node.left;\n      }\n    }\n\n    return result;\n  }\n\n  hasNext(): boolean {\n    return this.nodeStack_.length > 0;\n  }\n\n  peek(): T {\n    if (this.nodeStack_.length === 0) return null;\n\n    const node = this.nodeStack_[this.nodeStack_.length - 1];\n    if (this.resultGenerator_) {\n      return this.resultGenerator_(node.key, node.value);\n    } else {\n      return { key: node.key, value: node.value } as any;\n    }\n  }\n}\n\n/**\n * Represents a node in a Left-leaning Red-Black tree.\n */\nexport class LLRBNode<K, V> {\n  color: boolean;\n  left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n\n  /**\n   * @template K, V\n   * @param {!K} key Key associated with this node.\n   * @param {!V} value Value associated with this node.\n   * @param {?boolean} color Whether this node is red.\n   * @param {?(LLRBNode|LLRBEmptyNode)=} left Left child.\n   * @param {?(LLRBNode|LLRBEmptyNode)=} right Right child.\n   */\n  constructor(\n    public key: K,\n    public value: V,\n    color: boolean | null,\n    left?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ) {\n    this.color = color != null ? color : LLRBNode.RED;\n    this.left =\n      left != null ? left : (SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>);\n    this.right =\n      right != null ? right : (SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>);\n  }\n\n  static RED = true;\n  static BLACK = false;\n\n  /**\n   * Returns a copy of the current node, optionally replacing pieces of it.\n   *\n   * @param {?K} key New key for the node, or null.\n   * @param {?V} value New value for the node, or null.\n   * @param {?boolean} color New color for the node, or null.\n   * @param {?LLRBNode|LLRBEmptyNode} left New left child for the node, or null.\n   * @param {?LLRBNode|LLRBEmptyNode} right New right child for the node, or null.\n   * @return {!LLRBNode} The node copy.\n   */\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBNode<K, V> {\n    return new LLRBNode(\n      key != null ? key : this.key,\n      value != null ? value : this.value,\n      color != null ? color : this.color,\n      left != null ? left : this.left,\n      right != null ? right : this.right\n    );\n  }\n\n  /**\n   * @return {number} The total number of nodes in the tree.\n   */\n  count(): number {\n    return this.left.count() + 1 + this.right.count();\n  }\n\n  /**\n   * @return {boolean} True if the tree is empty.\n   */\n  isEmpty(): boolean {\n    return false;\n  }\n\n  /**\n   * Traverses the tree in key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called for each\n   *   node.  If it returns true, traversal is aborted.\n   * @return {*} The first truthy value returned by action, or the last falsey\n   *   value returned by action\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return (\n      this.left.inorderTraversal(action) ||\n      action(this.key, this.value) ||\n      this.right.inorderTraversal(action)\n    );\n  }\n\n  /**\n   * Traverses the tree in reverse key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!Object, !Object)} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {*} True if traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return (\n      this.right.reverseTraversal(action) ||\n      action(this.key, this.value) ||\n      this.left.reverseTraversal(action)\n    );\n  }\n\n  /**\n   * @return {!Object} The minimum node in the tree.\n   * @private\n   */\n  private min_(): LLRBNode<K, V> {\n    if (this.left.isEmpty()) {\n      return this;\n    } else {\n      return (this.left as LLRBNode<K, V>).min_();\n    }\n  }\n\n  /**\n   * @return {!K} The maximum key in the tree.\n   */\n  minKey(): K {\n    return this.min_().key;\n  }\n\n  /**\n   * @return {!K} The maximum key in the tree.\n   */\n  maxKey(): K {\n    if (this.right.isEmpty()) {\n      return this.key;\n    } else {\n      return this.right.maxKey();\n    }\n  }\n\n  /**\n   *\n   * @param {!Object} key Key to insert.\n   * @param {!Object} value Value to insert.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode} New tree, with the key/value added.\n   */\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    let cmp, n;\n    n = this;\n    cmp = comparator(key, n.key);\n    if (cmp < 0) {\n      n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n    } else if (cmp === 0) {\n      n = n.copy(null, value, null, null, null);\n    } else {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        n.right.insert(key, value, comparator)\n      );\n    }\n    return n.fixUp_();\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode|LLRBEmptyNode} New tree, with the minimum key removed.\n   */\n  private removeMin_(): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    if (this.left.isEmpty()) {\n      return SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n    }\n    let n: LLRBNode<K, V> = this;\n    if (!n.left.isRed_() && !n.left.left.isRed_()) n = n.moveRedLeft_();\n    n = n.copy(null, null, null, (n.left as LLRBNode<K, V>).removeMin_(), null);\n    return n.fixUp_();\n  }\n\n  /**\n   * @param {!Object} key The key of the item to remove.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode|LLRBEmptyNode} New tree, with the specified item removed.\n   */\n  remove(\n    key: K,\n    comparator: Comparator<K>\n  ): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    let n, smallest;\n    n = this;\n    if (comparator(key, n.key) < 0) {\n      if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\n        n = n.moveRedLeft_();\n      }\n      n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n    } else {\n      if (n.left.isRed_()) n = n.rotateRight_();\n      if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\n        n = n.moveRedRight_();\n      }\n      if (comparator(key, n.key) === 0) {\n        if (n.right.isEmpty()) {\n          return SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>;\n        } else {\n          smallest = (n.right as LLRBNode<K, V>).min_();\n          n = n.copy(\n            smallest.key,\n            smallest.value,\n            null,\n            null,\n            (n.right as LLRBNode<K, V>).removeMin_()\n          );\n        }\n      }\n      n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n    }\n    return n.fixUp_();\n  }\n\n  /**\n   * @private\n   * @return {boolean} Whether this is a RED node.\n   */\n  isRed_(): boolean {\n    return this.color;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree after performing any needed rotations.\n   */\n  private fixUp_(): LLRBNode<K, V> {\n    let n = this as any;\n    if (n.right.isRed_() && !n.left.isRed_()) n = n.rotateLeft_();\n    if (n.left.isRed_() && n.left.left.isRed_()) n = n.rotateRight_();\n    if (n.left.isRed_() && n.right.isRed_()) n = n.colorFlip_();\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after moveRedLeft.\n   */\n  private moveRedLeft_(): LLRBNode<K, V> {\n    let n = this.colorFlip_();\n    if (n.right.left.isRed_()) {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        (n.right as LLRBNode<K, V>).rotateRight_()\n      );\n      n = n.rotateLeft_();\n      n = n.colorFlip_();\n    }\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after moveRedRight.\n   */\n  private moveRedRight_(): LLRBNode<K, V> {\n    let n = this.colorFlip_();\n    if (n.left.left.isRed_()) {\n      n = n.rotateRight_();\n      n = n.colorFlip_();\n    }\n    return n;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after rotateLeft.\n   */\n  private rotateLeft_(): LLRBNode<K, V> {\n    const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n    return this.right.copy(null, null, this.color, nl, null) as LLRBNode<K, V>;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after rotateRight.\n   */\n  private rotateRight_(): LLRBNode<K, V> {\n    const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n    return this.left.copy(null, null, this.color, null, nr) as LLRBNode<K, V>;\n  }\n\n  /**\n   * @private\n   * @return {!LLRBNode} New tree, after colorFlip.\n   */\n  private colorFlip_(): LLRBNode<K, V> {\n    const left = this.left.copy(null, null, !this.left.color, null, null);\n    const right = this.right.copy(null, null, !this.right.color, null, null);\n    return this.copy(null, null, !this.color, left, right);\n  }\n\n  /**\n   * For testing.\n   *\n   * @private\n   * @return {boolean} True if all is well.\n   */\n  private checkMaxDepth_(): boolean {\n    const blackDepth = this.check_();\n    return Math.pow(2.0, blackDepth) <= this.count() + 1;\n  }\n\n  /**\n   * @private\n   * @return {number} Not sure what this returns exactly. :-).\n   */\n  check_(): number {\n    let blackDepth;\n    if (this.isRed_() && this.left.isRed_()) {\n      throw new Error(\n        'Red node has red child(' + this.key + ',' + this.value + ')'\n      );\n    }\n    if (this.right.isRed_()) {\n      throw new Error(\n        'Right child of (' + this.key + ',' + this.value + ') is red'\n      );\n    }\n    blackDepth = this.left.check_();\n    if (blackDepth !== this.right.check_()) {\n      throw new Error('Black depths differ');\n    } else {\n      return blackDepth + (this.isRed_() ? 0 : 1);\n    }\n  }\n}\n\n/**\n * Represents an empty node (a leaf node in the Red-Black Tree).\n */\nexport class LLRBEmptyNode<K, V> {\n  key: K;\n  value: V;\n  left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  color: boolean;\n\n  /**\n   * Returns a copy of the current node.\n   *\n   * @return {!LLRBEmptyNode} The node copy.\n   */\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  /**\n   * Returns a copy of the tree, with the specified key/value added.\n   *\n   * @param {!K} key Key to be added.\n   * @param {!V} value Value to be added.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBNode} New tree, with item added.\n   */\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    return new LLRBNode(key, value, null);\n  }\n\n  /**\n   * Returns a copy of the tree, with the specified key removed.\n   *\n   * @param {!K} key The key to remove.\n   * @param {Comparator} comparator Comparator.\n   * @return {!LLRBEmptyNode} New tree, with item removed.\n   */\n  remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  /**\n   * @return {number} The total number of nodes in the tree.\n   */\n  count(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean} True if the tree is empty.\n   */\n  isEmpty(): boolean {\n    return true;\n  }\n\n  /**\n   * Traverses the tree in key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {boolean} True if traversal was aborted.\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return false;\n  }\n\n  /**\n   * Traverses the tree in reverse key order and calls the specified action function\n   * for each node.\n   *\n   * @param {function(!K, !V)} action Callback function to be called for each\n   * node.  If it returns true, traversal is aborted.\n   * @return {boolean} True if traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return false;\n  }\n\n  /**\n   * @return {null}\n   */\n  minKey(): null {\n    return null;\n  }\n\n  /**\n   * @return {null}\n   */\n  maxKey(): null {\n    return null;\n  }\n\n  /**\n   * @private\n   * @return {number} Not sure what this returns exactly. :-).\n   */\n  check_(): number {\n    return 0;\n  }\n\n  /**\n   * @private\n   * @return {boolean} Whether this node is red.\n   */\n  isRed_() {\n    return false;\n  }\n}\n\n/**\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\n * tree.\n */\nexport class SortedMap<K, V> {\n  /**\n   * Always use the same empty node, to reduce memory.\n   * @const\n   */\n  static EMPTY_NODE = new LLRBEmptyNode();\n\n  /**\n   * @template K, V\n   * @param {function(K, K):number} comparator_ Key comparator.\n   * @param {LLRBNode=} root_ (Optional) Root node for the map.\n   */\n  constructor(\n    private comparator_: Comparator<K>,\n    private root_:\n      | LLRBNode<K, V>\n      | LLRBEmptyNode<K, V> = SortedMap.EMPTY_NODE as LLRBEmptyNode<K, V>\n  ) {}\n\n  /**\n   * Returns a copy of the map, with the specified key/value added or replaced.\n   * (TODO: We should perhaps rename this method to 'put')\n   *\n   * @param {!K} key Key to be added.\n   * @param {!V} value Value to be added.\n   * @return {!SortedMap.<K, V>} New map, with item added.\n   */\n  insert(key: K, value: V): SortedMap<K, V> {\n    return new SortedMap(\n      this.comparator_,\n      this.root_\n        .insert(key, value, this.comparator_)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  /**\n   * Returns a copy of the map, with the specified key removed.\n   *\n   * @param {!K} key The key to remove.\n   * @return {!SortedMap.<K, V>} New map, with item removed.\n   */\n  remove(key: K): SortedMap<K, V> {\n    return new SortedMap(\n      this.comparator_,\n      this.root_\n        .remove(key, this.comparator_)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  /**\n   * Returns the value of the node with the given key, or null.\n   *\n   * @param {!K} key The key to look up.\n   * @return {?V} The value of the node with the given key, or null if the\n   * key doesn't exist.\n   */\n  get(key: K): V | null {\n    let cmp;\n    let node = this.root_;\n    while (!node.isEmpty()) {\n      cmp = this.comparator_(key, node.key);\n      if (cmp === 0) {\n        return node.value;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        node = node.right;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns the key of the item *before* the specified key, or null if key is the first item.\n   * @param {K} key The key to find the predecessor of\n   * @return {?K} The predecessor key.\n   */\n  getPredecessorKey(key: K): K | null {\n    let cmp,\n      node = this.root_,\n      rightParent = null;\n    while (!node.isEmpty()) {\n      cmp = this.comparator_(key, node.key);\n      if (cmp === 0) {\n        if (!node.left.isEmpty()) {\n          node = node.left;\n          while (!node.right.isEmpty()) node = node.right;\n          return node.key;\n        } else if (rightParent) {\n          return rightParent.key;\n        } else {\n          return null; // first item.\n        }\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        rightParent = node;\n        node = node.right;\n      }\n    }\n\n    throw new Error(\n      'Attempted to find predecessor key for a nonexistent key.  What gives?'\n    );\n  }\n\n  /**\n   * @return {boolean} True if the map is empty.\n   */\n  isEmpty(): boolean {\n    return this.root_.isEmpty();\n  }\n\n  /**\n   * @return {number} The total number of nodes in the map.\n   */\n  count(): number {\n    return this.root_.count();\n  }\n\n  /**\n   * @return {?K} The minimum key in the map.\n   */\n  minKey(): K | null {\n    return this.root_.minKey();\n  }\n\n  /**\n   * @return {?K} The maximum key in the map.\n   */\n  maxKey(): K | null {\n    return this.root_.maxKey();\n  }\n\n  /**\n   * Traverses the map in key order and calls the specified action function\n   * for each key/value pair.\n   *\n   * @param {function(!K, !V):*} action Callback function to be called\n   * for each key/value pair.  If action returns true, traversal is aborted.\n   * @return {*} The first truthy value returned by action, or the last falsey\n   *   value returned by action\n   */\n  inorderTraversal(action: (k: K, v: V) => any): boolean {\n    return this.root_.inorderTraversal(action);\n  }\n\n  /**\n   * Traverses the map in reverse key order and calls the specified action function\n   * for each key/value pair.\n   *\n   * @param {function(!Object, !Object)} action Callback function to be called\n   * for each key/value pair.  If action returns true, traversal is aborted.\n   * @return {*} True if the traversal was aborted.\n   */\n  reverseTraversal(action: (k: K, v: V) => void): boolean {\n    return this.root_.reverseTraversal(action);\n  }\n\n  /**\n   * Returns an iterator over the SortedMap.\n   * @template T\n   * @param {(function(K, V):T)=} resultGenerator\n   * @return {SortedMapIterator.<K, V, T>} The iterator.\n   */\n  getIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      null,\n      this.comparator_,\n      false,\n      resultGenerator\n    );\n  }\n\n  getIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      key,\n      this.comparator_,\n      false,\n      resultGenerator\n    );\n  }\n\n  getReverseIteratorFrom<T>(\n    key: K,\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      key,\n      this.comparator_,\n      true,\n      resultGenerator\n    );\n  }\n\n  getReverseIterator<T>(\n    resultGenerator?: (k: K, v: V) => T\n  ): SortedMapIterator<K, V, T> {\n    return new SortedMapIterator(\n      this.root_,\n      null,\n      this.comparator_,\n      true,\n      resultGenerator\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}