{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ERROR_NAME = 'FirebaseError';\nvar captureStackTrace = Error.captureStackTrace;\n// Export for faking in tests\nfunction patchCapture(captureFake) {\n  var result = captureStackTrace;\n  captureStackTrace = captureFake;\n  return result;\n}\nexports.patchCapture = patchCapture;\nvar FirebaseError = /** @class */function () {\n  function FirebaseError(code, message) {\n    this.code = code;\n    this.message = message;\n    var stack;\n    // We want the stack value, if implemented by Error\n    if (captureStackTrace) {\n      // Patches this.stack, omitted calls above ErrorFactory#create\n      captureStackTrace(this, ErrorFactory.prototype.create);\n    } else {\n      var err_1 = Error.apply(this, arguments);\n      this.name = ERROR_NAME;\n      // Make non-enumerable getter for the property.\n      Object.defineProperty(this, 'stack', {\n        get: function get() {\n          return err_1.stack;\n        }\n      });\n    }\n  }\n  return FirebaseError;\n}();\nexports.FirebaseError = FirebaseError;\n// Back-door inheritance\nFirebaseError.prototype = Object.create(Error.prototype);\nFirebaseError.prototype.constructor = FirebaseError;\nFirebaseError.prototype.name = ERROR_NAME;\nvar ErrorFactory = /** @class */function () {\n  function ErrorFactory(service, serviceName, errors) {\n    this.service = service;\n    this.serviceName = serviceName;\n    this.errors = errors;\n    // Matches {$name}, by default.\n    this.pattern = /\\{\\$([^}]+)}/g;\n    // empty\n  }\n\n  ErrorFactory.prototype.create = function (code, data) {\n    if (data === undefined) {\n      data = {};\n    }\n    var template = this.errors[code];\n    var fullCode = this.service + '/' + code;\n    var message;\n    if (template === undefined) {\n      message = 'Error';\n    } else {\n      message = template.replace(this.pattern, function (match, key) {\n        var value = data[key];\n        return value !== undefined ? value.toString() : '<' + key + '?>';\n      });\n    }\n    // Service: Error message (service/code).\n    message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n    var err = new FirebaseError(fullCode, message);\n    // Populate the Error object with message parts for programmatic\n    // accesses (e.g., e.file).\n    for (var prop in data) {\n      if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n        continue;\n      }\n      err[prop] = data[prop];\n    }\n    return err;\n  };\n  return ErrorFactory;\n}();\nexports.ErrorFactory = ErrorFactory;","map":{"version":3,"mappings":";;;;;AAyDA,IAAMA,UAAU,GAAG,eAAe;AAMlC,IAAIC,iBAAiB,GAA0CC,KAAa,CACzED,iBAAiB;AAEpB;AACA,sBAA6BE,WAAiB;EAC5C,IAAIC,MAAM,GAAQH,iBAAiB;EACnCA,iBAAiB,GAAGE,WAAW;EAC/B,OAAOC,MAAM;AACf;AAJAC;AAoBA;EAIE,uBAAmBC,IAAY,EAASC,OAAe;IAApC,SAAI,GAAJD,IAAI;IAAiB,YAAO,GAAPC,OAAO;IAC7C,IAAIC,KAAa;IACjB;IACA,IAAIP,iBAAiB,EAAE;MACrB;MACAA,iBAAiB,CAAC,IAAI,EAAEQ,YAAY,CAACC,SAAS,CAACC,MAAM,CAAC;IACxD,CAAC,MAAM;MACL,IAAIC,KAAG,GAAGV,KAAK,CAACW,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;MACtC,IAAI,CAACC,IAAI,GAAGf,UAAU;MACtB;MACAgB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,OAAO,EAAE;QACnCC,GAAG,EAAE;UACH,OAAON,KAAG,CAACJ,KAAK;QAClB;OACD,CAAC;IACJ;EACF;EACF,oBAAC;AAAD,CArBA,EAqBC;AArBYH;AAuBb;AACAc,aAAa,CAACT,SAAS,GAAGM,MAAM,CAACL,MAAM,CAACT,KAAK,CAACQ,SAAS,CAAkB;AACzES,aAAa,CAACT,SAAS,CAACU,WAAW,GAAGD,aAAa;AAClDA,aAAa,CAACT,SAAiB,CAACK,IAAI,GAAGf,UAAU;AAElD;EAIE,sBACUqB,OAAe,EACfC,WAAmB,EACnBC,MAAoB;IAFpB,YAAO,GAAPF,OAAO;IACP,gBAAW,GAAXC,WAAW;IACX,WAAM,GAANC,MAAM;IANhB;IACO,YAAO,GAAG,eAAe;IAO9B;EACF;;EAEAd,6BAAM,GAAN,UAAOH,IAAO,EAAEkB,IAAqC;IACnD,IAAIA,IAAI,KAAKC,SAAS,EAAE;MACtBD,IAAI,GAAG,EAAE;IACX;IAEA,IAAIE,QAAQ,GAAG,IAAI,CAACH,MAAM,CAACjB,IAAc,CAAC;IAE1C,IAAIqB,QAAQ,GAAG,IAAI,CAACN,OAAO,GAAG,GAAG,GAAGf,IAAI;IACxC,IAAIC,OAAe;IAEnB,IAAImB,QAAQ,KAAKD,SAAS,EAAE;MAC1BlB,OAAO,GAAG,OAAO;IACnB,CAAC,MAAM;MACLA,OAAO,GAAGmB,QAAQ,CAACE,OAAO,CAAC,IAAI,CAACC,OAAO,EAAE,UAACC,KAAK,EAAEC,GAAG;QAClD,IAAIC,KAAK,GAAGR,IAAK,CAACO,GAAG,CAAC;QACtB,OAAOC,KAAK,KAAKP,SAAS,GAAGO,KAAK,CAACC,QAAQ,EAAE,GAAG,GAAG,GAAGF,GAAG,GAAG,IAAI;MAClE,CAAC,CAAC;IACJ;IAEA;IACAxB,OAAO,GAAG,IAAI,CAACe,WAAW,GAAG,IAAI,GAAGf,OAAO,GAAG,IAAI,GAAGoB,QAAQ,GAAG,IAAI;IACpE,IAAIO,GAAG,GAAG,IAAIf,aAAa,CAACQ,QAAQ,EAAEpB,OAAO,CAAC;IAE9C;IACA;IACA,KAAK,IAAI4B,IAAI,IAAIX,IAAI,EAAE;MACrB,IAAI,CAACA,IAAI,CAACY,cAAc,CAACD,IAAI,CAAC,IAAIA,IAAI,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACxD;MACF;MACCH,GAAW,CAACC,IAAI,CAAC,GAAGX,IAAI,CAACW,IAAI,CAAC;IACjC;IAEA,OAAOD,GAAG;EACZ,CAAC;EACH,mBAAC;AAAD,CA9CA,EA8CC;AA9CY7B","names":["ERROR_NAME","captureStackTrace","Error","captureFake","result","exports","code","message","stack","ErrorFactory","prototype","create","err_1","apply","arguments","name","Object","defineProperty","get","FirebaseError","constructor","service","serviceName","errors","data","undefined","template","fullCode","replace","pattern","match","key","value","toString","err","prop","hasOwnProperty","slice"],"sources":["../src/errors.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // Typescript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if (e.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nexport type ErrorList<T> = { [code: string]: string };\n\nconst ERROR_NAME = 'FirebaseError';\n\nexport interface StringLike {\n  toString: () => string;\n}\n\nlet captureStackTrace: (obj: Object, fn?: Function) => void = (Error as any)\n  .captureStackTrace;\n\n// Export for faking in tests\nexport function patchCapture(captureFake?: any): any {\n  let result: any = captureStackTrace;\n  captureStackTrace = captureFake;\n  return result;\n}\n\nexport interface FirebaseError {\n  // Unique code for error - format is service/error-code-string\n  code: string;\n\n  // Developer-friendly error message.\n  message: string;\n\n  // Always 'FirebaseError'\n  name: string;\n\n  // Where available - stack backtrace in a string\n  stack: string;\n}\n\nexport class FirebaseError implements FirebaseError {\n  public stack: string;\n  public name: string;\n\n  constructor(public code: string, public message: string) {\n    let stack: string;\n    // We want the stack value, if implemented by Error\n    if (captureStackTrace) {\n      // Patches this.stack, omitted calls above ErrorFactory#create\n      captureStackTrace(this, ErrorFactory.prototype.create);\n    } else {\n      let err = Error.apply(this, arguments);\n      this.name = ERROR_NAME;\n      // Make non-enumerable getter for the property.\n      Object.defineProperty(this, 'stack', {\n        get: function() {\n          return err.stack;\n        }\n      });\n    }\n  }\n}\n\n// Back-door inheritance\nFirebaseError.prototype = Object.create(Error.prototype) as FirebaseError;\nFirebaseError.prototype.constructor = FirebaseError;\n(FirebaseError.prototype as any).name = ERROR_NAME;\n\nexport class ErrorFactory<T extends string> {\n  // Matches {$name}, by default.\n  public pattern = /\\{\\$([^}]+)}/g;\n\n  constructor(\n    private service: string,\n    private serviceName: string,\n    private errors: ErrorList<T>\n  ) {\n    // empty\n  }\n\n  create(code: T, data?: { [prop: string]: StringLike }): FirebaseError {\n    if (data === undefined) {\n      data = {};\n    }\n\n    let template = this.errors[code as string];\n\n    let fullCode = this.service + '/' + code;\n    let message: string;\n\n    if (template === undefined) {\n      message = 'Error';\n    } else {\n      message = template.replace(this.pattern, (match, key) => {\n        let value = data![key];\n        return value !== undefined ? value.toString() : '<' + key + '?>';\n      });\n    }\n\n    // Service: Error message (service/code).\n    message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n    let err = new FirebaseError(fullCode, message);\n\n    // Populate the Error object with message parts for programmatic\n    // accesses (e.g., e.file).\n    for (let prop in data) {\n      if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n        continue;\n      }\n      (err as any)[prop] = data[prop];\n    }\n\n    return err;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}