{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar CacheNode_1 = require(\"./view/CacheNode\");\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"@firebase/util\");\nvar ViewCache_1 = require(\"./view/ViewCache\");\nvar View_1 = require(\"./view/View\");\nvar __referenceConstructor;\n/**\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\n * and user writes (set, transaction, update).\n *\n * It's responsible for:\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\n *    applyUserOverwrite, etc.)\n */\nvar SyncPoint = /** @class */function () {\n  function SyncPoint() {\n    /**\n     * The Views being tracked at this location in the tree, stored as a map where the key is a\n     * queryId and the value is the View for that query.\n     *\n     * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\n     *\n     * @type {!Object.<!string, !View>}\n     * @private\n     */\n    this.views_ = {};\n  }\n  Object.defineProperty(SyncPoint, \"__referenceConstructor\", {\n    get: function get() {\n      util_1.assert(__referenceConstructor, 'Reference.ts has not been loaded');\n      return __referenceConstructor;\n    },\n    set: function set(val) {\n      util_1.assert(!__referenceConstructor, '__referenceConstructor has already been defined');\n      __referenceConstructor = val;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @return {boolean}\n   */\n  SyncPoint.prototype.isEmpty = function () {\n    return util_2.isEmpty(this.views_);\n  };\n  /**\n   *\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} optCompleteServerCache\n   * @return {!Array.<!Event>}\n   */\n  SyncPoint.prototype.applyOperation = function (operation, writesCache, optCompleteServerCache) {\n    var queryId = operation.source.queryId;\n    if (queryId !== null) {\n      var view = util_2.safeGet(this.views_, queryId);\n      util_1.assert(view != null, 'SyncTree gave us an op for an invalid query.');\n      return view.applyOperation(operation, writesCache, optCompleteServerCache);\n    } else {\n      var events_1 = [];\n      util_2.forEach(this.views_, function (key, view) {\n        events_1 = events_1.concat(view.applyOperation(operation, writesCache, optCompleteServerCache));\n      });\n      return events_1;\n    }\n  };\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache Complete server cache, if we have it.\n   * @param {boolean} serverCacheComplete\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  SyncPoint.prototype.addEventRegistration = function (query, eventRegistration, writesCache, serverCache, serverCacheComplete) {\n    var queryId = query.queryIdentifier();\n    var view = util_2.safeGet(this.views_, queryId);\n    if (!view) {\n      // TODO: make writesCache take flag for complete server node\n      var eventCache = writesCache.calcCompleteEventCache(serverCacheComplete ? serverCache : null);\n      var eventCacheComplete = false;\n      if (eventCache) {\n        eventCacheComplete = true;\n      } else if (serverCache instanceof ChildrenNode_1.ChildrenNode) {\n        eventCache = writesCache.calcCompleteEventChildren(serverCache);\n        eventCacheComplete = false;\n      } else {\n        eventCache = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n        eventCacheComplete = false;\n      }\n      var viewCache = new ViewCache_1.ViewCache(new CacheNode_1.CacheNode( /** @type {!Node} */eventCache, eventCacheComplete, false), new CacheNode_1.CacheNode( /** @type {!Node} */serverCache, serverCacheComplete, false));\n      view = new View_1.View(query, viewCache);\n      this.views_[queryId] = view;\n    }\n    // This is guaranteed to exist now, we just created anything that was missing\n    view.addEventRegistration(eventRegistration);\n    return view.getInitialEvents(eventRegistration);\n  };\n  /**\n   * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\n   *\n   * If query is the default query, we'll check all views for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\n   *\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events\n   */\n  SyncPoint.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {\n    var queryId = query.queryIdentifier();\n    var removed = [];\n    var cancelEvents = [];\n    var hadCompleteView = this.hasCompleteView();\n    if (queryId === 'default') {\n      // When you do ref.off(...), we search all views for the registration to remove.\n      var self_1 = this;\n      util_2.forEach(this.views_, function (viewQueryId, view) {\n        cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\n        if (view.isEmpty()) {\n          delete self_1.views_[viewQueryId];\n          // We'll deal with complete views later.\n          if (!view.getQuery().getQueryParams().loadsAllData()) {\n            removed.push(view.getQuery());\n          }\n        }\n      });\n    } else {\n      // remove the callback from the specific view.\n      var view = util_2.safeGet(this.views_, queryId);\n      if (view) {\n        cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\n        if (view.isEmpty()) {\n          delete this.views_[queryId];\n          // We'll deal with complete views later.\n          if (!view.getQuery().getQueryParams().loadsAllData()) {\n            removed.push(view.getQuery());\n          }\n        }\n      }\n    }\n    if (hadCompleteView && !this.hasCompleteView()) {\n      // We removed our last complete view.\n      removed.push(new SyncPoint.__referenceConstructor(query.repo, query.path));\n    }\n    return {\n      removed: removed,\n      events: cancelEvents\n    };\n  };\n  /**\n   * @return {!Array.<!View>}\n   */\n  SyncPoint.prototype.getQueryViews = function () {\n    var _this = this;\n    var values = Object.keys(this.views_).map(function (key) {\n      return _this.views_[key];\n    });\n    return values.filter(function (view) {\n      return !view.getQuery().getQueryParams().loadsAllData();\n    });\n  };\n  /**\n   *\n   * @param {!Path} path The path to the desired complete snapshot\n   * @return {?Node} A complete cache, if it exists\n   */\n  SyncPoint.prototype.getCompleteServerCache = function (path) {\n    var serverCache = null;\n    util_2.forEach(this.views_, function (key, view) {\n      serverCache = serverCache || view.getCompleteServerCache(path);\n    });\n    return serverCache;\n  };\n  /**\n   * @param {!Query} query\n   * @return {?View}\n   */\n  SyncPoint.prototype.viewForQuery = function (query) {\n    var params = query.getQueryParams();\n    if (params.loadsAllData()) {\n      return this.getCompleteView();\n    } else {\n      var queryId = query.queryIdentifier();\n      return util_2.safeGet(this.views_, queryId);\n    }\n  };\n  /**\n   * @param {!Query} query\n   * @return {boolean}\n   */\n  SyncPoint.prototype.viewExistsForQuery = function (query) {\n    return this.viewForQuery(query) != null;\n  };\n  /**\n   * @return {boolean}\n   */\n  SyncPoint.prototype.hasCompleteView = function () {\n    return this.getCompleteView() != null;\n  };\n  /**\n   * @return {?View}\n   */\n  SyncPoint.prototype.getCompleteView = function () {\n    var completeView = util_2.findValue(this.views_, function (view) {\n      return view.getQuery().getQueryParams().loadsAllData();\n    });\n    return completeView || null;\n  };\n  return SyncPoint;\n}();\nexports.SyncPoint = SyncPoint;","map":{"version":3,"mappings":"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","names":["__referenceConstructor","Object","SyncPoint","util_1","val","util_2","views_","operation","writesCache","optCompleteServerCache","queryId","source","view","applyOperation","events_1","key","concat","query","eventRegistration","serverCache","serverCacheComplete","queryIdentifier","eventCache","calcCompleteEventCache","eventCacheComplete","ChildrenNode_1","calcCompleteEventChildren","EMPTY_NODE","viewCache","ViewCache_1","CacheNode_1","View_1","addEventRegistration","getInitialEvents","cancelError","removed","cancelEvents","hadCompleteView","hasCompleteView","self_1","viewQueryId","removeEventRegistration","isEmpty","getQuery","getQueryParams","loadsAllData","push","repo","path","events","values","keys","map","filter","getCompleteServerCache","params","getCompleteView","viewForQuery","completeView","exports"],"sources":["../src/core/SyncPoint.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CacheNode } from './view/CacheNode';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { assert } from '@firebase/util';\nimport { isEmpty, forEach, findValue, safeGet } from '@firebase/util';\nimport { ViewCache } from './view/ViewCache';\nimport { View } from './view/View';\nimport { Operation } from './operation/Operation';\nimport { WriteTreeRef } from './WriteTree';\nimport { Query } from '../api/Query';\nimport { EventRegistration } from './view/EventRegistration';\nimport { Node } from './snap/Node';\nimport { Path } from './util/Path';\nimport { Event } from './view/Event';\nimport { Reference, ReferenceConstructor } from '../api/Reference';\n\nlet __referenceConstructor: ReferenceConstructor;\n\n/**\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\n * and user writes (set, transaction, update).\n *\n * It's responsible for:\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\n *    applyUserOverwrite, etc.)\n */\nexport class SyncPoint {\n  static set __referenceConstructor(val: ReferenceConstructor) {\n    assert(\n      !__referenceConstructor,\n      '__referenceConstructor has already been defined'\n    );\n    __referenceConstructor = val;\n  }\n\n  static get __referenceConstructor() {\n    assert(__referenceConstructor, 'Reference.ts has not been loaded');\n    return __referenceConstructor;\n  }\n\n  /**\n   * The Views being tracked at this location in the tree, stored as a map where the key is a\n   * queryId and the value is the View for that query.\n   *\n   * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\n   *\n   * @type {!Object.<!string, !View>}\n   * @private\n   */\n  private views_: { [k: string]: View } = {};\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty(): boolean {\n    return isEmpty(this.views_);\n  }\n\n  /**\n   *\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} optCompleteServerCache\n   * @return {!Array.<!Event>}\n   */\n  applyOperation(\n    operation: Operation,\n    writesCache: WriteTreeRef,\n    optCompleteServerCache: Node | null\n  ): Event[] {\n    const queryId = operation.source.queryId;\n    if (queryId !== null) {\n      const view = safeGet(this.views_, queryId);\n      assert(view != null, 'SyncTree gave us an op for an invalid query.');\n      return view.applyOperation(\n        operation,\n        writesCache,\n        optCompleteServerCache\n      );\n    } else {\n      let events: Event[] = [];\n\n      forEach(this.views_, function(key: string, view: View) {\n        events = events.concat(\n          view.applyOperation(operation, writesCache, optCompleteServerCache)\n        );\n      });\n\n      return events;\n    }\n  }\n\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache Complete server cache, if we have it.\n   * @param {boolean} serverCacheComplete\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  addEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    serverCacheComplete: boolean\n  ): Event[] {\n    const queryId = query.queryIdentifier();\n    let view = safeGet(this.views_, queryId);\n    if (!view) {\n      // TODO: make writesCache take flag for complete server node\n      let eventCache = writesCache.calcCompleteEventCache(\n        serverCacheComplete ? serverCache : null\n      );\n      let eventCacheComplete = false;\n      if (eventCache) {\n        eventCacheComplete = true;\n      } else if (serverCache instanceof ChildrenNode) {\n        eventCache = writesCache.calcCompleteEventChildren(serverCache);\n        eventCacheComplete = false;\n      } else {\n        eventCache = ChildrenNode.EMPTY_NODE;\n        eventCacheComplete = false;\n      }\n      const viewCache = new ViewCache(\n        new CacheNode(\n          /** @type {!Node} */ (eventCache),\n          eventCacheComplete,\n          false\n        ),\n        new CacheNode(\n          /** @type {!Node} */ (serverCache),\n          serverCacheComplete,\n          false\n        )\n      );\n      view = new View(query, viewCache);\n      this.views_[queryId] = view;\n    }\n\n    // This is guaranteed to exist now, we just created anything that was missing\n    view.addEventRegistration(eventRegistration);\n    return view.getInitialEvents(eventRegistration);\n  }\n\n  /**\n   * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\n   *\n   * If query is the default query, we'll check all views for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\n   *\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events\n   */\n  removeEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration | null,\n    cancelError?: Error\n  ): { removed: Query[]; events: Event[] } {\n    const queryId = query.queryIdentifier();\n    const removed: Query[] = [];\n    let cancelEvents: Event[] = [];\n    const hadCompleteView = this.hasCompleteView();\n    if (queryId === 'default') {\n      // When you do ref.off(...), we search all views for the registration to remove.\n      const self = this;\n      forEach(this.views_, function(viewQueryId: string, view: View) {\n        cancelEvents = cancelEvents.concat(\n          view.removeEventRegistration(eventRegistration, cancelError)\n        );\n        if (view.isEmpty()) {\n          delete self.views_[viewQueryId];\n\n          // We'll deal with complete views later.\n          if (\n            !view\n              .getQuery()\n              .getQueryParams()\n              .loadsAllData()\n          ) {\n            removed.push(view.getQuery());\n          }\n        }\n      });\n    } else {\n      // remove the callback from the specific view.\n      const view = safeGet(this.views_, queryId);\n      if (view) {\n        cancelEvents = cancelEvents.concat(\n          view.removeEventRegistration(eventRegistration, cancelError)\n        );\n        if (view.isEmpty()) {\n          delete this.views_[queryId];\n\n          // We'll deal with complete views later.\n          if (\n            !view\n              .getQuery()\n              .getQueryParams()\n              .loadsAllData()\n          ) {\n            removed.push(view.getQuery());\n          }\n        }\n      }\n    }\n\n    if (hadCompleteView && !this.hasCompleteView()) {\n      // We removed our last complete view.\n      removed.push(\n        new SyncPoint.__referenceConstructor(query.repo, query.path)\n      );\n    }\n\n    return { removed: removed, events: cancelEvents };\n  }\n\n  /**\n   * @return {!Array.<!View>}\n   */\n  getQueryViews(): View[] {\n    const values = Object.keys(this.views_).map(key => this.views_[key]);\n    return values.filter(function(view) {\n      return !view\n        .getQuery()\n        .getQueryParams()\n        .loadsAllData();\n    });\n  }\n\n  /**\n   *\n   * @param {!Path} path The path to the desired complete snapshot\n   * @return {?Node} A complete cache, if it exists\n   */\n  getCompleteServerCache(path: Path): Node | null {\n    let serverCache: Node | null = null;\n    forEach(this.views_, (key: string, view: View) => {\n      serverCache = serverCache || view.getCompleteServerCache(path);\n    });\n    return serverCache;\n  }\n\n  /**\n   * @param {!Query} query\n   * @return {?View}\n   */\n  viewForQuery(query: Query): View | null {\n    const params = query.getQueryParams();\n    if (params.loadsAllData()) {\n      return this.getCompleteView();\n    } else {\n      const queryId = query.queryIdentifier();\n      return safeGet(this.views_, queryId);\n    }\n  }\n\n  /**\n   * @param {!Query} query\n   * @return {boolean}\n   */\n  viewExistsForQuery(query: Query): boolean {\n    return this.viewForQuery(query) != null;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasCompleteView(): boolean {\n    return this.getCompleteView() != null;\n  }\n\n  /**\n   * @return {?View}\n   */\n  getCompleteView(): View | null {\n    const completeView = findValue(this.views_, (view: View) =>\n      view\n        .getQuery()\n        .getQueryParams()\n        .loadsAllData()\n    );\n    return completeView || null;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}