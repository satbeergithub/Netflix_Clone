{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"../core/util/util\");\nvar storage_1 = require(\"../core/storage/storage\");\nvar Constants_1 = require(\"./Constants\");\nvar TransportManager_1 = require(\"./TransportManager\");\n// Abort upgrade attempt if it takes longer than 60s.\nvar UPGRADE_TIMEOUT = 60000;\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\nvar DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\nvar BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\nvar BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\nvar MESSAGE_TYPE = 't';\nvar MESSAGE_DATA = 'd';\nvar CONTROL_SHUTDOWN = 's';\nvar CONTROL_RESET = 'r';\nvar CONTROL_ERROR = 'e';\nvar CONTROL_PONG = 'o';\nvar SWITCH_ACK = 'a';\nvar END_TRANSMISSION = 'n';\nvar PING = 'p';\nvar SERVER_HELLO = 'h';\n/**\n * Creates a new real-time connection to the server using whichever method works\n * best in the current browser.\n *\n * @constructor\n */\nvar Connection = /** @class */function () {\n  /**\n   * @param {!string} id - an id for this connection\n   * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to\n   * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives\n   * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.\n   * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost\n   * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.\n   * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\n   */\n  function Connection(id, repoInfo_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {\n    this.id = id;\n    this.repoInfo_ = repoInfo_;\n    this.onMessage_ = onMessage_;\n    this.onReady_ = onReady_;\n    this.onDisconnect_ = onDisconnect_;\n    this.onKill_ = onKill_;\n    this.lastSessionId = lastSessionId;\n    this.connectionCount = 0;\n    this.pendingDataMessages = [];\n    this.state_ = 0 /* CONNECTING */;\n    this.log_ = util_1.logWrapper('c:' + this.id + ':');\n    this.transportManager_ = new TransportManager_1.TransportManager(repoInfo_);\n    this.log_('Connection created');\n    this.start_();\n  }\n  /**\n   * Starts a connection attempt\n   * @private\n   */\n  Connection.prototype.start_ = function () {\n    var _this = this;\n    var conn = this.transportManager_.initialTransport();\n    this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, undefined, this.lastSessionId);\n    // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n    this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\n    var onMessageReceived = this.connReceiver_(this.conn_);\n    var onConnectionLost = this.disconnReceiver_(this.conn_);\n    this.tx_ = this.conn_;\n    this.rx_ = this.conn_;\n    this.secondaryConn_ = null;\n    this.isHealthy_ = false;\n    /*\n     * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\n     * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\n     * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\n     * still have the context of your originating frame.\n     */\n    setTimeout(function () {\n      // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\n      _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);\n    }, Math.floor(0));\n    var healthyTimeout_ms = conn['healthyTimeout'] || 0;\n    if (healthyTimeout_ms > 0) {\n      this.healthyTimeout_ = util_1.setTimeoutNonBlocking(function () {\n        _this.healthyTimeout_ = null;\n        if (!_this.isHealthy_) {\n          if (_this.conn_ && _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {\n            _this.log_('Connection exceeded healthy timeout but has received ' + _this.conn_.bytesReceived + ' bytes.  Marking connection healthy.');\n            _this.isHealthy_ = true;\n            _this.conn_.markConnectionHealthy();\n          } else if (_this.conn_ && _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {\n            _this.log_('Connection exceeded healthy timeout but has sent ' + _this.conn_.bytesSent + ' bytes.  Leaving connection alive.');\n            // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n            // the server.\n          } else {\n            _this.log_('Closing unhealthy connection after timeout.');\n            _this.close();\n          }\n        }\n      }, Math.floor(healthyTimeout_ms));\n    }\n  };\n  /**\n   * @return {!string}\n   * @private\n   */\n  Connection.prototype.nextTransportId_ = function () {\n    return 'c:' + this.id + ':' + this.connectionCount++;\n  };\n  Connection.prototype.disconnReceiver_ = function (conn) {\n    var _this = this;\n    return function (everConnected) {\n      if (conn === _this.conn_) {\n        _this.onConnectionLost_(everConnected);\n      } else if (conn === _this.secondaryConn_) {\n        _this.log_('Secondary connection lost.');\n        _this.onSecondaryConnectionLost_();\n      } else {\n        _this.log_('closing an old connection');\n      }\n    };\n  };\n  Connection.prototype.connReceiver_ = function (conn) {\n    var _this = this;\n    return function (message) {\n      if (_this.state_ != 2 /* DISCONNECTED */) {\n        if (conn === _this.rx_) {\n          _this.onPrimaryMessageReceived_(message);\n        } else if (conn === _this.secondaryConn_) {\n          _this.onSecondaryMessageReceived_(message);\n        } else {\n          _this.log_('message on old connection');\n        }\n      }\n    };\n  };\n  /**\n   *\n   * @param {Object} dataMsg An arbitrary data message to be sent to the server\n   */\n  Connection.prototype.sendRequest = function (dataMsg) {\n    // wrap in a data message envelope and send it on\n    var msg = {\n      t: 'd',\n      d: dataMsg\n    };\n    this.sendData_(msg);\n  };\n  Connection.prototype.tryCleanupConnection = function () {\n    if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\n      this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);\n      this.conn_ = this.secondaryConn_;\n      this.secondaryConn_ = null;\n      // the server will shutdown the old connection\n    }\n  };\n\n  Connection.prototype.onSecondaryControl_ = function (controlData) {\n    if (MESSAGE_TYPE in controlData) {\n      var cmd = controlData[MESSAGE_TYPE];\n      if (cmd === SWITCH_ACK) {\n        this.upgradeIfSecondaryHealthy_();\n      } else if (cmd === CONTROL_RESET) {\n        // Most likely the session wasn't valid. Abandon the switch attempt\n        this.log_('Got a reset on secondary, closing it');\n        this.secondaryConn_.close();\n        // If we were already using this connection for something, than we need to fully close\n        if (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) {\n          this.close();\n        }\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on secondary.');\n        this.secondaryResponsesRequired_--;\n        this.upgradeIfSecondaryHealthy_();\n      }\n    }\n  };\n  Connection.prototype.onSecondaryMessageReceived_ = function (parsedData) {\n    var layer = util_1.requireKey('t', parsedData);\n    var data = util_1.requireKey('d', parsedData);\n    if (layer == 'c') {\n      this.onSecondaryControl_(data);\n    } else if (layer == 'd') {\n      // got a data message, but we're still second connection. Need to buffer it up\n      this.pendingDataMessages.push(data);\n    } else {\n      throw new Error('Unknown protocol layer: ' + layer);\n    }\n  };\n  Connection.prototype.upgradeIfSecondaryHealthy_ = function () {\n    if (this.secondaryResponsesRequired_ <= 0) {\n      this.log_('Secondary connection is healthy.');\n      this.isHealthy_ = true;\n      this.secondaryConn_.markConnectionHealthy();\n      this.proceedWithUpgrade_();\n    } else {\n      // Send a ping to make sure the connection is healthy.\n      this.log_('sending ping on secondary.');\n      this.secondaryConn_.send({\n        t: 'c',\n        d: {\n          t: PING,\n          d: {}\n        }\n      });\n    }\n  };\n  Connection.prototype.proceedWithUpgrade_ = function () {\n    // tell this connection to consider itself open\n    this.secondaryConn_.start();\n    // send ack\n    this.log_('sending client ack on secondary');\n    this.secondaryConn_.send({\n      t: 'c',\n      d: {\n        t: SWITCH_ACK,\n        d: {}\n      }\n    });\n    // send end packet on primary transport, switch to sending on this one\n    // can receive on this one, buffer responses until end received on primary transport\n    this.log_('Ending transmission on primary');\n    this.conn_.send({\n      t: 'c',\n      d: {\n        t: END_TRANSMISSION,\n        d: {}\n      }\n    });\n    this.tx_ = this.secondaryConn_;\n    this.tryCleanupConnection();\n  };\n  Connection.prototype.onPrimaryMessageReceived_ = function (parsedData) {\n    // Must refer to parsedData properties in quotes, so closure doesn't touch them.\n    var layer = util_1.requireKey('t', parsedData);\n    var data = util_1.requireKey('d', parsedData);\n    if (layer == 'c') {\n      this.onControl_(data);\n    } else if (layer == 'd') {\n      this.onDataMessage_(data);\n    }\n  };\n  Connection.prototype.onDataMessage_ = function (message) {\n    this.onPrimaryResponse_();\n    // We don't do anything with data messages, just kick them up a level\n    this.onMessage_(message);\n  };\n  Connection.prototype.onPrimaryResponse_ = function () {\n    if (!this.isHealthy_) {\n      this.primaryResponsesRequired_--;\n      if (this.primaryResponsesRequired_ <= 0) {\n        this.log_('Primary connection is healthy.');\n        this.isHealthy_ = true;\n        this.conn_.markConnectionHealthy();\n      }\n    }\n  };\n  Connection.prototype.onControl_ = function (controlData) {\n    var cmd = util_1.requireKey(MESSAGE_TYPE, controlData);\n    if (MESSAGE_DATA in controlData) {\n      var payload = controlData[MESSAGE_DATA];\n      if (cmd === SERVER_HELLO) {\n        this.onHandshake_(payload);\n      } else if (cmd === END_TRANSMISSION) {\n        this.log_('recvd end transmission on primary');\n        this.rx_ = this.secondaryConn_;\n        for (var i = 0; i < this.pendingDataMessages.length; ++i) {\n          this.onDataMessage_(this.pendingDataMessages[i]);\n        }\n        this.pendingDataMessages = [];\n        this.tryCleanupConnection();\n      } else if (cmd === CONTROL_SHUTDOWN) {\n        // This was previously the 'onKill' callback passed to the lower-level connection\n        // payload in this case is the reason for the shutdown. Generally a human-readable error\n        this.onConnectionShutdown_(payload);\n      } else if (cmd === CONTROL_RESET) {\n        // payload in this case is the host we should contact\n        this.onReset_(payload);\n      } else if (cmd === CONTROL_ERROR) {\n        util_1.error('Server Error: ' + payload);\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on primary.');\n        this.onPrimaryResponse_();\n        this.sendPingOnPrimaryIfNecessary_();\n      } else {\n        util_1.error('Unknown control packet command: ' + cmd);\n      }\n    }\n  };\n  /**\n   *\n   * @param {Object} handshake The handshake data returned from the server\n   * @private\n   */\n  Connection.prototype.onHandshake_ = function (handshake) {\n    var timestamp = handshake.ts;\n    var version = handshake.v;\n    var host = handshake.h;\n    this.sessionId = handshake.s;\n    this.repoInfo_.updateHost(host);\n    // if we've already closed the connection, then don't bother trying to progress further\n    if (this.state_ == 0 /* CONNECTING */) {\n      this.conn_.start();\n      this.onConnectionEstablished_(this.conn_, timestamp);\n      if (Constants_1.PROTOCOL_VERSION !== version) {\n        util_1.warn('Protocol version mismatch detected');\n      }\n      // TODO: do we want to upgrade? when? maybe a delay?\n      this.tryStartUpgrade_();\n    }\n  };\n  Connection.prototype.tryStartUpgrade_ = function () {\n    var conn = this.transportManager_.upgradeTransport();\n    if (conn) {\n      this.startUpgrade_(conn);\n    }\n  };\n  Connection.prototype.startUpgrade_ = function (conn) {\n    var _this = this;\n    this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.sessionId);\n    // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n    this.secondaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\n    var onMessage = this.connReceiver_(this.secondaryConn_);\n    var onDisconnect = this.disconnReceiver_(this.secondaryConn_);\n    this.secondaryConn_.open(onMessage, onDisconnect);\n    // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\n    util_1.setTimeoutNonBlocking(function () {\n      if (_this.secondaryConn_) {\n        _this.log_('Timed out trying to upgrade.');\n        _this.secondaryConn_.close();\n      }\n    }, Math.floor(UPGRADE_TIMEOUT));\n  };\n  Connection.prototype.onReset_ = function (host) {\n    this.log_('Reset packet received.  New host: ' + host);\n    this.repoInfo_.updateHost(host);\n    // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n    // We don't currently support resets after the connection has already been established\n    if (this.state_ === 1 /* CONNECTED */) {\n      this.close();\n    } else {\n      // Close whatever connections we have open and start again.\n      this.closeConnections_();\n      this.start_();\n    }\n  };\n  Connection.prototype.onConnectionEstablished_ = function (conn, timestamp) {\n    var _this = this;\n    this.log_('Realtime connection established.');\n    this.conn_ = conn;\n    this.state_ = 1 /* CONNECTED */;\n    if (this.onReady_) {\n      this.onReady_(timestamp, this.sessionId);\n      this.onReady_ = null;\n    }\n    // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n    // send some pings.\n    if (this.primaryResponsesRequired_ === 0) {\n      this.log_('Primary connection is healthy.');\n      this.isHealthy_ = true;\n    } else {\n      util_1.setTimeoutNonBlocking(function () {\n        _this.sendPingOnPrimaryIfNecessary_();\n      }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\n    }\n  };\n  Connection.prototype.sendPingOnPrimaryIfNecessary_ = function () {\n    // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\n    if (!this.isHealthy_ && this.state_ === 1 /* CONNECTED */) {\n      this.log_('sending ping on primary.');\n      this.sendData_({\n        t: 'c',\n        d: {\n          t: PING,\n          d: {}\n        }\n      });\n    }\n  };\n  Connection.prototype.onSecondaryConnectionLost_ = function () {\n    var conn = this.secondaryConn_;\n    this.secondaryConn_ = null;\n    if (this.tx_ === conn || this.rx_ === conn) {\n      // we are relying on this connection already in some capacity. Therefore, a failure is real\n      this.close();\n    }\n  };\n  /**\n   *\n   * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if\n   * we should flush the host cache\n   * @private\n   */\n  Connection.prototype.onConnectionLost_ = function (everConnected) {\n    this.conn_ = null;\n    // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n    // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\n    if (!everConnected && this.state_ === 0 /* CONNECTING */) {\n      this.log_('Realtime connection failed.');\n      // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\n      if (this.repoInfo_.isCacheableHost()) {\n        storage_1.PersistentStorage.remove('host:' + this.repoInfo_.host);\n        // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\n        this.repoInfo_.internalHost = this.repoInfo_.host;\n      }\n    } else if (this.state_ === 1 /* CONNECTED */) {\n      this.log_('Realtime connection lost.');\n    }\n    this.close();\n  };\n  /**\n   *\n   * @param {string} reason\n   * @private\n   */\n  Connection.prototype.onConnectionShutdown_ = function (reason) {\n    this.log_('Connection shutdown command received. Shutting down...');\n    if (this.onKill_) {\n      this.onKill_(reason);\n      this.onKill_ = null;\n    }\n    // We intentionally don't want to fire onDisconnect (kill is a different case),\n    // so clear the callback.\n    this.onDisconnect_ = null;\n    this.close();\n  };\n  Connection.prototype.sendData_ = function (data) {\n    if (this.state_ !== 1 /* CONNECTED */) {\n      throw 'Connection is not connected';\n    } else {\n      this.tx_.send(data);\n    }\n  };\n  /**\n   * Cleans up this connection, calling the appropriate callbacks\n   */\n  Connection.prototype.close = function () {\n    if (this.state_ !== 2 /* DISCONNECTED */) {\n      this.log_('Closing realtime connection.');\n      this.state_ = 2 /* DISCONNECTED */;\n      this.closeConnections_();\n      if (this.onDisconnect_) {\n        this.onDisconnect_();\n        this.onDisconnect_ = null;\n      }\n    }\n  };\n  /**\n   *\n   * @private\n   */\n  Connection.prototype.closeConnections_ = function () {\n    this.log_('Shutting down all connections');\n    if (this.conn_) {\n      this.conn_.close();\n      this.conn_ = null;\n    }\n    if (this.secondaryConn_) {\n      this.secondaryConn_.close();\n      this.secondaryConn_ = null;\n    }\n    if (this.healthyTimeout_) {\n      clearTimeout(this.healthyTimeout_);\n      this.healthyTimeout_ = null;\n    }\n  };\n  return Connection;\n}();\nexports.Connection = Connection;","map":{"version":3,"mappings":"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","names":["UPGRADE_TIMEOUT","DELAY_BEFORE_SENDING_EXTRA_REQUESTS","BYTES_SENT_HEALTHY_OVERRIDE","BYTES_RECEIVED_HEALTHY_OVERRIDE","MESSAGE_TYPE","MESSAGE_DATA","CONTROL_SHUTDOWN","CONTROL_RESET","CONTROL_ERROR","CONTROL_PONG","SWITCH_ACK","END_TRANSMISSION","PING","SERVER_HELLO","id","repoInfo_","onMessage_","onReady_","onDisconnect_","onKill_","lastSessionId","log_","util_1","transportManager_","TransportManager_1","start_","Connection","conn","initialTransport","conn_","nextTransportId_","undefined","primaryResponsesRequired_","onMessageReceived","connReceiver_","onConnectionLost","disconnReceiver_","tx_","rx_","secondaryConn_","isHealthy_","setTimeout","_this","open","Math","floor","healthyTimeout_ms","healthyTimeout_","bytesReceived","markConnectionHealthy","bytesSent","close","connectionCount","onConnectionLost_","everConnected","onSecondaryConnectionLost_","message","state_","onPrimaryMessageReceived_","onSecondaryMessageReceived_","dataMsg","msg","t","d","sendData_","connId","controlData","cmd","upgradeIfSecondaryHealthy_","secondaryResponsesRequired_","parsedData","layer","data","onSecondaryControl_","pendingDataMessages","push","Error","proceedWithUpgrade_","send","start","tryCleanupConnection","onControl_","onDataMessage_","onPrimaryResponse_","payload","onHandshake_","i","length","onConnectionShutdown_","onReset_","sendPingOnPrimaryIfNecessary_","handshake","timestamp","ts","version","v","host","h","sessionId","s","updateHost","onConnectionEstablished_","Constants_1","tryStartUpgrade_","upgradeTransport","startUpgrade_","onMessage","onDisconnect","closeConnections_","isCacheableHost","storage_1","remove","internalHost","reason","clearTimeout","exports"],"sources":["../src/realtime/Connection.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  error,\n  logWrapper,\n  requireKey,\n  setTimeoutNonBlocking,\n  warn\n} from '../core/util/util';\nimport { PersistentStorage } from '../core/storage/storage';\nimport { PROTOCOL_VERSION } from './Constants';\nimport { TransportManager } from './TransportManager';\nimport { RepoInfo } from '../core/RepoInfo';\nimport { Transport, TransportConstructor } from './Transport';\n\n// Abort upgrade attempt if it takes longer than 60s.\nconst UPGRADE_TIMEOUT = 60000;\n\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\nconst DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\n\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\nconst BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\nconst BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\n\nconst enum RealtimeState {\n  CONNECTING,\n  CONNECTED,\n  DISCONNECTED\n}\n\nconst MESSAGE_TYPE = 't';\nconst MESSAGE_DATA = 'd';\nconst CONTROL_SHUTDOWN = 's';\nconst CONTROL_RESET = 'r';\nconst CONTROL_ERROR = 'e';\nconst CONTROL_PONG = 'o';\nconst SWITCH_ACK = 'a';\nconst END_TRANSMISSION = 'n';\nconst PING = 'p';\n\nconst SERVER_HELLO = 'h';\n\n/**\n * Creates a new real-time connection to the server using whichever method works\n * best in the current browser.\n *\n * @constructor\n */\nexport class Connection {\n  connectionCount = 0;\n  pendingDataMessages: any[] = [];\n  sessionId: string;\n\n  private conn_: Transport;\n  private healthyTimeout_: number;\n  private isHealthy_: boolean;\n  private log_: (...args: any[]) => void;\n  private primaryResponsesRequired_: number;\n  private rx_: Transport;\n  private secondaryConn_: Transport;\n  private secondaryResponsesRequired_: number;\n  private state_ = RealtimeState.CONNECTING;\n  private transportManager_: TransportManager;\n  private tx_: Transport;\n\n  /**\n   * @param {!string} id - an id for this connection\n   * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to\n   * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives\n   * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.\n   * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost\n   * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.\n   * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\n   */\n  constructor(\n    public id: string,\n    private repoInfo_: RepoInfo,\n    private onMessage_: (a: Object) => void,\n    private onReady_: (a: number, b: string) => void,\n    private onDisconnect_: () => void,\n    private onKill_: (a: string) => void,\n    public lastSessionId?: string\n  ) {\n    this.log_ = logWrapper('c:' + this.id + ':');\n    this.transportManager_ = new TransportManager(repoInfo_);\n    this.log_('Connection created');\n    this.start_();\n  }\n\n  /**\n   * Starts a connection attempt\n   * @private\n   */\n  private start_() {\n    const conn = this.transportManager_.initialTransport();\n    this.conn_ = new conn(\n      this.nextTransportId_(),\n      this.repoInfo_,\n      undefined,\n      this.lastSessionId\n    );\n\n    // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n    this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\n\n    const onMessageReceived = this.connReceiver_(this.conn_);\n    const onConnectionLost = this.disconnReceiver_(this.conn_);\n    this.tx_ = this.conn_;\n    this.rx_ = this.conn_;\n    this.secondaryConn_ = null;\n    this.isHealthy_ = false;\n\n    /*\n     * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\n     * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\n     * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\n     * still have the context of your originating frame.\n     */\n    setTimeout(() => {\n      // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\n      this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);\n    }, Math.floor(0));\n\n    const healthyTimeout_ms = conn['healthyTimeout'] || 0;\n    if (healthyTimeout_ms > 0) {\n      this.healthyTimeout_ = setTimeoutNonBlocking(() => {\n        this.healthyTimeout_ = null;\n        if (!this.isHealthy_) {\n          if (\n            this.conn_ &&\n            this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE\n          ) {\n            this.log_(\n              'Connection exceeded healthy timeout but has received ' +\n                this.conn_.bytesReceived +\n                ' bytes.  Marking connection healthy.'\n            );\n            this.isHealthy_ = true;\n            this.conn_.markConnectionHealthy();\n          } else if (\n            this.conn_ &&\n            this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE\n          ) {\n            this.log_(\n              'Connection exceeded healthy timeout but has sent ' +\n                this.conn_.bytesSent +\n                ' bytes.  Leaving connection alive.'\n            );\n            // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n            // the server.\n          } else {\n            this.log_('Closing unhealthy connection after timeout.');\n            this.close();\n          }\n        }\n      }, Math.floor(healthyTimeout_ms)) as any;\n    }\n  }\n\n  /**\n   * @return {!string}\n   * @private\n   */\n  private nextTransportId_(): string {\n    return 'c:' + this.id + ':' + this.connectionCount++;\n  }\n\n  private disconnReceiver_(conn) {\n    return everConnected => {\n      if (conn === this.conn_) {\n        this.onConnectionLost_(everConnected);\n      } else if (conn === this.secondaryConn_) {\n        this.log_('Secondary connection lost.');\n        this.onSecondaryConnectionLost_();\n      } else {\n        this.log_('closing an old connection');\n      }\n    };\n  }\n\n  private connReceiver_(conn: Transport) {\n    return (message: object) => {\n      if (this.state_ != RealtimeState.DISCONNECTED) {\n        if (conn === this.rx_) {\n          this.onPrimaryMessageReceived_(message);\n        } else if (conn === this.secondaryConn_) {\n          this.onSecondaryMessageReceived_(message);\n        } else {\n          this.log_('message on old connection');\n        }\n      }\n    };\n  }\n\n  /**\n   *\n   * @param {Object} dataMsg An arbitrary data message to be sent to the server\n   */\n  sendRequest(dataMsg: object) {\n    // wrap in a data message envelope and send it on\n    const msg = { t: 'd', d: dataMsg };\n    this.sendData_(msg);\n  }\n\n  tryCleanupConnection() {\n    if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\n      this.log_(\n        'cleaning up and promoting a connection: ' + this.secondaryConn_.connId\n      );\n      this.conn_ = this.secondaryConn_;\n      this.secondaryConn_ = null;\n      // the server will shutdown the old connection\n    }\n  }\n\n  private onSecondaryControl_(controlData: { [k: string]: any }) {\n    if (MESSAGE_TYPE in controlData) {\n      const cmd = controlData[MESSAGE_TYPE] as string;\n      if (cmd === SWITCH_ACK) {\n        this.upgradeIfSecondaryHealthy_();\n      } else if (cmd === CONTROL_RESET) {\n        // Most likely the session wasn't valid. Abandon the switch attempt\n        this.log_('Got a reset on secondary, closing it');\n        this.secondaryConn_.close();\n        // If we were already using this connection for something, than we need to fully close\n        if (\n          this.tx_ === this.secondaryConn_ ||\n          this.rx_ === this.secondaryConn_\n        ) {\n          this.close();\n        }\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on secondary.');\n        this.secondaryResponsesRequired_--;\n        this.upgradeIfSecondaryHealthy_();\n      }\n    }\n  }\n\n  private onSecondaryMessageReceived_(parsedData: object) {\n    const layer: string = requireKey('t', parsedData);\n    const data: any = requireKey('d', parsedData);\n    if (layer == 'c') {\n      this.onSecondaryControl_(data);\n    } else if (layer == 'd') {\n      // got a data message, but we're still second connection. Need to buffer it up\n      this.pendingDataMessages.push(data);\n    } else {\n      throw new Error('Unknown protocol layer: ' + layer);\n    }\n  }\n\n  private upgradeIfSecondaryHealthy_() {\n    if (this.secondaryResponsesRequired_ <= 0) {\n      this.log_('Secondary connection is healthy.');\n      this.isHealthy_ = true;\n      this.secondaryConn_.markConnectionHealthy();\n      this.proceedWithUpgrade_();\n    } else {\n      // Send a ping to make sure the connection is healthy.\n      this.log_('sending ping on secondary.');\n      this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });\n    }\n  }\n\n  private proceedWithUpgrade_() {\n    // tell this connection to consider itself open\n    this.secondaryConn_.start();\n    // send ack\n    this.log_('sending client ack on secondary');\n    this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });\n\n    // send end packet on primary transport, switch to sending on this one\n    // can receive on this one, buffer responses until end received on primary transport\n    this.log_('Ending transmission on primary');\n    this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });\n    this.tx_ = this.secondaryConn_;\n\n    this.tryCleanupConnection();\n  }\n\n  private onPrimaryMessageReceived_(parsedData: { [k: string]: any }) {\n    // Must refer to parsedData properties in quotes, so closure doesn't touch them.\n    const layer: string = requireKey('t', parsedData);\n    const data: any = requireKey('d', parsedData);\n    if (layer == 'c') {\n      this.onControl_(data);\n    } else if (layer == 'd') {\n      this.onDataMessage_(data);\n    }\n  }\n\n  private onDataMessage_(message: any) {\n    this.onPrimaryResponse_();\n\n    // We don't do anything with data messages, just kick them up a level\n    this.onMessage_(message);\n  }\n\n  private onPrimaryResponse_() {\n    if (!this.isHealthy_) {\n      this.primaryResponsesRequired_--;\n      if (this.primaryResponsesRequired_ <= 0) {\n        this.log_('Primary connection is healthy.');\n        this.isHealthy_ = true;\n        this.conn_.markConnectionHealthy();\n      }\n    }\n  }\n\n  private onControl_(controlData: { [k: string]: any }) {\n    const cmd: string = requireKey(MESSAGE_TYPE, controlData);\n    if (MESSAGE_DATA in controlData) {\n      const payload = controlData[MESSAGE_DATA];\n      if (cmd === SERVER_HELLO) {\n        this.onHandshake_(payload);\n      } else if (cmd === END_TRANSMISSION) {\n        this.log_('recvd end transmission on primary');\n        this.rx_ = this.secondaryConn_;\n        for (let i = 0; i < this.pendingDataMessages.length; ++i) {\n          this.onDataMessage_(this.pendingDataMessages[i]);\n        }\n        this.pendingDataMessages = [];\n        this.tryCleanupConnection();\n      } else if (cmd === CONTROL_SHUTDOWN) {\n        // This was previously the 'onKill' callback passed to the lower-level connection\n        // payload in this case is the reason for the shutdown. Generally a human-readable error\n        this.onConnectionShutdown_(payload);\n      } else if (cmd === CONTROL_RESET) {\n        // payload in this case is the host we should contact\n        this.onReset_(payload);\n      } else if (cmd === CONTROL_ERROR) {\n        error('Server Error: ' + payload);\n      } else if (cmd === CONTROL_PONG) {\n        this.log_('got pong on primary.');\n        this.onPrimaryResponse_();\n        this.sendPingOnPrimaryIfNecessary_();\n      } else {\n        error('Unknown control packet command: ' + cmd);\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {Object} handshake The handshake data returned from the server\n   * @private\n   */\n  private onHandshake_(handshake: {\n    ts: number;\n    v: string;\n    h: string;\n    s: string;\n  }) {\n    const timestamp = handshake.ts;\n    const version = handshake.v;\n    const host = handshake.h;\n    this.sessionId = handshake.s;\n    this.repoInfo_.updateHost(host);\n    // if we've already closed the connection, then don't bother trying to progress further\n    if (this.state_ == RealtimeState.CONNECTING) {\n      this.conn_.start();\n      this.onConnectionEstablished_(this.conn_, timestamp);\n      if (PROTOCOL_VERSION !== version) {\n        warn('Protocol version mismatch detected');\n      }\n      // TODO: do we want to upgrade? when? maybe a delay?\n      this.tryStartUpgrade_();\n    }\n  }\n\n  private tryStartUpgrade_() {\n    const conn = this.transportManager_.upgradeTransport();\n    if (conn) {\n      this.startUpgrade_(conn);\n    }\n  }\n\n  private startUpgrade_(conn: TransportConstructor) {\n    this.secondaryConn_ = new conn(\n      this.nextTransportId_(),\n      this.repoInfo_,\n      this.sessionId\n    );\n    // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n    // can consider the transport healthy.\n    this.secondaryResponsesRequired_ =\n      conn['responsesRequiredToBeHealthy'] || 0;\n\n    const onMessage = this.connReceiver_(this.secondaryConn_);\n    const onDisconnect = this.disconnReceiver_(this.secondaryConn_);\n    this.secondaryConn_.open(onMessage, onDisconnect);\n\n    // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\n    setTimeoutNonBlocking(() => {\n      if (this.secondaryConn_) {\n        this.log_('Timed out trying to upgrade.');\n        this.secondaryConn_.close();\n      }\n    }, Math.floor(UPGRADE_TIMEOUT));\n  }\n\n  private onReset_(host: string) {\n    this.log_('Reset packet received.  New host: ' + host);\n    this.repoInfo_.updateHost(host);\n    // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n    // We don't currently support resets after the connection has already been established\n    if (this.state_ === RealtimeState.CONNECTED) {\n      this.close();\n    } else {\n      // Close whatever connections we have open and start again.\n      this.closeConnections_();\n      this.start_();\n    }\n  }\n\n  private onConnectionEstablished_(conn: Transport, timestamp: number) {\n    this.log_('Realtime connection established.');\n    this.conn_ = conn;\n    this.state_ = RealtimeState.CONNECTED;\n\n    if (this.onReady_) {\n      this.onReady_(timestamp, this.sessionId);\n      this.onReady_ = null;\n    }\n\n    // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n    // send some pings.\n    if (this.primaryResponsesRequired_ === 0) {\n      this.log_('Primary connection is healthy.');\n      this.isHealthy_ = true;\n    } else {\n      setTimeoutNonBlocking(() => {\n        this.sendPingOnPrimaryIfNecessary_();\n      }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\n    }\n  }\n\n  private sendPingOnPrimaryIfNecessary_() {\n    // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\n    if (!this.isHealthy_ && this.state_ === RealtimeState.CONNECTED) {\n      this.log_('sending ping on primary.');\n      this.sendData_({ t: 'c', d: { t: PING, d: {} } });\n    }\n  }\n\n  private onSecondaryConnectionLost_() {\n    const conn = this.secondaryConn_;\n    this.secondaryConn_ = null;\n    if (this.tx_ === conn || this.rx_ === conn) {\n      // we are relying on this connection already in some capacity. Therefore, a failure is real\n      this.close();\n    }\n  }\n\n  /**\n   *\n   * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if\n   * we should flush the host cache\n   * @private\n   */\n  private onConnectionLost_(everConnected: boolean) {\n    this.conn_ = null;\n\n    // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n    // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\n    if (!everConnected && this.state_ === RealtimeState.CONNECTING) {\n      this.log_('Realtime connection failed.');\n      // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\n      if (this.repoInfo_.isCacheableHost()) {\n        PersistentStorage.remove('host:' + this.repoInfo_.host);\n        // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\n        this.repoInfo_.internalHost = this.repoInfo_.host;\n      }\n    } else if (this.state_ === RealtimeState.CONNECTED) {\n      this.log_('Realtime connection lost.');\n    }\n\n    this.close();\n  }\n\n  /**\n   *\n   * @param {string} reason\n   * @private\n   */\n  private onConnectionShutdown_(reason: string) {\n    this.log_('Connection shutdown command received. Shutting down...');\n\n    if (this.onKill_) {\n      this.onKill_(reason);\n      this.onKill_ = null;\n    }\n\n    // We intentionally don't want to fire onDisconnect (kill is a different case),\n    // so clear the callback.\n    this.onDisconnect_ = null;\n\n    this.close();\n  }\n\n  private sendData_(data: object) {\n    if (this.state_ !== RealtimeState.CONNECTED) {\n      throw 'Connection is not connected';\n    } else {\n      this.tx_.send(data);\n    }\n  }\n\n  /**\n   * Cleans up this connection, calling the appropriate callbacks\n   */\n  close() {\n    if (this.state_ !== RealtimeState.DISCONNECTED) {\n      this.log_('Closing realtime connection.');\n      this.state_ = RealtimeState.DISCONNECTED;\n\n      this.closeConnections_();\n\n      if (this.onDisconnect_) {\n        this.onDisconnect_();\n        this.onDisconnect_ = null;\n      }\n    }\n  }\n\n  /**\n   *\n   * @private\n   */\n  private closeConnections_() {\n    this.log_('Shutting down all connections');\n    if (this.conn_) {\n      this.conn_.close();\n      this.conn_ = null;\n    }\n\n    if (this.secondaryConn_) {\n      this.secondaryConn_.close();\n      this.secondaryConn_ = null;\n    }\n\n    if (this.healthyTimeout_) {\n      clearTimeout(this.healthyTimeout_);\n      this.healthyTimeout_ = null;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}