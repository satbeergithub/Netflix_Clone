{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"@firebase/util\");\nvar Path_1 = require(\"./util/Path\");\nvar CompoundWrite_1 = require(\"./CompoundWrite\");\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\n/**\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\n * and addMerge(), and removed with removeWrite().\n *\n * @constructor\n */\nvar WriteTree = /** @class */function () {\n  function WriteTree() {\n    /**\n     * A tree tracking the result of applying all visible writes.  This does not include transactions with\n     * applyLocally=false or writes that are completely shadowed by other writes.\n     *\n     * @type {!CompoundWrite}\n     * @private\n     */\n    this.visibleWrites_ = CompoundWrite_1.CompoundWrite.Empty;\n    /**\n     * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\n     * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\n     * used by transactions).\n     *\n     * @type {!Array.<!WriteRecord>}\n     * @private\n     */\n    this.allWrites_ = [];\n    this.lastWriteId_ = -1;\n  }\n  /**\n   * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\n   *\n   * @param {!Path} path\n   * @return {!WriteTreeRef}\n   */\n  WriteTree.prototype.childWrites = function (path) {\n    return new WriteTreeRef(path, this);\n  };\n  /**\n   * Record a new overwrite from user code.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} writeId\n   * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches\n   */\n  WriteTree.prototype.addOverwrite = function (path, snap, writeId, visible) {\n    util_2.assert(writeId > this.lastWriteId_, 'Stacking an older write on top of newer ones');\n    if (visible === undefined) {\n      visible = true;\n    }\n    this.allWrites_.push({\n      path: path,\n      snap: snap,\n      writeId: writeId,\n      visible: visible\n    });\n    if (visible) {\n      this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);\n    }\n    this.lastWriteId_ = writeId;\n  };\n  /**\n   * Record a new merge from user code.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   */\n  WriteTree.prototype.addMerge = function (path, changedChildren, writeId) {\n    util_2.assert(writeId > this.lastWriteId_, 'Stacking an older merge on top of newer ones');\n    this.allWrites_.push({\n      path: path,\n      children: changedChildren,\n      writeId: writeId,\n      visible: true\n    });\n    this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);\n    this.lastWriteId_ = writeId;\n  };\n  /**\n   * @param {!number} writeId\n   * @return {?WriteRecord}\n   */\n  WriteTree.prototype.getWrite = function (writeId) {\n    for (var i = 0; i < this.allWrites_.length; i++) {\n      var record = this.allWrites_[i];\n      if (record.writeId === writeId) {\n        return record;\n      }\n    }\n    return null;\n  };\n  /**\n   * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\n   * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\n   *\n   * @param {!number} writeId\n   * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise\n   * events as a result).\n   */\n  WriteTree.prototype.removeWrite = function (writeId) {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n    var _this = this;\n    var idx = this.allWrites_.findIndex(function (s) {\n      return s.writeId === writeId;\n    });\n    util_2.assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\n    var writeToRemove = this.allWrites_[idx];\n    this.allWrites_.splice(idx, 1);\n    var removedWriteWasVisible = writeToRemove.visible;\n    var removedWriteOverlapsWithOtherWrites = false;\n    var i = this.allWrites_.length - 1;\n    while (removedWriteWasVisible && i >= 0) {\n      var currentWrite = this.allWrites_[i];\n      if (currentWrite.visible) {\n        if (i >= idx && this.recordContainsPath_(currentWrite, writeToRemove.path)) {\n          // The removed write was completely shadowed by a subsequent write.\n          removedWriteWasVisible = false;\n        } else if (writeToRemove.path.contains(currentWrite.path)) {\n          // Either we're covering some writes or they're covering part of us (depending on which came first).\n          removedWriteOverlapsWithOtherWrites = true;\n        }\n      }\n      i--;\n    }\n    if (!removedWriteWasVisible) {\n      return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n      // There's some shadowing going on. Just rebuild the visible writes from scratch.\n      this.resetTree_();\n      return true;\n    } else {\n      // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n      if (writeToRemove.snap) {\n        this.visibleWrites_ = this.visibleWrites_.removeWrite(writeToRemove.path);\n      } else {\n        var children = writeToRemove.children;\n        util_1.forEach(children, function (childName) {\n          _this.visibleWrites_ = _this.visibleWrites_.removeWrite(writeToRemove.path.child(childName));\n        });\n      }\n      return true;\n    }\n  };\n  /**\n   * Return a complete snapshot for the given path if there's visible write data at that path, else null.\n   * No server data is considered.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  WriteTree.prototype.getCompleteWriteData = function (path) {\n    return this.visibleWrites_.getCompleteNode(path);\n  };\n  /**\n   * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\n   * writes), attempt to calculate a complete snapshot for the given path\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  WriteTree.prototype.calcCompleteEventCache = function (treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n      var shadowingNode = this.visibleWrites_.getCompleteNode(treePath);\n      if (shadowingNode != null) {\n        return shadowingNode;\n      } else {\n        var subMerge = this.visibleWrites_.childCompoundWrite(treePath);\n        if (subMerge.isEmpty()) {\n          return completeServerCache;\n        } else if (completeServerCache == null && !subMerge.hasCompleteWrite(Path_1.Path.Empty)) {\n          // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n          return null;\n        } else {\n          var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          return subMerge.apply(layeredCache);\n        }\n      }\n    } else {\n      var merge = this.visibleWrites_.childCompoundWrite(treePath);\n      if (!includeHiddenWrites && merge.isEmpty()) {\n        return completeServerCache;\n      } else {\n        // If the server cache is null, and we don't have a complete cache, we need to return null\n        if (!includeHiddenWrites && completeServerCache == null && !merge.hasCompleteWrite(Path_1.Path.Empty)) {\n          return null;\n        } else {\n          var filter = function (write) {\n            return (write.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write.writeId)) && (write.path.contains(treePath) || treePath.contains(write.path));\n          };\n          var mergeAtPath = WriteTree.layerTree_(this.allWrites_, filter, treePath);\n          var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          return mergeAtPath.apply(layeredCache);\n        }\n      }\n    }\n  };\n  /**\n   * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\n   * Used when creating new views, to pre-fill their complete event children snapshot.\n   *\n   * @param {!Path} treePath\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  WriteTree.prototype.calcCompleteEventChildren = function (treePath, completeServerChildren) {\n    var completeChildren = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    var topLevelSet = this.visibleWrites_.getCompleteNode(treePath);\n    if (topLevelSet) {\n      if (!topLevelSet.isLeafNode()) {\n        // we're shadowing everything. Return the children.\n        topLevelSet.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childSnap) {\n          completeChildren = completeChildren.updateImmediateChild(childName, childSnap);\n        });\n      }\n      return completeChildren;\n    } else if (completeServerChildren) {\n      // Layer any children we have on top of this\n      // We know we don't have a top-level set, so just enumerate existing children\n      var merge_1 = this.visibleWrites_.childCompoundWrite(treePath);\n      completeServerChildren.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {\n        var node = merge_1.childCompoundWrite(new Path_1.Path(childName)).apply(childNode);\n        completeChildren = completeChildren.updateImmediateChild(childName, node);\n      });\n      // Add any complete children we have from the set\n      merge_1.getCompleteChildren().forEach(function (namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n      });\n      return completeChildren;\n    } else {\n      // We don't have anything to layer on top of. Layer on any children we have\n      // Note that we can return an empty snap if we have a defined delete\n      var merge = this.visibleWrites_.childCompoundWrite(treePath);\n      merge.getCompleteChildren().forEach(function (namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n      });\n      return completeChildren;\n    }\n  };\n  /**\n   * Given that the underlying server data has updated, determine what, if anything, needs to be\n   * applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events\n   *\n   * Either existingEventSnap or existingServerSnap must exist\n   *\n   * @param {!Path} treePath\n   * @param {!Path} childPath\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  WriteTree.prototype.calcEventCacheAfterServerOverwrite = function (treePath, childPath, existingEventSnap, existingServerSnap) {\n    util_2.assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');\n    var path = treePath.child(childPath);\n    if (this.visibleWrites_.hasCompleteWrite(path)) {\n      // At this point we can probably guarantee that we're in case 2, meaning no events\n      // May need to check visibility while doing the findRootMostValueAndPath call\n      return null;\n    } else {\n      // No complete shadowing. We're either partially shadowing or not shadowing at all.\n      var childMerge = this.visibleWrites_.childCompoundWrite(path);\n      if (childMerge.isEmpty()) {\n        // We're not shadowing at all. Case 1\n        return existingServerSnap.getChild(childPath);\n      } else {\n        // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n        // However this is tricky to find out, since user updates don't necessary change the server\n        // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n        // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n        // only check if the updates change the serverNode.\n        // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n        return childMerge.apply(existingServerSnap.getChild(childPath));\n      }\n    }\n  };\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!Path} treePath\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerSnap\n   * @return {?Node}\n   */\n  WriteTree.prototype.calcCompleteChild = function (treePath, childKey, existingServerSnap) {\n    var path = treePath.child(childKey);\n    var shadowingNode = this.visibleWrites_.getCompleteNode(path);\n    if (shadowingNode != null) {\n      return shadowingNode;\n    } else {\n      if (existingServerSnap.isCompleteForChild(childKey)) {\n        var childMerge = this.visibleWrites_.childCompoundWrite(path);\n        return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));\n      } else {\n        return null;\n      }\n    }\n  };\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  WriteTree.prototype.shadowingWrite = function (path) {\n    return this.visibleWrites_.getCompleteNode(path);\n  };\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window.\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  WriteTree.prototype.calcIndexedSlice = function (treePath, completeServerData, startPost, count, reverse, index) {\n    var toIterate;\n    var merge = this.visibleWrites_.childCompoundWrite(treePath);\n    var shadowingNode = merge.getCompleteNode(Path_1.Path.Empty);\n    if (shadowingNode != null) {\n      toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n      toIterate = merge.apply(completeServerData);\n    } else {\n      // no children to iterate on\n      return [];\n    }\n    toIterate = toIterate.withIndex(index);\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n      var nodes = [];\n      var cmp = index.getCompare();\n      var iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);\n      var next = iter.getNext();\n      while (next && nodes.length < count) {\n        if (cmp(next, startPost) !== 0) {\n          nodes.push(next);\n        }\n        next = iter.getNext();\n      }\n      return nodes;\n    } else {\n      return [];\n    }\n  };\n  /**\n   * @param {!WriteRecord} writeRecord\n   * @param {!Path} path\n   * @return {boolean}\n   * @private\n   */\n  WriteTree.prototype.recordContainsPath_ = function (writeRecord, path) {\n    if (writeRecord.snap) {\n      return writeRecord.path.contains(path);\n    } else {\n      // findKey can return undefined, so use !! to coerce to boolean\n      return !!util_1.findKey(writeRecord.children, function (childSnap, childName) {\n        return writeRecord.path.child(childName).contains(path);\n      });\n    }\n  };\n  /**\n   * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\n   * @private\n   */\n  WriteTree.prototype.resetTree_ = function () {\n    this.visibleWrites_ = WriteTree.layerTree_(this.allWrites_, WriteTree.DefaultFilter_, Path_1.Path.Empty);\n    if (this.allWrites_.length > 0) {\n      this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;\n    } else {\n      this.lastWriteId_ = -1;\n    }\n  };\n  /**\n   * The default filter used when constructing the tree. Keep everything that's visible.\n   *\n   * @param {!WriteRecord} write\n   * @return {boolean}\n   * @private\n   */\n  WriteTree.DefaultFilter_ = function (write) {\n    return write.visible;\n  };\n  /**\n   * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\n   * event data at that path.\n   *\n   * @param {!Array.<!WriteRecord>} writes\n   * @param {!function(!WriteRecord):boolean} filter\n   * @param {!Path} treeRoot\n   * @return {!CompoundWrite}\n   * @private\n   */\n  WriteTree.layerTree_ = function (writes, filter, treeRoot) {\n    var compoundWrite = CompoundWrite_1.CompoundWrite.Empty;\n    for (var i = 0; i < writes.length; ++i) {\n      var write = writes[i];\n      // Theory, a later set will either:\n      // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n      // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n      if (filter(write)) {\n        var writePath = write.path;\n        var relativePath = void 0;\n        if (write.snap) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path_1.Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrite(relativePath, write.snap);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path_1.Path.relativePath(writePath, treeRoot);\n            compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, write.snap.getChild(relativePath));\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else if (write.children) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path_1.Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrites(relativePath, write.children);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path_1.Path.relativePath(writePath, treeRoot);\n            if (relativePath.isEmpty()) {\n              compoundWrite = compoundWrite.addWrites(Path_1.Path.Empty, write.children);\n            } else {\n              var child = util_1.safeGet(write.children, relativePath.getFront());\n              if (child) {\n                // There exists a child in this node that matches the root path\n                var deepNode = child.getChild(relativePath.popFront());\n                compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, deepNode);\n              }\n            }\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else {\n          throw util_2.assertionError('WriteRecord should have .snap or .children');\n        }\n      }\n    }\n    return compoundWrite;\n  };\n  return WriteTree;\n}();\nexports.WriteTree = WriteTree;\n/**\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\n * just proxy to the underlying WriteTree.\n *\n * @constructor\n */\nvar WriteTreeRef = /** @class */function () {\n  /**\n   * @param {!Path} path\n   * @param {!WriteTree} writeTree\n   */\n  function WriteTreeRef(path, writeTree) {\n    this.treePath_ = path;\n    this.writeTree_ = writeTree;\n  }\n  /**\n   * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\n   * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\n   * can lead to a more expensive calculation.\n   *\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  WriteTreeRef.prototype.calcCompleteEventCache = function (completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    return this.writeTree_.calcCompleteEventCache(this.treePath_, completeServerCache, writeIdsToExclude, includeHiddenWrites);\n  };\n  /**\n   * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\n   * mix of the given server data and write data.\n   *\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  WriteTreeRef.prototype.calcCompleteEventChildren = function (completeServerChildren) {\n    return this.writeTree_.calcCompleteEventChildren(this.treePath_, completeServerChildren);\n  };\n  /**\n   * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\n   * if anything, needs to be applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events should be raised\n   *\n   * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\n   *\n   * @param {!Path} path\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  WriteTreeRef.prototype.calcEventCacheAfterServerOverwrite = function (path, existingEventSnap, existingServerSnap) {\n    return this.writeTree_.calcEventCacheAfterServerOverwrite(this.treePath_, path, existingEventSnap, existingServerSnap);\n  };\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  WriteTreeRef.prototype.shadowingWrite = function (path) {\n    return this.writeTree_.shadowingWrite(this.treePath_.child(path));\n  };\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window\n   *\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  WriteTreeRef.prototype.calcIndexedSlice = function (completeServerData, startPost, count, reverse, index) {\n    return this.writeTree_.calcIndexedSlice(this.treePath_, completeServerData, startPost, count, reverse, index);\n  };\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerCache\n   * @return {?Node}\n   */\n  WriteTreeRef.prototype.calcCompleteChild = function (childKey, existingServerCache) {\n    return this.writeTree_.calcCompleteChild(this.treePath_, childKey, existingServerCache);\n  };\n  /**\n   * Return a WriteTreeRef for a child.\n   *\n   * @param {string} childName\n   * @return {!WriteTreeRef}\n   */\n  WriteTreeRef.prototype.child = function (childName) {\n    return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);\n  };\n  return WriteTreeRef;\n}();\nexports.WriteTreeRef = WriteTreeRef;","map":{"version":3,"mappings":"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","names":["CompoundWrite_1","Empty","WriteTree","path","WriteTreeRef","snap","writeId","visible","util_2","lastWriteId_","undefined","allWrites_","push","visibleWrites_","addWrite","changedChildren","children","addWrites","i","length","record","idx","findIndex","s","writeToRemove","splice","removedWriteWasVisible","removedWriteOverlapsWithOtherWrites","currentWrite","recordContainsPath_","contains","resetTree_","removeWrite","util_1","childName","_this","child","getCompleteNode","treePath","completeServerCache","writeIdsToExclude","includeHiddenWrites","shadowingNode","subMerge","childCompoundWrite","isEmpty","hasCompleteWrite","Path_1","layeredCache","ChildrenNode_1","EMPTY_NODE","apply","merge","filter","write","indexOf","mergeAtPath","layerTree_","completeServerChildren","completeChildren","topLevelSet","isLeafNode","forEachChild","PriorityIndex_1","childSnap","updateImmediateChild","merge_1","childNode","node","getCompleteChildren","forEach","namedNode","name","childPath","existingEventSnap","existingServerSnap","childMerge","getChild","childKey","isCompleteForChild","getNode","getImmediateChild","completeServerData","startPost","count","reverse","index","toIterate","withIndex","nodes","cmp","getCompare","iter","getReverseIteratorFrom","getIteratorFrom","next","getNext","writeRecord","DefaultFilter_","writes","treeRoot","compoundWrite","writePath","relativePath","getFront","deepNode","popFront","exports","writeTree","treePath_","writeTree_","calcCompleteEventCache","calcCompleteEventChildren","calcEventCacheAfterServerOverwrite","shadowingWrite","calcIndexedSlice","existingServerCache","calcCompleteChild"],"sources":["../src/core/WriteTree.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { findKey, forEach, safeGet } from '@firebase/util';\nimport { assert, assertionError } from '@firebase/util';\nimport { Path } from './util/Path';\nimport { CompoundWrite } from './CompoundWrite';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { NamedNode, Node } from './snap/Node';\nimport { CacheNode } from './view/CacheNode';\nimport { Index } from './snap/indexes/Index';\n\n/**\n * Defines a single user-initiated write operation. May be the result of a set(), transaction(), or update() call. In\n * the case of a set() or transaction, snap wil be non-null.  In the case of an update(), children will be non-null.\n */\nexport interface WriteRecord {\n  writeId: number;\n  path: Path;\n  snap?: Node | null;\n  children?: { [k: string]: Node } | null;\n  visible: boolean;\n}\n\n/**\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\n * and addMerge(), and removed with removeWrite().\n *\n * @constructor\n */\nexport class WriteTree {\n  /**\n   * A tree tracking the result of applying all visible writes.  This does not include transactions with\n   * applyLocally=false or writes that are completely shadowed by other writes.\n   *\n   * @type {!CompoundWrite}\n   * @private\n   */\n  private visibleWrites_: CompoundWrite = CompoundWrite.Empty;\n\n  /**\n   * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\n   * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\n   * used by transactions).\n   *\n   * @type {!Array.<!WriteRecord>}\n   * @private\n   */\n  private allWrites_: WriteRecord[] = [];\n\n  private lastWriteId_ = -1;\n\n  /**\n   * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\n   *\n   * @param {!Path} path\n   * @return {!WriteTreeRef}\n   */\n  childWrites(path: Path): WriteTreeRef {\n    return new WriteTreeRef(path, this);\n  }\n\n  /**\n   * Record a new overwrite from user code.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} writeId\n   * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches\n   */\n  addOverwrite(path: Path, snap: Node, writeId: number, visible?: boolean) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older write on top of newer ones'\n    );\n    if (visible === undefined) {\n      visible = true;\n    }\n    this.allWrites_.push({\n      path: path,\n      snap: snap,\n      writeId: writeId,\n      visible: visible\n    });\n\n    if (visible) {\n      this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);\n    }\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * Record a new merge from user code.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   */\n  addMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    writeId: number\n  ) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older merge on top of newer ones'\n    );\n    this.allWrites_.push({\n      path: path,\n      children: changedChildren,\n      writeId: writeId,\n      visible: true\n    });\n\n    this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * @param {!number} writeId\n   * @return {?WriteRecord}\n   */\n  getWrite(writeId: number): WriteRecord | null {\n    for (let i = 0; i < this.allWrites_.length; i++) {\n      const record = this.allWrites_[i];\n      if (record.writeId === writeId) {\n        return record;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\n   * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\n   *\n   * @param {!number} writeId\n   * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise\n   * events as a result).\n   */\n  removeWrite(writeId: number): boolean {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n\n    const idx = this.allWrites_.findIndex(function(s) {\n      return s.writeId === writeId;\n    });\n    assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\n    const writeToRemove = this.allWrites_[idx];\n    this.allWrites_.splice(idx, 1);\n\n    let removedWriteWasVisible = writeToRemove.visible;\n    let removedWriteOverlapsWithOtherWrites = false;\n\n    let i = this.allWrites_.length - 1;\n\n    while (removedWriteWasVisible && i >= 0) {\n      const currentWrite = this.allWrites_[i];\n      if (currentWrite.visible) {\n        if (\n          i >= idx &&\n          this.recordContainsPath_(currentWrite, writeToRemove.path)\n        ) {\n          // The removed write was completely shadowed by a subsequent write.\n          removedWriteWasVisible = false;\n        } else if (writeToRemove.path.contains(currentWrite.path)) {\n          // Either we're covering some writes or they're covering part of us (depending on which came first).\n          removedWriteOverlapsWithOtherWrites = true;\n        }\n      }\n      i--;\n    }\n\n    if (!removedWriteWasVisible) {\n      return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n      // There's some shadowing going on. Just rebuild the visible writes from scratch.\n      this.resetTree_();\n      return true;\n    } else {\n      // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n      if (writeToRemove.snap) {\n        this.visibleWrites_ = this.visibleWrites_.removeWrite(\n          writeToRemove.path\n        );\n      } else {\n        const children = writeToRemove.children;\n        forEach(children, (childName: string) => {\n          this.visibleWrites_ = this.visibleWrites_.removeWrite(\n            writeToRemove.path.child(childName)\n          );\n        });\n      }\n      return true;\n    }\n  }\n\n  /**\n   * Return a complete snapshot for the given path if there's visible write data at that path, else null.\n   * No server data is considered.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  getCompleteWriteData(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\n   * writes), attempt to calculate a complete snapshot for the given path\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    treePath: Path,\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n      const shadowingNode = this.visibleWrites_.getCompleteNode(treePath);\n      if (shadowingNode != null) {\n        return shadowingNode;\n      } else {\n        const subMerge = this.visibleWrites_.childCompoundWrite(treePath);\n        if (subMerge.isEmpty()) {\n          return completeServerCache;\n        } else if (\n          completeServerCache == null &&\n          !subMerge.hasCompleteWrite(Path.Empty)\n        ) {\n          // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n          return null;\n        } else {\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return subMerge.apply(layeredCache);\n        }\n      }\n    } else {\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      if (!includeHiddenWrites && merge.isEmpty()) {\n        return completeServerCache;\n      } else {\n        // If the server cache is null, and we don't have a complete cache, we need to return null\n        if (\n          !includeHiddenWrites &&\n          completeServerCache == null &&\n          !merge.hasCompleteWrite(Path.Empty)\n        ) {\n          return null;\n        } else {\n          const filter = function(write: WriteRecord) {\n            return (\n              (write.visible || includeHiddenWrites) &&\n              (!writeIdsToExclude ||\n                !~writeIdsToExclude.indexOf(write.writeId)) &&\n              (write.path.contains(treePath) || treePath.contains(write.path))\n            );\n          };\n          const mergeAtPath = WriteTree.layerTree_(\n            this.allWrites_,\n            filter,\n            treePath\n          );\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return mergeAtPath.apply(layeredCache);\n        }\n      }\n    }\n  }\n\n  /**\n   * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\n   * Used when creating new views, to pre-fill their complete event children snapshot.\n   *\n   * @param {!Path} treePath\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(\n    treePath: Path,\n    completeServerChildren: ChildrenNode | null\n  ) {\n    let completeChildren = ChildrenNode.EMPTY_NODE as Node;\n    const topLevelSet = this.visibleWrites_.getCompleteNode(treePath);\n    if (topLevelSet) {\n      if (!topLevelSet.isLeafNode()) {\n        // we're shadowing everything. Return the children.\n        topLevelSet.forEachChild(PRIORITY_INDEX, function(\n          childName,\n          childSnap\n        ) {\n          completeChildren = completeChildren.updateImmediateChild(\n            childName,\n            childSnap\n          );\n        });\n      }\n      return completeChildren;\n    } else if (completeServerChildren) {\n      // Layer any children we have on top of this\n      // We know we don't have a top-level set, so just enumerate existing children\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      completeServerChildren.forEachChild(PRIORITY_INDEX, function(\n        childName,\n        childNode\n      ) {\n        const node = merge\n          .childCompoundWrite(new Path(childName))\n          .apply(childNode);\n        completeChildren = completeChildren.updateImmediateChild(\n          childName,\n          node\n        );\n      });\n      // Add any complete children we have from the set\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    } else {\n      // We don't have anything to layer on top of. Layer on any children we have\n      // Note that we can return an empty snap if we have a defined delete\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    }\n  }\n\n  /**\n   * Given that the underlying server data has updated, determine what, if anything, needs to be\n   * applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events\n   *\n   * Either existingEventSnap or existingServerSnap must exist\n   *\n   * @param {!Path} treePath\n   * @param {!Path} childPath\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    treePath: Path,\n    childPath: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    assert(\n      existingEventSnap || existingServerSnap,\n      'Either existingEventSnap or existingServerSnap must exist'\n    );\n    const path = treePath.child(childPath);\n    if (this.visibleWrites_.hasCompleteWrite(path)) {\n      // At this point we can probably guarantee that we're in case 2, meaning no events\n      // May need to check visibility while doing the findRootMostValueAndPath call\n      return null;\n    } else {\n      // No complete shadowing. We're either partially shadowing or not shadowing at all.\n      const childMerge = this.visibleWrites_.childCompoundWrite(path);\n      if (childMerge.isEmpty()) {\n        // We're not shadowing at all. Case 1\n        return existingServerSnap.getChild(childPath);\n      } else {\n        // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n        // However this is tricky to find out, since user updates don't necessary change the server\n        // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n        // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n        // only check if the updates change the serverNode.\n        // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n        return childMerge.apply(existingServerSnap.getChild(childPath));\n      }\n    }\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!Path} treePath\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerSnap\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    treePath: Path,\n    childKey: string,\n    existingServerSnap: CacheNode\n  ): Node | null {\n    const path = treePath.child(childKey);\n    const shadowingNode = this.visibleWrites_.getCompleteNode(path);\n    if (shadowingNode != null) {\n      return shadowingNode;\n    } else {\n      if (existingServerSnap.isCompleteForChild(childKey)) {\n        const childMerge = this.visibleWrites_.childCompoundWrite(path);\n        return childMerge.apply(\n          existingServerSnap.getNode().getImmediateChild(childKey)\n        );\n      } else {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window.\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  calcIndexedSlice(\n    treePath: Path,\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    let toIterate: Node;\n    const merge = this.visibleWrites_.childCompoundWrite(treePath);\n    const shadowingNode = merge.getCompleteNode(Path.Empty);\n    if (shadowingNode != null) {\n      toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n      toIterate = merge.apply(completeServerData);\n    } else {\n      // no children to iterate on\n      return [];\n    }\n    toIterate = toIterate.withIndex(index);\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n      const nodes = [];\n      const cmp = index.getCompare();\n      const iter = reverse\n        ? (toIterate as ChildrenNode).getReverseIteratorFrom(startPost, index)\n        : (toIterate as ChildrenNode).getIteratorFrom(startPost, index);\n      let next = iter.getNext();\n      while (next && nodes.length < count) {\n        if (cmp(next, startPost) !== 0) {\n          nodes.push(next);\n        }\n        next = iter.getNext();\n      }\n      return nodes;\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * @param {!WriteRecord} writeRecord\n   * @param {!Path} path\n   * @return {boolean}\n   * @private\n   */\n  private recordContainsPath_(writeRecord: WriteRecord, path: Path): boolean {\n    if (writeRecord.snap) {\n      return writeRecord.path.contains(path);\n    } else {\n      // findKey can return undefined, so use !! to coerce to boolean\n      return !!findKey(writeRecord.children, function(\n        childSnap: Node,\n        childName: string\n      ) {\n        return writeRecord.path.child(childName).contains(path);\n      });\n    }\n  }\n\n  /**\n   * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\n   * @private\n   */\n  private resetTree_() {\n    this.visibleWrites_ = WriteTree.layerTree_(\n      this.allWrites_,\n      WriteTree.DefaultFilter_,\n      Path.Empty\n    );\n    if (this.allWrites_.length > 0) {\n      this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;\n    } else {\n      this.lastWriteId_ = -1;\n    }\n  }\n\n  /**\n   * The default filter used when constructing the tree. Keep everything that's visible.\n   *\n   * @param {!WriteRecord} write\n   * @return {boolean}\n   * @private\n   */\n  private static DefaultFilter_(write: WriteRecord) {\n    return write.visible;\n  }\n\n  /**\n   * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\n   * event data at that path.\n   *\n   * @param {!Array.<!WriteRecord>} writes\n   * @param {!function(!WriteRecord):boolean} filter\n   * @param {!Path} treeRoot\n   * @return {!CompoundWrite}\n   * @private\n   */\n  private static layerTree_(\n    writes: WriteRecord[],\n    filter: (w: WriteRecord) => boolean,\n    treeRoot: Path\n  ): CompoundWrite {\n    let compoundWrite = CompoundWrite.Empty;\n    for (let i = 0; i < writes.length; ++i) {\n      const write = writes[i];\n      // Theory, a later set will either:\n      // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n      // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n      if (filter(write)) {\n        const writePath = write.path;\n        let relativePath;\n        if (write.snap) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrite(relativePath, write.snap);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            compoundWrite = compoundWrite.addWrite(\n              Path.Empty,\n              write.snap.getChild(relativePath)\n            );\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else if (write.children) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrites(\n              relativePath,\n              write.children\n            );\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            if (relativePath.isEmpty()) {\n              compoundWrite = compoundWrite.addWrites(\n                Path.Empty,\n                write.children\n              );\n            } else {\n              const child = safeGet(write.children, relativePath.getFront());\n              if (child) {\n                // There exists a child in this node that matches the root path\n                const deepNode = child.getChild(relativePath.popFront());\n                compoundWrite = compoundWrite.addWrite(Path.Empty, deepNode);\n              }\n            }\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else {\n          throw assertionError('WriteRecord should have .snap or .children');\n        }\n      }\n    }\n    return compoundWrite;\n  }\n}\n\n/**\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\n * just proxy to the underlying WriteTree.\n *\n * @constructor\n */\nexport class WriteTreeRef {\n  /**\n   * The path to this particular write tree ref. Used for calling methods on writeTree_ while exposing a simpler\n   * interface to callers.\n   *\n   * @type {!Path}\n   * @private\n   * @const\n   */\n  private readonly treePath_: Path;\n\n  /**\n   * * A reference to the actual tree of write data. All methods are pass-through to the tree, but with the appropriate\n   * path prefixed.\n   *\n   * This lets us make cheap references to points in the tree for sync points without having to copy and maintain all of\n   * the data.\n   *\n   * @type {!WriteTree}\n   * @private\n   * @const\n   */\n  private readonly writeTree_: WriteTree;\n\n  /**\n   * @param {!Path} path\n   * @param {!WriteTree} writeTree\n   */\n  constructor(path: Path, writeTree: WriteTree) {\n    this.treePath_ = path;\n    this.writeTree_ = writeTree;\n  }\n\n  /**\n   * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\n   * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\n   * can lead to a more expensive calculation.\n   *\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    return this.writeTree_.calcCompleteEventCache(\n      this.treePath_,\n      completeServerCache,\n      writeIdsToExclude,\n      includeHiddenWrites\n    );\n  }\n\n  /**\n   * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\n   * mix of the given server data and write data.\n   *\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(\n    completeServerChildren: ChildrenNode | null\n  ): ChildrenNode {\n    return this.writeTree_.calcCompleteEventChildren(\n      this.treePath_,\n      completeServerChildren\n    ) as ChildrenNode;\n  }\n\n  /**\n   * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\n   * if anything, needs to be applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events should be raised\n   *\n   * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\n   *\n   * @param {!Path} path\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    path: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    return this.writeTree_.calcEventCacheAfterServerOverwrite(\n      this.treePath_,\n      path,\n      existingEventSnap,\n      existingServerSnap\n    );\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.writeTree_.shadowingWrite(this.treePath_.child(path));\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window\n   *\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  calcIndexedSlice(\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    return this.writeTree_.calcIndexedSlice(\n      this.treePath_,\n      completeServerData,\n      startPost,\n      count,\n      reverse,\n      index\n    );\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerCache\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    childKey: string,\n    existingServerCache: CacheNode\n  ): Node | null {\n    return this.writeTree_.calcCompleteChild(\n      this.treePath_,\n      childKey,\n      existingServerCache\n    );\n  }\n\n  /**\n   * Return a WriteTreeRef for a child.\n   *\n   * @param {string} childName\n   * @return {!WriteTreeRef}\n   */\n  child(childName: string): WriteTreeRef {\n    return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}