{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar IndexedFilter_1 = require(\"./IndexedFilter\");\nvar PriorityIndex_1 = require(\"../../snap/indexes/PriorityIndex\");\nvar Node_1 = require(\"../../../core/snap/Node\");\nvar ChildrenNode_1 = require(\"../../snap/ChildrenNode\");\n/**\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\n *\n * @constructor\n * @implements {NodeFilter}\n */\nvar RangedFilter = /** @class */function () {\n  /**\n   * @param {!QueryParams} params\n   */\n  function RangedFilter(params) {\n    this.indexedFilter_ = new IndexedFilter_1.IndexedFilter(params.getIndex());\n    this.index_ = params.getIndex();\n    this.startPost_ = RangedFilter.getStartPost_(params);\n    this.endPost_ = RangedFilter.getEndPost_(params);\n  }\n  /**\n   * @return {!NamedNode}\n   */\n  RangedFilter.prototype.getStartPost = function () {\n    return this.startPost_;\n  };\n  /**\n   * @return {!NamedNode}\n   */\n  RangedFilter.prototype.getEndPost = function () {\n    return this.endPost_;\n  };\n  /**\n   * @param {!NamedNode} node\n   * @return {boolean}\n   */\n  RangedFilter.prototype.matches = function (node) {\n    return this.index_.compare(this.getStartPost(), node) <= 0 && this.index_.compare(node, this.getEndPost()) <= 0;\n  };\n  /**\n   * @inheritDoc\n   */\n  RangedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n    if (!this.matches(new Node_1.NamedNode(key, newChild))) {\n      newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    }\n    return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n  };\n  /**\n   * @inheritDoc\n   */\n  RangedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n    if (newSnap.isLeafNode()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      newSnap = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    }\n    var filtered = newSnap.withIndex(this.index_);\n    // Don't support priorities on queries\n    filtered = filtered.updatePriority(ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n    var self = this;\n    newSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n      if (!self.matches(new Node_1.NamedNode(key, childNode))) {\n        filtered = filtered.updateImmediateChild(key, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n      }\n    });\n    return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);\n  };\n  /**\n   * @inheritDoc\n   */\n  RangedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n    // Don't support priorities on queries\n    return oldSnap;\n  };\n  /**\n   * @inheritDoc\n   */\n  RangedFilter.prototype.filtersNodes = function () {\n    return true;\n  };\n  /**\n   * @inheritDoc\n   */\n  RangedFilter.prototype.getIndexedFilter = function () {\n    return this.indexedFilter_;\n  };\n  /**\n   * @inheritDoc\n   */\n  RangedFilter.prototype.getIndex = function () {\n    return this.index_;\n  };\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n  RangedFilter.getStartPost_ = function (params) {\n    if (params.hasStart()) {\n      var startName = params.getIndexStartName();\n      return params.getIndex().makePost(params.getIndexStartValue(), startName);\n    } else {\n      return params.getIndex().minPost();\n    }\n  };\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n  RangedFilter.getEndPost_ = function (params) {\n    if (params.hasEnd()) {\n      var endName = params.getIndexEndName();\n      return params.getIndex().makePost(params.getIndexEndValue(), endName);\n    } else {\n      return params.getIndex().maxPost();\n    }\n  };\n  return RangedFilter;\n}();\nexports.RangedFilter = RangedFilter;","map":{"version":3,"mappings":"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","names":["params","indexedFilter_","IndexedFilter_1","getIndex","index_","startPost_","RangedFilter","getStartPost_","endPost_","getEndPost_","node","compare","getStartPost","getEndPost","snap","key","newChild","affectedPath","source","optChangeAccumulator","matches","Node_1","ChildrenNode_1","EMPTY_NODE","updateChild","oldSnap","newSnap","isLeafNode","filtered","withIndex","updatePriority","self","forEachChild","PriorityIndex_1","childNode","updateImmediateChild","updateFullNode","newPriority","hasStart","startName","getIndexStartName","makePost","getIndexStartValue","minPost","hasEnd","endName","getIndexEndName","getIndexEndValue","maxPost","exports"],"sources":["../src/core/view/filter/RangedFilter.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexedFilter } from './IndexedFilter';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\nimport { NamedNode, Node } from '../../../core/snap/Node';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { NodeFilter } from './NodeFilter';\nimport { QueryParams } from '../QueryParams';\nimport { Index } from '../../snap/indexes/Index';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\n\n/**\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\n *\n * @constructor\n * @implements {NodeFilter}\n */\nexport class RangedFilter implements NodeFilter {\n  /**\n   * @type {!IndexedFilter}\n   * @const\n   * @private\n   */\n  private indexedFilter_: IndexedFilter;\n\n  /**\n   * @const\n   * @type {!Index}\n   * @private\n   */\n  private index_: Index;\n\n  /**\n   * @const\n   * @type {!NamedNode}\n   * @private\n   */\n  private startPost_: NamedNode;\n\n  /**\n   * @const\n   * @type {!NamedNode}\n   * @private\n   */\n  private endPost_: NamedNode;\n\n  /**\n   * @param {!QueryParams} params\n   */\n  constructor(params: QueryParams) {\n    this.indexedFilter_ = new IndexedFilter(params.getIndex());\n    this.index_ = params.getIndex();\n    this.startPost_ = RangedFilter.getStartPost_(params);\n    this.endPost_ = RangedFilter.getEndPost_(params);\n  }\n\n  /**\n   * @return {!NamedNode}\n   */\n  getStartPost(): NamedNode {\n    return this.startPost_;\n  }\n\n  /**\n   * @return {!NamedNode}\n   */\n  getEndPost(): NamedNode {\n    return this.endPost_;\n  }\n\n  /**\n   * @param {!NamedNode} node\n   * @return {boolean}\n   */\n  matches(node: NamedNode): boolean {\n    return (\n      this.index_.compare(this.getStartPost(), node) <= 0 &&\n      this.index_.compare(node, this.getEndPost()) <= 0\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (!this.matches(new NamedNode(key, newChild))) {\n      newChild = ChildrenNode.EMPTY_NODE;\n    }\n    return this.indexedFilter_.updateChild(\n      snap,\n      key,\n      newChild,\n      affectedPath,\n      source,\n      optChangeAccumulator\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (newSnap.isLeafNode()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      newSnap = ChildrenNode.EMPTY_NODE;\n    }\n    let filtered = newSnap.withIndex(this.index_);\n    // Don't support priorities on queries\n    filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n    const self = this;\n    newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n      if (!self.matches(new NamedNode(key, childNode))) {\n        filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);\n      }\n    });\n    return this.indexedFilter_.updateFullNode(\n      oldSnap,\n      filtered,\n      optChangeAccumulator\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    // Don't support priorities on queries\n    return oldSnap;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this.indexedFilter_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n  private static getStartPost_(params: QueryParams): NamedNode {\n    if (params.hasStart()) {\n      const startName = params.getIndexStartName();\n      return params.getIndex().makePost(params.getIndexStartValue(), startName);\n    } else {\n      return params.getIndex().minPost();\n    }\n  }\n\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n  private static getEndPost_(params: QueryParams): NamedNode {\n    if (params.hasEnd()) {\n      const endName = params.getIndexEndName();\n      return params.getIndex().makePost(params.getIndexEndValue(), endName);\n    } else {\n      return params.getIndex().maxPost();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}