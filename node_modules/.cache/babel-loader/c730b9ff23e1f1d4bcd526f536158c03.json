{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BrowserPollConnection_1 = require(\"./BrowserPollConnection\");\nvar WebSocketConnection_1 = require(\"./WebSocketConnection\");\nvar util_1 = require(\"../core/util/util\");\n/**\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\n * lifecycle.\n *\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\n * they are available.\n * @constructor\n */\nvar TransportManager = /** @class */function () {\n  /**\n   * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to\n   */\n  function TransportManager(repoInfo) {\n    this.initTransports_(repoInfo);\n  }\n  Object.defineProperty(TransportManager, \"ALL_TRANSPORTS\", {\n    /**\n     * @const\n     * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}\n     */\n    get: function () {\n      return [BrowserPollConnection_1.BrowserPollConnection, WebSocketConnection_1.WebSocketConnection];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @param {!RepoInfo} repoInfo\n   * @private\n   */\n  TransportManager.prototype.initTransports_ = function (repoInfo) {\n    var isWebSocketsAvailable = WebSocketConnection_1.WebSocketConnection && WebSocketConnection_1.WebSocketConnection['isAvailable']();\n    var isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection_1.WebSocketConnection.previouslyFailed();\n    if (repoInfo.webSocketOnly) {\n      if (!isWebSocketsAvailable) util_1.warn(\"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\");\n      isSkipPollConnection = true;\n    }\n    if (isSkipPollConnection) {\n      this.transports_ = [WebSocketConnection_1.WebSocketConnection];\n    } else {\n      var transports_1 = this.transports_ = [];\n      util_1.each(TransportManager.ALL_TRANSPORTS, function (i, transport) {\n        if (transport && transport['isAvailable']()) {\n          transports_1.push(transport);\n        }\n      });\n    }\n  };\n  /**\n   * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the\n   * initial transport to use\n   */\n  TransportManager.prototype.initialTransport = function () {\n    if (this.transports_.length > 0) {\n      return this.transports_[0];\n    } else {\n      throw new Error('No transports available');\n    }\n  };\n  /**\n   * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next\n   * transport, or null\n   */\n  TransportManager.prototype.upgradeTransport = function () {\n    if (this.transports_.length > 1) {\n      return this.transports_[1];\n    } else {\n      return null;\n    }\n  };\n  return TransportManager;\n}();\nexports.TransportManager = TransportManager;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AAIA;;;;;;;;AAQA;EAWE;;;EAGA,0BAAYA,QAAkB;IAC5B,IAAI,CAACC,eAAe,CAACD,QAAQ,CAAC;EAChC;EATAE,sBAAWC,kCAAc;IAJzB;;;;SAIA;MACE,OAAO,CAACC,6CAAqB,EAAEC,yCAAmB,CAAC;IACrD,CAAC;;;;EASD;;;;EAIQF,0CAAe,GAAvB,UAAwBH,QAAkB;IACxC,IAAMM,qBAAqB,GACzBD,yCAAmB,IAAIA,yCAAmB,CAAC,aAAa,CAAC,EAAE;IAC7D,IAAIE,oBAAoB,GACtBD,qBAAqB,IAAI,CAACD,yCAAmB,CAACG,gBAAgB,EAAE;IAElE,IAAIR,QAAQ,CAACS,aAAa,EAAE;MAC1B,IAAI,CAACH,qBAAqB,EACxBI,WAAI,CACF,iFAAiF,CAClF;MAEHH,oBAAoB,GAAG,IAAI;IAC7B;IAEA,IAAIA,oBAAoB,EAAE;MACxB,IAAI,CAACI,WAAW,GAAG,CAACN,yCAAmB,CAAC;IAC1C,CAAC,MAAM;MACL,IAAMO,YAAU,GAAI,IAAI,CAACD,WAAW,GAAG,EAA6B;MACpED,WAAI,CACFP,gBAAgB,CAACU,cAAc,EAC/B,UAACC,CAAS,EAAEC,SAA+B;QACzC,IAAIA,SAAS,IAAIA,SAAS,CAAC,aAAa,CAAC,EAAE,EAAE;UAC3CH,YAAU,CAACI,IAAI,CAACD,SAAS,CAAC;QAC5B;MACF,CAAC,CACF;IACH;EACF,CAAC;EAED;;;;EAIAZ,2CAAgB,GAAhB;IACE,IAAI,IAAI,CAACQ,WAAW,CAACM,MAAM,GAAG,CAAC,EAAE;MAC/B,OAAO,IAAI,CAACN,WAAW,CAAC,CAAC,CAAC;IAC5B,CAAC,MAAM;MACL,MAAM,IAAIO,KAAK,CAAC,yBAAyB,CAAC;IAC5C;EACF,CAAC;EAED;;;;EAIAf,2CAAgB,GAAhB;IACE,IAAI,IAAI,CAACQ,WAAW,CAACM,MAAM,GAAG,CAAC,EAAE;MAC/B,OAAO,IAAI,CAACN,WAAW,CAAC,CAAC,CAAC;IAC5B,CAAC,MAAM;MACL,OAAO,IAAI;IACb;EACF,CAAC;EACH,uBAAC;AAAD,CA3EA,EA2EC;AA3EYQ","names":["repoInfo","initTransports_","Object","TransportManager","BrowserPollConnection_1","WebSocketConnection_1","isWebSocketsAvailable","isSkipPollConnection","previouslyFailed","webSocketOnly","util_1","transports_","transports_1","ALL_TRANSPORTS","i","transport","push","length","Error","exports"],"sources":["../src/realtime/TransportManager.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BrowserPollConnection } from './BrowserPollConnection';\nimport { WebSocketConnection } from './WebSocketConnection';\nimport { warn, each } from '../core/util/util';\nimport { TransportConstructor } from './Transport';\nimport { RepoInfo } from '../core/RepoInfo';\n\n/**\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\n * lifecycle.\n *\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\n * they are available.\n * @constructor\n */\nexport class TransportManager {\n  private transports_: TransportConstructor[];\n\n  /**\n   * @const\n   * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}\n   */\n  static get ALL_TRANSPORTS() {\n    return [BrowserPollConnection, WebSocketConnection];\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to\n   */\n  constructor(repoInfo: RepoInfo) {\n    this.initTransports_(repoInfo);\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo\n   * @private\n   */\n  private initTransports_(repoInfo: RepoInfo) {\n    const isWebSocketsAvailable: boolean =\n      WebSocketConnection && WebSocketConnection['isAvailable']();\n    let isSkipPollConnection =\n      isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();\n\n    if (repoInfo.webSocketOnly) {\n      if (!isWebSocketsAvailable)\n        warn(\n          \"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\"\n        );\n\n      isSkipPollConnection = true;\n    }\n\n    if (isSkipPollConnection) {\n      this.transports_ = [WebSocketConnection];\n    } else {\n      const transports = (this.transports_ = [] as TransportConstructor[]);\n      each(\n        TransportManager.ALL_TRANSPORTS,\n        (i: number, transport: TransportConstructor) => {\n          if (transport && transport['isAvailable']()) {\n            transports.push(transport);\n          }\n        }\n      );\n    }\n  }\n\n  /**\n   * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the\n   * initial transport to use\n   */\n  initialTransport(): TransportConstructor {\n    if (this.transports_.length > 0) {\n      return this.transports_[0];\n    } else {\n      throw new Error('No transports available');\n    }\n  }\n\n  /**\n   * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next\n   * transport, or null\n   */\n  upgradeTransport(): TransportConstructor | null {\n    if (this.transports_.length > 1) {\n      return this.transports_[1];\n    } else {\n      return null;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}