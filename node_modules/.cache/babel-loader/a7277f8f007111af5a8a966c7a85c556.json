{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ServerValues_1 = require(\"./util/ServerValues\");\nvar nodeFromJSON_1 = require(\"./snap/nodeFromJSON\");\nvar Path_1 = require(\"./util/Path\");\nvar SparseSnapshotTree_1 = require(\"./SparseSnapshotTree\");\nvar SyncTree_1 = require(\"./SyncTree\");\nvar SnapshotHolder_1 = require(\"./SnapshotHolder\");\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"./util/util\");\nvar util_3 = require(\"@firebase/util\");\nvar AuthTokenProvider_1 = require(\"./AuthTokenProvider\");\nvar StatsManager_1 = require(\"./stats/StatsManager\");\nvar StatsReporter_1 = require(\"./stats/StatsReporter\");\nvar StatsListener_1 = require(\"./stats/StatsListener\");\nvar EventQueue_1 = require(\"./view/EventQueue\");\nvar PersistentConnection_1 = require(\"./PersistentConnection\");\nvar ReadonlyRestClient_1 = require(\"./ReadonlyRestClient\");\nvar Database_1 = require(\"../api/Database\");\nvar INTERRUPT_REASON = 'repo_interrupt';\n/**\n * A connection to a single data repository.\n */\nvar Repo = /** @class */function () {\n  /**\n   * @param {!RepoInfo} repoInfo_\n   * @param {boolean} forceRestClient\n   * @param {!FirebaseApp} app\n   */\n  function Repo(repoInfo_, forceRestClient, app) {\n    var _this = this;\n    this.repoInfo_ = repoInfo_;\n    this.app = app;\n    this.dataUpdateCount = 0;\n    this.statsListener_ = null;\n    this.eventQueue_ = new EventQueue_1.EventQueue();\n    this.nextWriteId_ = 1;\n    this.interceptServerDataCallback_ = null;\n    // A list of data pieces and paths to be set when this client disconnects.\n    this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();\n    /**\n     * TODO: This should be @private but it's used by test_access.js and internal.js\n     * @type {?PersistentConnection}\n     */\n    this.persistentConnection_ = null;\n    /** @type {!AuthTokenProvider} */\n    var authTokenProvider = new AuthTokenProvider_1.AuthTokenProvider(app);\n    this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo_);\n    if (forceRestClient || util_2.beingCrawled()) {\n      this.server_ = new ReadonlyRestClient_1.ReadonlyRestClient(this.repoInfo_, this.onDataUpdate_.bind(this), authTokenProvider);\n      // Minor hack: Fire onConnect immediately, since there's no actual connection.\n      setTimeout(this.onConnectStatus_.bind(this, true), 0);\n    } else {\n      var authOverride = app.options['databaseAuthVariableOverride'];\n      // Validate authOverride\n      if (typeof authOverride !== 'undefined' && authOverride !== null) {\n        if (typeof authOverride !== 'object') {\n          throw new Error('Only objects are supported for option databaseAuthVariableOverride');\n        }\n        try {\n          util_1.stringify(authOverride);\n        } catch (e) {\n          throw new Error('Invalid authOverride provided: ' + e);\n        }\n      }\n      this.persistentConnection_ = new PersistentConnection_1.PersistentConnection(this.repoInfo_, this.onDataUpdate_.bind(this), this.onConnectStatus_.bind(this), this.onServerInfoUpdate_.bind(this), authTokenProvider, authOverride);\n      this.server_ = this.persistentConnection_;\n    }\n    authTokenProvider.addTokenChangeListener(function (token) {\n      _this.server_.refreshAuthToken(token);\n    });\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n    this.statsReporter_ = StatsManager_1.StatsManager.getOrCreateReporter(repoInfo_, function () {\n      return new StatsReporter_1.StatsReporter(_this.stats_, _this.server_);\n    });\n    this.transactions_init_();\n    // Used for .info.\n    this.infoData_ = new SnapshotHolder_1.SnapshotHolder();\n    this.infoSyncTree_ = new SyncTree_1.SyncTree({\n      startListening: function startListening(query, tag, currentHashFn, onComplete) {\n        var infoEvents = [];\n        var node = _this.infoData_.getNode(query.path);\n        // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n        // on initial data...\n        if (!node.isEmpty()) {\n          infoEvents = _this.infoSyncTree_.applyServerOverwrite(query.path, node);\n          setTimeout(function () {\n            onComplete('ok');\n          }, 0);\n        }\n        return infoEvents;\n      },\n      stopListening: function stopListening() {}\n    });\n    this.updateInfo_('connected', false);\n    this.serverSyncTree_ = new SyncTree_1.SyncTree({\n      startListening: function startListening(query, tag, currentHashFn, onComplete) {\n        _this.server_.listen(query, currentHashFn, tag, function (status, data) {\n          var events = onComplete(status, data);\n          _this.eventQueue_.raiseEventsForChangedPath(query.path, events);\n        });\n        // No synchronous events for network-backed sync trees\n        return [];\n      },\n      stopListening: function stopListening(query, tag) {\n        _this.server_.unlisten(query, tag);\n      }\n    });\n  }\n  /**\n   * @return {string}  The URL corresponding to the root of this Firebase.\n   */\n  Repo.prototype.toString = function () {\n    return (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host;\n  };\n  /**\n   * @return {!string} The namespace represented by the repo.\n   */\n  Repo.prototype.name = function () {\n    return this.repoInfo_.namespace;\n  };\n  /**\n   * @return {!number} The time in milliseconds, taking the server offset into account if we have one.\n   */\n  Repo.prototype.serverTime = function () {\n    var offsetNode = this.infoData_.getNode(new Path_1.Path('.info/serverTimeOffset'));\n    var offset = offsetNode.val() || 0;\n    return new Date().getTime() + offset;\n  };\n  /**\n   * Generate ServerValues using some variables from the repo object.\n   * @return {!Object}\n   */\n  Repo.prototype.generateServerValues = function () {\n    return ServerValues_1.generateWithValues({\n      timestamp: this.serverTime()\n    });\n  };\n  /**\n   * Called by realtime when we get new messages from the server.\n   *\n   * @private\n   * @param {string} pathString\n   * @param {*} data\n   * @param {boolean} isMerge\n   * @param {?number} tag\n   */\n  Repo.prototype.onDataUpdate_ = function (pathString, data, isMerge, tag) {\n    // For testing.\n    this.dataUpdateCount++;\n    var path = new Path_1.Path(pathString);\n    data = this.interceptServerDataCallback_ ? this.interceptServerDataCallback_(pathString, data) : data;\n    var events = [];\n    if (tag) {\n      if (isMerge) {\n        var taggedChildren = util_3.map(data, function (raw) {\n          return nodeFromJSON_1.nodeFromJSON(raw);\n        });\n        events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);\n      } else {\n        var taggedSnap = nodeFromJSON_1.nodeFromJSON(data);\n        events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);\n      }\n    } else if (isMerge) {\n      var changedChildren = util_3.map(data, function (raw) {\n        return nodeFromJSON_1.nodeFromJSON(raw);\n      });\n      events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\n    } else {\n      var snap = nodeFromJSON_1.nodeFromJSON(data);\n      events = this.serverSyncTree_.applyServerOverwrite(path, snap);\n    }\n    var affectedPath = path;\n    if (events.length > 0) {\n      // Since we have a listener outstanding for each transaction, receiving any events\n      // is a proxy for some change having occurred.\n      affectedPath = this.rerunTransactions_(path);\n    }\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\n  };\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @param {?function(!string, *):*} callback\n   * @private\n   */\n  Repo.prototype.interceptServerData_ = function (callback) {\n    this.interceptServerDataCallback_ = callback;\n  };\n  /**\n   * @param {!boolean} connectStatus\n   * @private\n   */\n  Repo.prototype.onConnectStatus_ = function (connectStatus) {\n    this.updateInfo_('connected', connectStatus);\n    if (connectStatus === false) {\n      this.runOnDisconnectEvents_();\n    }\n  };\n  /**\n   * @param {!Object} updates\n   * @private\n   */\n  Repo.prototype.onServerInfoUpdate_ = function (updates) {\n    var _this = this;\n    util_2.each(updates, function (value, key) {\n      _this.updateInfo_(key, value);\n    });\n  };\n  /**\n   *\n   * @param {!string} pathString\n   * @param {*} value\n   * @private\n   */\n  Repo.prototype.updateInfo_ = function (pathString, value) {\n    var path = new Path_1.Path('/.info/' + pathString);\n    var newNode = nodeFromJSON_1.nodeFromJSON(value);\n    this.infoData_.updateSnapshot(path, newNode);\n    var events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n  };\n  /**\n   * @return {!number}\n   * @private\n   */\n  Repo.prototype.getNextWriteId_ = function () {\n    return this.nextWriteId_++;\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} newVal\n   * @param {number|string|null} newPriority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  Repo.prototype.setWithPriority = function (path, newVal, newPriority, onComplete) {\n    var _this = this;\n    this.log_('set', {\n      path: path.toString(),\n      value: newVal,\n      priority: newPriority\n    });\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n    var serverValues = this.generateServerValues();\n    var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, newPriority);\n    var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n    var writeId = this.getNextWriteId_();\n    var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);\n    this.eventQueue_.queueEvents(events);\n    this.server_.put(path.toString(), newNodeUnresolved.val( /*export=*/true), function (status, errorReason) {\n      var success = status === 'ok';\n      if (!success) {\n        util_2.warn('set at ' + path + ' failed: ' + status);\n      }\n      var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId, !success);\n      _this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n    var affectedPath = this.abortTransactions_(path);\n    this.rerunTransactions_(affectedPath);\n    // We queued the events above, so just flush the queue here\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\n  };\n  /**\n   * @param {!Path} path\n   * @param {!Object} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  Repo.prototype.update = function (path, childrenToMerge, onComplete) {\n    var _this = this;\n    this.log_('update', {\n      path: path.toString(),\n      value: childrenToMerge\n    });\n    // Start with our existing data and merge each child into it.\n    var empty = true;\n    var serverValues = this.generateServerValues();\n    var changedChildren = {};\n    util_3.forEach(childrenToMerge, function (changedKey, changedValue) {\n      empty = false;\n      var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(changedValue);\n      changedChildren[changedKey] = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n    });\n    if (!empty) {\n      var writeId_1 = this.getNextWriteId_();\n      var events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId_1);\n      this.eventQueue_.queueEvents(events);\n      this.server_.merge(path.toString(), childrenToMerge, function (status, errorReason) {\n        var success = status === 'ok';\n        if (!success) {\n          util_2.warn('update at ' + path + ' failed: ' + status);\n        }\n        var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId_1, !success);\n        var affectedPath = clearEvents.length > 0 ? _this.rerunTransactions_(path) : path;\n        _this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\n        _this.callOnCompleteCallback(onComplete, status, errorReason);\n      });\n      util_3.forEach(childrenToMerge, function (changedPath) {\n        var affectedPath = _this.abortTransactions_(path.child(changedPath));\n        _this.rerunTransactions_(affectedPath);\n      });\n      // We queued the events above, so just flush the queue here\n      this.eventQueue_.raiseEventsForChangedPath(path, []);\n    } else {\n      util_2.log(\"update() called with empty data.  Don't do anything.\");\n      this.callOnCompleteCallback(onComplete, 'ok');\n    }\n  };\n  /**\n   * Applies all of the changes stored up in the onDisconnect_ tree.\n   * @private\n   */\n  Repo.prototype.runOnDisconnectEvents_ = function () {\n    var _this = this;\n    this.log_('onDisconnectEvents');\n    var serverValues = this.generateServerValues();\n    var resolvedOnDisconnectTree = ServerValues_1.resolveDeferredValueTree(this.onDisconnect_, serverValues);\n    var events = [];\n    resolvedOnDisconnectTree.forEachTree(Path_1.Path.Empty, function (path, snap) {\n      events = events.concat(_this.serverSyncTree_.applyServerOverwrite(path, snap));\n      var affectedPath = _this.abortTransactions_(path);\n      _this.rerunTransactions_(affectedPath);\n    });\n    this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();\n    this.eventQueue_.raiseEventsForChangedPath(Path_1.Path.Empty, events);\n  };\n  /**\n   * @param {!Path} path\n   * @param {?function(?Error, *=)} onComplete\n   */\n  Repo.prototype.onDisconnectCancel = function (path, onComplete) {\n    var _this = this;\n    this.server_.onDisconnectCancel(path.toString(), function (status, errorReason) {\n      if (status === 'ok') {\n        _this.onDisconnect_.forget(path);\n      }\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {?function(?Error, *=)} onComplete\n   */\n  Repo.prototype.onDisconnectSet = function (path, value, onComplete) {\n    var _this = this;\n    var newNode = nodeFromJSON_1.nodeFromJSON(value);\n    this.server_.onDisconnectPut(path.toString(), newNode.val( /*export=*/true), function (status, errorReason) {\n      if (status === 'ok') {\n        _this.onDisconnect_.remember(path, newNode);\n      }\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {*} priority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  Repo.prototype.onDisconnectSetWithPriority = function (path, value, priority, onComplete) {\n    var _this = this;\n    var newNode = nodeFromJSON_1.nodeFromJSON(value, priority);\n    this.server_.onDisconnectPut(path.toString(), newNode.val( /*export=*/true), function (status, errorReason) {\n      if (status === 'ok') {\n        _this.onDisconnect_.remember(path, newNode);\n      }\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  Repo.prototype.onDisconnectUpdate = function (path, childrenToMerge, onComplete) {\n    var _this = this;\n    if (util_3.isEmpty(childrenToMerge)) {\n      util_2.log(\"onDisconnect().update() called with empty data.  Don't do anything.\");\n      this.callOnCompleteCallback(onComplete, 'ok');\n      return;\n    }\n    this.server_.onDisconnectMerge(path.toString(), childrenToMerge, function (status, errorReason) {\n      if (status === 'ok') {\n        util_3.forEach(childrenToMerge, function (childName, childNode) {\n          var newChildNode = nodeFromJSON_1.nodeFromJSON(childNode);\n          _this.onDisconnect_.remember(path.child(childName), newChildNode);\n        });\n      }\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   */\n  Repo.prototype.addEventCallbackForQuery = function (query, eventRegistration) {\n    var events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.addEventRegistration(query, eventRegistration);\n    } else {\n      events = this.serverSyncTree_.addEventRegistration(query, eventRegistration);\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  };\n  /**\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration\n   */\n  Repo.prototype.removeEventCallbackForQuery = function (query, eventRegistration) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    var events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.removeEventRegistration(query, eventRegistration);\n    } else {\n      events = this.serverSyncTree_.removeEventRegistration(query, eventRegistration);\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  };\n  Repo.prototype.interrupt = function () {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n  };\n  Repo.prototype.resume = function () {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n  };\n  Repo.prototype.stats = function (showDelta) {\n    if (showDelta === void 0) {\n      showDelta = false;\n    }\n    if (typeof console === 'undefined') return;\n    var stats;\n    if (showDelta) {\n      if (!this.statsListener_) this.statsListener_ = new StatsListener_1.StatsListener(this.stats_);\n      stats = this.statsListener_.get();\n    } else {\n      stats = this.stats_.get();\n    }\n    var longestName = Object.keys(stats).reduce(function (previousValue, currentValue) {\n      return Math.max(currentValue.length, previousValue);\n    }, 0);\n    util_3.forEach(stats, function (stat, value) {\n      // pad stat names to be the same length (plus 2 extra spaces).\n      for (var i = stat.length; i < longestName + 2; i++) {\n        stat += ' ';\n      }\n      console.log(stat + value);\n    });\n  };\n  Repo.prototype.statsIncrementCounter = function (metric) {\n    this.stats_.incrementCounter(metric);\n    this.statsReporter_.includeStat(metric);\n  };\n  /**\n   * @param {...*} var_args\n   * @private\n   */\n  Repo.prototype.log_ = function () {\n    var var_args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      var_args[_i] = arguments[_i];\n    }\n    var prefix = '';\n    if (this.persistentConnection_) {\n      prefix = this.persistentConnection_.id + ':';\n    }\n    util_2.log.apply(void 0, [prefix].concat(var_args));\n  };\n  /**\n   * @param {?function(?Error, *=)} callback\n   * @param {!string} status\n   * @param {?string=} errorReason\n   */\n  Repo.prototype.callOnCompleteCallback = function (callback, status, errorReason) {\n    if (callback) {\n      util_2.exceptionGuard(function () {\n        if (status == 'ok') {\n          callback(null);\n        } else {\n          var code = (status || 'error').toUpperCase();\n          var message = code;\n          if (errorReason) message += ': ' + errorReason;\n          var error = new Error(message);\n          error.code = code;\n          callback(error);\n        }\n      });\n    }\n  };\n  Object.defineProperty(Repo.prototype, \"database\", {\n    get: function get() {\n      return this.__database || (this.__database = new Database_1.Database(this));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Repo;\n}();\nexports.Repo = Repo;","map":{"version":3,"mappings":"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","names":["INTERRUPT_REASON","repoInfo_","forceRestClient","app","EventQueue_1","SparseSnapshotTree_1","authTokenProvider","AuthTokenProvider_1","stats_","StatsManager_1","getCollection","util_2","server_","ReadonlyRestClient_1","onDataUpdate_","bind","setTimeout","onConnectStatus_","authOverride","options","Error","util_1","e","persistentConnection_","PersistentConnection_1","onServerInfoUpdate_","addTokenChangeListener","_this","refreshAuthToken","token","statsReporter_","getOrCreateReporter","StatsReporter_1","transactions_init_","infoData_","SnapshotHolder_1","infoSyncTree_","SyncTree_1","startListening","query","tag","currentHashFn","onComplete","infoEvents","node","getNode","path","isEmpty","applyServerOverwrite","stopListening","updateInfo_","serverSyncTree_","listen","status","data","events","eventQueue_","raiseEventsForChangedPath","unlisten","Repo","secure","host","namespace","offsetNode","Path_1","offset","val","Date","getTime","ServerValues_1","timestamp","serverTime","pathString","isMerge","dataUpdateCount","interceptServerDataCallback_","taggedChildren","util_3","raw","applyTaggedQueryMerge","taggedSnap","nodeFromJSON_1","applyTaggedQueryOverwrite","changedChildren","applyServerMerge","snap","affectedPath","length","rerunTransactions_","callback","connectStatus","runOnDisconnectEvents_","updates","value","key","newNode","updateSnapshot","nextWriteId_","newVal","newPriority","log_","toString","priority","serverValues","generateServerValues","newNodeUnresolved","writeId","getNextWriteId_","applyUserOverwrite","queueEvents","put","errorReason","success","clearEvents","ackUserWrite","callOnCompleteCallback","abortTransactions_","childrenToMerge","empty","changedKey","changedValue","writeId_1","applyUserMerge","merge","changedPath","child","resolvedOnDisconnectTree","onDisconnect_","forEachTree","Empty","concat","onDisconnectCancel","forget","onDisconnectPut","remember","onDisconnectMerge","childName","childNode","newChildNode","eventRegistration","getFront","addEventRegistration","raiseEventsAtPath","removeEventRegistration","interrupt","resume","showDelta","console","stats","statsListener_","StatsListener_1","get","longestName","Object","keys","reduce","previousValue","currentValue","max","stat","i","log","metric","incrementCounter","includeStat","_i","var_args","prefix","id","code","toUpperCase","message","error","__database","Database_1","exports"],"sources":["../src/core/Repo.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  generateWithValues,\n  resolveDeferredValueSnapshot,\n  resolveDeferredValueTree\n} from './util/ServerValues';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { Path } from './util/Path';\nimport { SparseSnapshotTree } from './SparseSnapshotTree';\nimport { SyncTree } from './SyncTree';\nimport { SnapshotHolder } from './SnapshotHolder';\nimport { stringify } from '@firebase/util';\nimport { beingCrawled, each, exceptionGuard, warn, log } from './util/util';\nimport { map, forEach, isEmpty } from '@firebase/util';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { StatsManager } from './stats/StatsManager';\nimport { StatsReporter } from './stats/StatsReporter';\nimport { StatsListener } from './stats/StatsListener';\nimport { EventQueue } from './view/EventQueue';\nimport { PersistentConnection } from './PersistentConnection';\nimport { ReadonlyRestClient } from './ReadonlyRestClient';\nimport { FirebaseApp } from '@firebase/app';\nimport { RepoInfo } from './RepoInfo';\nimport { Database } from '../api/Database';\nimport { ServerActions } from './ServerActions';\nimport { Query } from '../api/Query';\nimport { EventRegistration } from './view/EventRegistration';\nimport { StatsCollection } from './stats/StatsCollection';\nimport { Event } from './view/Event';\nimport { Node } from './snap/Node';\n\nconst INTERRUPT_REASON = 'repo_interrupt';\n\n/**\n * A connection to a single data repository.\n */\nexport class Repo {\n  dataUpdateCount = 0;\n  private infoSyncTree_: SyncTree;\n  private serverSyncTree_: SyncTree;\n\n  private stats_: StatsCollection;\n  private statsListener_: StatsListener | null = null;\n  private eventQueue_ = new EventQueue();\n  private nextWriteId_ = 1;\n  private server_: ServerActions;\n  private statsReporter_: StatsReporter;\n  private transactions_init_: () => void;\n  private infoData_: SnapshotHolder;\n  private abortTransactions_: (path: Path) => Path;\n  private rerunTransactions_: (changedPath: Path) => Path;\n  private interceptServerDataCallback_:\n    | ((a: string, b: any) => void)\n    | null = null;\n  private __database: Database;\n\n  // A list of data pieces and paths to be set when this client disconnects.\n  private onDisconnect_ = new SparseSnapshotTree();\n\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @type {?PersistentConnection}\n   */\n  persistentConnection_: PersistentConnection | null = null;\n\n  /**\n   * @param {!RepoInfo} repoInfo_\n   * @param {boolean} forceRestClient\n   * @param {!FirebaseApp} app\n   */\n  constructor(\n    public repoInfo_: RepoInfo,\n    forceRestClient: boolean,\n    public app: FirebaseApp\n  ) {\n    /** @type {!AuthTokenProvider} */\n    const authTokenProvider = new AuthTokenProvider(app);\n\n    this.stats_ = StatsManager.getCollection(repoInfo_);\n\n    if (forceRestClient || beingCrawled()) {\n      this.server_ = new ReadonlyRestClient(\n        this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        authTokenProvider\n      );\n\n      // Minor hack: Fire onConnect immediately, since there's no actual connection.\n      setTimeout(this.onConnectStatus_.bind(this, true), 0);\n    } else {\n      const authOverride = app.options['databaseAuthVariableOverride'];\n      // Validate authOverride\n      if (typeof authOverride !== 'undefined' && authOverride !== null) {\n        if (typeof authOverride !== 'object') {\n          throw new Error(\n            'Only objects are supported for option databaseAuthVariableOverride'\n          );\n        }\n        try {\n          stringify(authOverride);\n        } catch (e) {\n          throw new Error('Invalid authOverride provided: ' + e);\n        }\n      }\n\n      this.persistentConnection_ = new PersistentConnection(\n        this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        this.onConnectStatus_.bind(this),\n        this.onServerInfoUpdate_.bind(this),\n        authTokenProvider,\n        authOverride\n      );\n\n      this.server_ = this.persistentConnection_;\n    }\n\n    authTokenProvider.addTokenChangeListener(token => {\n      this.server_.refreshAuthToken(token);\n    });\n\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n    this.statsReporter_ = StatsManager.getOrCreateReporter(\n      repoInfo_,\n      () => new StatsReporter(this.stats_, this.server_)\n    );\n\n    this.transactions_init_();\n\n    // Used for .info.\n    this.infoData_ = new SnapshotHolder();\n    this.infoSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        let infoEvents: Event[] = [];\n        const node = this.infoData_.getNode(query.path);\n        // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n        // on initial data...\n        if (!node.isEmpty()) {\n          infoEvents = this.infoSyncTree_.applyServerOverwrite(\n            query.path,\n            node\n          );\n          setTimeout(() => {\n            onComplete('ok');\n          }, 0);\n        }\n        return infoEvents;\n      },\n      stopListening: () => {}\n    });\n    this.updateInfo_('connected', false);\n\n    this.serverSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        this.server_.listen(query, currentHashFn, tag, (status, data) => {\n          const events = onComplete(status, data);\n          this.eventQueue_.raiseEventsForChangedPath(query.path, events);\n        });\n        // No synchronous events for network-backed sync trees\n        return [];\n      },\n      stopListening: (query, tag) => {\n        this.server_.unlisten(query, tag);\n      }\n    });\n  }\n\n  /**\n   * @return {string}  The URL corresponding to the root of this Firebase.\n   */\n  toString(): string {\n    return (\n      (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host\n    );\n  }\n\n  /**\n   * @return {!string} The namespace represented by the repo.\n   */\n  name(): string {\n    return this.repoInfo_.namespace;\n  }\n\n  /**\n   * @return {!number} The time in milliseconds, taking the server offset into account if we have one.\n   */\n  serverTime(): number {\n    const offsetNode = this.infoData_.getNode(\n      new Path('.info/serverTimeOffset')\n    );\n    const offset = (offsetNode.val() as number) || 0;\n    return new Date().getTime() + offset;\n  }\n\n  /**\n   * Generate ServerValues using some variables from the repo object.\n   * @return {!Object}\n   */\n  generateServerValues(): Object {\n    return generateWithValues({\n      timestamp: this.serverTime()\n    });\n  }\n\n  /**\n   * Called by realtime when we get new messages from the server.\n   *\n   * @private\n   * @param {string} pathString\n   * @param {*} data\n   * @param {boolean} isMerge\n   * @param {?number} tag\n   */\n  private onDataUpdate_(\n    pathString: string,\n    data: any,\n    isMerge: boolean,\n    tag: number | null\n  ) {\n    // For testing.\n    this.dataUpdateCount++;\n    const path = new Path(pathString);\n    data = this.interceptServerDataCallback_\n      ? this.interceptServerDataCallback_(pathString, data)\n      : data;\n    let events = [];\n    if (tag) {\n      if (isMerge) {\n        const taggedChildren = map(data as { [k: string]: any }, (raw: any) =>\n          nodeFromJSON(raw)\n        );\n        events = this.serverSyncTree_.applyTaggedQueryMerge(\n          path,\n          taggedChildren,\n          tag\n        );\n      } else {\n        const taggedSnap = nodeFromJSON(data);\n        events = this.serverSyncTree_.applyTaggedQueryOverwrite(\n          path,\n          taggedSnap,\n          tag\n        );\n      }\n    } else if (isMerge) {\n      const changedChildren = map(data as { [k: string]: any }, (raw: any) =>\n        nodeFromJSON(raw)\n      );\n      events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\n    } else {\n      const snap = nodeFromJSON(data);\n      events = this.serverSyncTree_.applyServerOverwrite(path, snap);\n    }\n    let affectedPath = path;\n    if (events.length > 0) {\n      // Since we have a listener outstanding for each transaction, receiving any events\n      // is a proxy for some change having occurred.\n      affectedPath = this.rerunTransactions_(path);\n    }\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\n  }\n\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @param {?function(!string, *):*} callback\n   * @private\n   */\n  interceptServerData_(callback: ((a: string, b: any) => any) | null) {\n    this.interceptServerDataCallback_ = callback;\n  }\n\n  /**\n   * @param {!boolean} connectStatus\n   * @private\n   */\n  private onConnectStatus_(connectStatus: boolean) {\n    this.updateInfo_('connected', connectStatus);\n    if (connectStatus === false) {\n      this.runOnDisconnectEvents_();\n    }\n  }\n\n  /**\n   * @param {!Object} updates\n   * @private\n   */\n  private onServerInfoUpdate_(updates: Object) {\n    each(updates, (value: any, key: string) => {\n      this.updateInfo_(key, value);\n    });\n  }\n\n  /**\n   *\n   * @param {!string} pathString\n   * @param {*} value\n   * @private\n   */\n  private updateInfo_(pathString: string, value: any) {\n    const path = new Path('/.info/' + pathString);\n    const newNode = nodeFromJSON(value);\n    this.infoData_.updateSnapshot(path, newNode);\n    const events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n  }\n\n  /**\n   * @return {!number}\n   * @private\n   */\n  private getNextWriteId_(): number {\n    return this.nextWriteId_++;\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} newVal\n   * @param {number|string|null} newPriority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  setWithPriority(\n    path: Path,\n    newVal: any,\n    newPriority: number | string | null,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.log_('set', {\n      path: path.toString(),\n      value: newVal,\n      priority: newPriority\n    });\n\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);\n    const newNode = resolveDeferredValueSnapshot(\n      newNodeUnresolved,\n      serverValues\n    );\n\n    const writeId = this.getNextWriteId_();\n    const events = this.serverSyncTree_.applyUserOverwrite(\n      path,\n      newNode,\n      writeId,\n      true\n    );\n    this.eventQueue_.queueEvents(events);\n    this.server_.put(\n      path.toString(),\n      newNodeUnresolved.val(/*export=*/ true),\n      (status, errorReason) => {\n        const success = status === 'ok';\n        if (!success) {\n          warn('set at ' + path + ' failed: ' + status);\n        }\n\n        const clearEvents = this.serverSyncTree_.ackUserWrite(\n          writeId,\n          !success\n        );\n        this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n    const affectedPath = this.abortTransactions_(path);\n    this.rerunTransactions_(affectedPath);\n    // We queued the events above, so just flush the queue here\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {!Object} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  update(\n    path: Path,\n    childrenToMerge: { [k: string]: any },\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.log_('update', { path: path.toString(), value: childrenToMerge });\n\n    // Start with our existing data and merge each child into it.\n    let empty = true;\n    const serverValues = this.generateServerValues();\n    const changedChildren: { [k: string]: Node } = {};\n    forEach(childrenToMerge, (changedKey: string, changedValue: any) => {\n      empty = false;\n      const newNodeUnresolved = nodeFromJSON(changedValue);\n      changedChildren[changedKey] = resolveDeferredValueSnapshot(\n        newNodeUnresolved,\n        serverValues\n      );\n    });\n\n    if (!empty) {\n      const writeId = this.getNextWriteId_();\n      const events = this.serverSyncTree_.applyUserMerge(\n        path,\n        changedChildren,\n        writeId\n      );\n      this.eventQueue_.queueEvents(events);\n      this.server_.merge(\n        path.toString(),\n        childrenToMerge,\n        (status, errorReason) => {\n          const success = status === 'ok';\n          if (!success) {\n            warn('update at ' + path + ' failed: ' + status);\n          }\n\n          const clearEvents = this.serverSyncTree_.ackUserWrite(\n            writeId,\n            !success\n          );\n          const affectedPath =\n            clearEvents.length > 0 ? this.rerunTransactions_(path) : path;\n          this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\n          this.callOnCompleteCallback(onComplete, status, errorReason);\n        }\n      );\n\n      forEach(childrenToMerge, (changedPath: string) => {\n        const affectedPath = this.abortTransactions_(path.child(changedPath));\n        this.rerunTransactions_(affectedPath);\n      });\n\n      // We queued the events above, so just flush the queue here\n      this.eventQueue_.raiseEventsForChangedPath(path, []);\n    } else {\n      log(\"update() called with empty data.  Don't do anything.\");\n      this.callOnCompleteCallback(onComplete, 'ok');\n    }\n  }\n\n  /**\n   * Applies all of the changes stored up in the onDisconnect_ tree.\n   * @private\n   */\n  private runOnDisconnectEvents_() {\n    this.log_('onDisconnectEvents');\n\n    const serverValues = this.generateServerValues();\n    const resolvedOnDisconnectTree = resolveDeferredValueTree(\n      this.onDisconnect_,\n      serverValues\n    );\n    let events: Event[] = [];\n\n    resolvedOnDisconnectTree.forEachTree(Path.Empty, (path, snap) => {\n      events = events.concat(\n        this.serverSyncTree_.applyServerOverwrite(path, snap)\n      );\n      const affectedPath = this.abortTransactions_(path);\n      this.rerunTransactions_(affectedPath);\n    });\n\n    this.onDisconnect_ = new SparseSnapshotTree();\n    this.eventQueue_.raiseEventsForChangedPath(Path.Empty, events);\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectCancel(\n    path: Path,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.server_.onDisconnectCancel(path.toString(), (status, errorReason) => {\n      if (status === 'ok') {\n        this.onDisconnect_.forget(path);\n      }\n      this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectSet(\n    path: Path,\n    value: any,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    const newNode = nodeFromJSON(value);\n    this.server_.onDisconnectPut(\n      path.toString(),\n      newNode.val(/*export=*/ true),\n      (status, errorReason) => {\n        if (status === 'ok') {\n          this.onDisconnect_.remember(path, newNode);\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {*} priority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectSetWithPriority(\n    path: Path,\n    value: any,\n    priority: any,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    const newNode = nodeFromJSON(value, priority);\n    this.server_.onDisconnectPut(\n      path.toString(),\n      newNode.val(/*export=*/ true),\n      (status, errorReason) => {\n        if (status === 'ok') {\n          this.onDisconnect_.remember(path, newNode);\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectUpdate(\n    path: Path,\n    childrenToMerge: { [k: string]: any },\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    if (isEmpty(childrenToMerge)) {\n      log(\n        \"onDisconnect().update() called with empty data.  Don't do anything.\"\n      );\n      this.callOnCompleteCallback(onComplete, 'ok');\n      return;\n    }\n\n    this.server_.onDisconnectMerge(\n      path.toString(),\n      childrenToMerge,\n      (status, errorReason) => {\n        if (status === 'ok') {\n          forEach(childrenToMerge, (childName: string, childNode: any) => {\n            const newChildNode = nodeFromJSON(childNode);\n            this.onDisconnect_.remember(path.child(childName), newChildNode);\n          });\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   */\n  addEventCallbackForQuery(query: Query, eventRegistration: EventRegistration) {\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.addEventRegistration(\n        query,\n        eventRegistration\n      );\n    } else {\n      events = this.serverSyncTree_.addEventRegistration(\n        query,\n        eventRegistration\n      );\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  /**\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration\n   */\n  removeEventCallbackForQuery(\n    query: Query,\n    eventRegistration: EventRegistration\n  ) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.removeEventRegistration(\n        query,\n        eventRegistration\n      );\n    } else {\n      events = this.serverSyncTree_.removeEventRegistration(\n        query,\n        eventRegistration\n      );\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  interrupt() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n  }\n\n  resume() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n  }\n\n  stats(showDelta: boolean = false) {\n    if (typeof console === 'undefined') return;\n\n    let stats: { [k: string]: any };\n    if (showDelta) {\n      if (!this.statsListener_)\n        this.statsListener_ = new StatsListener(this.stats_);\n      stats = this.statsListener_.get();\n    } else {\n      stats = this.stats_.get();\n    }\n\n    const longestName = Object.keys(stats).reduce(\n      (previousValue, currentValue) =>\n        Math.max(currentValue.length, previousValue),\n      0\n    );\n\n    forEach(stats, (stat: string, value: any) => {\n      // pad stat names to be the same length (plus 2 extra spaces).\n      for (let i = stat.length; i < longestName + 2; i++) stat += ' ';\n      console.log(stat + value);\n    });\n  }\n\n  statsIncrementCounter(metric: string) {\n    this.stats_.incrementCounter(metric);\n    this.statsReporter_.includeStat(metric);\n  }\n\n  /**\n   * @param {...*} var_args\n   * @private\n   */\n  private log_(...var_args: any[]) {\n    let prefix = '';\n    if (this.persistentConnection_) {\n      prefix = this.persistentConnection_.id + ':';\n    }\n    log(prefix, ...var_args);\n  }\n\n  /**\n   * @param {?function(?Error, *=)} callback\n   * @param {!string} status\n   * @param {?string=} errorReason\n   */\n  callOnCompleteCallback(\n    callback: ((status: Error | null, errorReason?: string) => void) | null,\n    status: string,\n    errorReason?: string | null\n  ) {\n    if (callback) {\n      exceptionGuard(function() {\n        if (status == 'ok') {\n          callback(null);\n        } else {\n          const code = (status || 'error').toUpperCase();\n          let message = code;\n          if (errorReason) message += ': ' + errorReason;\n\n          const error = new Error(message);\n          (error as any).code = code;\n          callback(error);\n        }\n      });\n    }\n  }\n\n  get database(): Database {\n    return this.__database || (this.__database = new Database(this));\n  }\n}\n"]},"metadata":{},"sourceType":"script"}