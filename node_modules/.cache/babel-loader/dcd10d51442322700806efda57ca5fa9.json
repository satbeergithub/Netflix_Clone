{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as errorsExports from './error';\nimport * as MetadataUtils from './metadata';\nimport * as type from './type';\n/**\n * @param name Name of the function.\n * @param specs Argument specs.\n * @param passed The actual arguments passed to the function.\n * @throws {fbs.Error} If the arguments are invalid.\n */\nexport function validate(name, specs, passed) {\n  var minArgs = specs.length;\n  var maxArgs = specs.length;\n  for (var i = 0; i < specs.length; i++) {\n    if (specs[i].optional) {\n      minArgs = i;\n      break;\n    }\n  }\n  var validLength = minArgs <= passed.length && passed.length <= maxArgs;\n  if (!validLength) {\n    throw errorsExports.invalidArgumentCount(minArgs, maxArgs, name, passed.length);\n  }\n  for (var i = 0; i < passed.length; i++) {\n    try {\n      specs[i].validator(passed[i]);\n    } catch (e) {\n      if (e instanceof Error) {\n        throw errorsExports.invalidArgument(i, name, e.message);\n      } else {\n        throw errorsExports.invalidArgument(i, name, e);\n      }\n    }\n  }\n}\n/**\n * @struct\n */\nvar ArgSpec = /** @class */function () {\n  function ArgSpec(validator, opt_optional) {\n    var self = this;\n    this.validator = function (p) {\n      if (self.optional && !type.isJustDef(p)) {\n        return;\n      }\n      validator(p);\n    };\n    this.optional = !!opt_optional;\n  }\n  return ArgSpec;\n}();\nexport { ArgSpec };\nexport function and_(v1, v2) {\n  return function (p) {\n    v1(p);\n    v2(p);\n  };\n}\nexport function stringSpec(opt_validator, opt_optional) {\n  function stringValidator(p) {\n    if (!type.isString(p)) {\n      throw 'Expected string.';\n    }\n  }\n  var validator;\n  if (opt_validator) {\n    validator = and_(stringValidator, opt_validator);\n  } else {\n    validator = stringValidator;\n  }\n  return new ArgSpec(validator, opt_optional);\n}\nexport function uploadDataSpec() {\n  function validator(p) {\n    var valid = p instanceof Uint8Array || p instanceof ArrayBuffer || type.isNativeBlobDefined() && p instanceof Blob;\n    if (!valid) {\n      throw 'Expected Blob or File.';\n    }\n  }\n  return new ArgSpec(validator);\n}\nexport function metadataSpec(opt_optional) {\n  return new ArgSpec(MetadataUtils.metadataValidator, opt_optional);\n}\nexport function nonNegativeNumberSpec() {\n  function validator(p) {\n    var valid = type.isNumber(p) && p >= 0;\n    if (!valid) {\n      throw 'Expected a number 0 or greater.';\n    }\n  }\n  return new ArgSpec(validator);\n}\nexport function looseObjectSpec(opt_validator, opt_optional) {\n  function validator(p) {\n    var isLooseObject = p === null || type.isDef(p) && p instanceof Object;\n    if (!isLooseObject) {\n      throw 'Expected an Object.';\n    }\n    if (opt_validator !== undefined && opt_validator !== null) {\n      opt_validator(p);\n    }\n  }\n  return new ArgSpec(validator, opt_optional);\n}\nexport function nullFunctionSpec(opt_optional) {\n  function validator(p) {\n    var valid = p === null || type.isFunction(p);\n    if (!valid) {\n      throw 'Expected a Function.';\n    }\n  }\n  return new ArgSpec(validator, opt_optional);\n}","map":{"version":3,"mappings":"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","names":["errorsExports","MetadataUtils","type","name","specs","passed","minArgs","length","maxArgs","i","optional","validLength","invalidArgumentCount","validator","e","Error","invalidArgument","message","opt_optional","self","p","isJustDef","v1","v2","opt_validator","isString","and_","stringValidator","ArgSpec","valid","Uint8Array","ArrayBuffer","isNativeBlobDefined","Blob","metadataValidator","isNumber","isLooseObject","isDef","Object","undefined","isFunction"],"sources":["../src/implementation/args.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as errorsExports from './error';\nimport { errors } from './error';\nimport * as MetadataUtils from './metadata';\nimport * as type from './type';\n\n/**\n * @param name Name of the function.\n * @param specs Argument specs.\n * @param passed The actual arguments passed to the function.\n * @throws {fbs.Error} If the arguments are invalid.\n */\nexport function validate(name: string, specs: ArgSpec[], passed: IArguments) {\n  let minArgs = specs.length;\n  let maxArgs = specs.length;\n  for (let i = 0; i < specs.length; i++) {\n    if (specs[i].optional) {\n      minArgs = i;\n      break;\n    }\n  }\n  let validLength = minArgs <= passed.length && passed.length <= maxArgs;\n  if (!validLength) {\n    throw errorsExports.invalidArgumentCount(\n      minArgs,\n      maxArgs,\n      name,\n      passed.length\n    );\n  }\n  for (let i = 0; i < passed.length; i++) {\n    try {\n      specs[i].validator(passed[i]);\n    } catch (e) {\n      if (e instanceof Error) {\n        throw errorsExports.invalidArgument(i, name, e.message);\n      } else {\n        throw errorsExports.invalidArgument(i, name, e);\n      }\n    }\n  }\n}\n\n/**\n * @struct\n */\nexport class ArgSpec {\n  validator: (p1: any) => void;\n  optional: boolean;\n\n  constructor(validator: (p1: any) => void, opt_optional?: boolean) {\n    let self = this;\n    this.validator = function(p: any) {\n      if (self.optional && !type.isJustDef(p)) {\n        return;\n      }\n      validator(p);\n    };\n    this.optional = !!opt_optional;\n  }\n}\n\nexport function and_(v1: (p1: any) => void, v2: Function): (p1: any) => void {\n  return function(p) {\n    v1(p);\n    v2(p);\n  };\n}\n\nexport function stringSpec(\n  opt_validator?: (p1: any) => void | null,\n  opt_optional?: boolean\n): ArgSpec {\n  function stringValidator(p: any) {\n    if (!type.isString(p)) {\n      throw 'Expected string.';\n    }\n  }\n  let validator;\n  if (opt_validator) {\n    validator = and_(stringValidator, opt_validator);\n  } else {\n    validator = stringValidator;\n  }\n  return new ArgSpec(validator, opt_optional);\n}\n\nexport function uploadDataSpec(): ArgSpec {\n  function validator(p: any) {\n    let valid =\n      p instanceof Uint8Array ||\n      p instanceof ArrayBuffer ||\n      (type.isNativeBlobDefined() && p instanceof Blob);\n    if (!valid) {\n      throw 'Expected Blob or File.';\n    }\n  }\n  return new ArgSpec(validator);\n}\n\nexport function metadataSpec(opt_optional?: boolean): ArgSpec {\n  return new ArgSpec(MetadataUtils.metadataValidator, opt_optional);\n}\n\nexport function nonNegativeNumberSpec(): ArgSpec {\n  function validator(p: any) {\n    let valid = type.isNumber(p) && p >= 0;\n    if (!valid) {\n      throw 'Expected a number 0 or greater.';\n    }\n  }\n  return new ArgSpec(validator);\n}\n\nexport function looseObjectSpec(\n  opt_validator?: ((p1: any) => void) | null,\n  opt_optional?: boolean\n): ArgSpec {\n  function validator(p: any) {\n    let isLooseObject = p === null || (type.isDef(p) && p instanceof Object);\n    if (!isLooseObject) {\n      throw 'Expected an Object.';\n    }\n    if (opt_validator !== undefined && opt_validator !== null) {\n      opt_validator(p);\n    }\n  }\n  return new ArgSpec(validator, opt_optional);\n}\n\nexport function nullFunctionSpec(opt_optional?: boolean): ArgSpec {\n  function validator(p: any) {\n    let valid = p === null || type.isFunction(p);\n    if (!valid) {\n      throw 'Expected a Function.';\n    }\n  }\n  return new ArgSpec(validator, opt_optional);\n}\n"]},"metadata":{},"sourceType":"module"}